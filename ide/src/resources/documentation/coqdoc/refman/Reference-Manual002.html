<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<LINK rel="stylesheet" type="text/css" href="Reference-Manual.css">
<TITLE>Credits</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual001.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual003.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter">Credits</H1><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN>  is a proof assistant for higher-order logic, allowing the
development of computer programs consistent with their formal
specification. It is the result of about ten years of research of the
Coq project. We shall briefly survey here three main aspects: the
<EM>logical language</EM> in which we write our axiomatizations and
specifications, the <EM>proof assistant</EM> which allows the development
of verified mathematical proofs, and the <EM>program extractor</EM> which
synthesizes computer programs obeying their formal specifications,
written as logical assertions in the language.</P><P>The logical language used by <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is a variety of type theory,
called the <EM>Calculus of Inductive Constructions</EM>. Without going
back to Leibniz and Boole, we can date the creation of what is now
called mathematical logic to the work of Frege and Peano at the turn
of the century. The discovery of antinomies in the free use of
predicates or comprehension principles prompted Russell to restrict
predicate calculus with a stratification of <EM>types</EM>. This effort
culminated with <EM>Principia Mathematica</EM>, the first systematic
attempt at a formal foundation of mathematics. A simplification of
this system along the lines of simply typed &#X3BB;-calculus
occurred with Church's <EM>Simple Theory of Types</EM>. The
&#X3BB;-calculus notation, originally used for expressing
functionality, could also be used as an encoding of natural deduction
proofs. This Curry-Howard isomorphism was used by N. de Bruijn in the
<EM>Automath</EM> project, the first full-scale attempt to develop and
mechanically verify mathematical proofs. This effort culminated with
Jutting's verification of Landau's <EM>Grundlagen</EM> in the 1970's.
Exploiting this Curry-Howard isomorphism, notable achievements in
proof theory saw the emergence of two type-theoretic frameworks; the
first one, Martin-Löf's <EM>Intuitionistic Theory of Types</EM>,
attempts a new foundation of mathematics on constructive principles.
The second one, Girard's polymorphic &#X3BB;-calculus <I>F</I><SUB>&#X3C9;</SUB>, is
a very strong functional system in which we may represent higher-order
logic proof structures. Combining both systems in a higher-order
extension of the Automath languages, T. Coquand presented in 1985 the
first version of the <EM>Calculus of Constructions</EM>, CoC. This strong
logical system allowed powerful axiomatizations, but direct inductive
definitions were not possible, and inductive notions had to be defined
indirectly through functional encodings, which introduced
inefficiencies and awkwardness. The formalism was extended in 1989 by
T. Coquand and C. Paulin with primitive inductive definitions, leading
to the current <EM>Calculus of Inductive Constructions</EM>. This
extended formalism is not rigorously defined here. Rather, numerous
concrete examples are discussed. We refer the interested reader to
relevant research papers for more information about the formalism, its
meta-theoretic properties, and semantics. However, it should not be
necessary to understand this theoretical material in order to write
specifications. It is possible to understand the Calculus of Inductive
Constructions at a higher level, as a mixture of predicate calculus,
inductive predicate definitions presented as typed PROLOG, and
recursive function definitions close to the language ML.</P><P>Automated theorem-proving was pioneered in the 1960's by Davis and
Putnam in propositional calculus. A complete mechanization (in the
sense of a semi-decision procedure) of classical first-order logic was
proposed in 1965 by J.A. Robinson, with a single uniform inference
rule called <EM>resolution</EM>. Resolution relies on solving equations
in free algebras (i.e. term structures), using the <EM>unification
algorithm</EM>. Many refinements of resolution were studied in the
1970's, but few convincing implementations were realized, except of
course that PROLOG is in some sense issued from this effort. A less
ambitious approach to proof development is computer-aided
proof-checking. The most notable proof-checkers developed in the
1970's were LCF, designed by R. Milner and his colleagues at U.
Edinburgh, specialized in proving properties about denotational
semantics recursion equations, and the Boyer and Moore theorem-prover,
an automation of primitive recursion over inductive data types. While
the Boyer-Moore theorem-prover attempted to synthesize proofs by a
combination of automated methods, LCF constructed its proofs through
the programming of <EM>tactics</EM>, written in a high-level functional
meta-language, ML.</P><P>The salient feature which clearly distinguishes our proof assistant
from say LCF or Boyer and Moore's, is its possibility to extract
programs from the constructive contents of proofs. This computational
interpretation of proof objects, in the tradition of Bishop's
constructive mathematics, is based on a realizability interpretation,
in the sense of Kleene, due to C. Paulin. The user must just mark his
intention by separating in the logical statements the assertions
stating the existence of a computational object from the logical
assertions which specify its properties, but which may be considered
as just comments in the corresponding program. Given this information,
the system automatically extracts a functional term from a consistency
proof of its specifications. This functional term may be in turn
compiled into an actual computer program. This methodology of
extracting programs from proofs is a revolutionary paradigm for
software engineering. Program synthesis has long been a theme of
research in artificial intelligence, pioneered by R. Waldinger. The
Tablog system of Z. Manna and R. Waldinger allows the deductive
synthesis of functional programs from proofs in tableau form of their
specifications, written in a variety of first-order logic. Development
of a systematic <EM>programming logic</EM>, based on extensions of
Martin-Löf's type theory, was undertaken at Cornell U. by the Nuprl
team, headed by R. Constable. The first actual program extractor, PX,
was designed and implemented around 1985 by S. Hayashi from Kyoto
University. It allows the extraction of a LISP program from a proof
in a logical system inspired by the logical formalisms of S. Feferman.
Interest in this methodology is growing in the theoretical computer
science community. We can foresee the day when actual computer systems
used in applications will contain certified modules, automatically
generated from a consistency proof of their formal specifications. We
are however still far from being able to use this methodology in a
smooth interaction with the standard tools from software engineering,
i.e. compilers, linkers, run-time systems taking advantage of special
hardware, debuggers, and the like. We hope that <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can be of use
to researchers interested in experimenting with this new methodology.</P><P>A first implementation of CoC was started in 1984 by G. Huet and T.
Coquand. Its implementation language was CAML, a functional
programming language from the ML family designed at INRIA in
Rocquencourt. The core of this system was a proof-checker for CoC seen
as a typed &#X3BB;-calculus, called the <EM>Constructive Engine</EM>.
This engine was operated through a high-level notation permitting the
declaration of axioms and parameters, the definition of mathematical
types and objects, and the explicit construction of proof objects
encoded as &#X3BB;-terms. A section mechanism, designed and
implemented by G. Dowek, allowed hierarchical developments of
mathematical theories. This high-level language was called the
<EM>Mathematical Vernacular</EM>. Furthermore, an interactive
<EM>Theorem Prover</EM> permitted the incremental construction of proof
trees in a top-down manner, subgoaling recursively and backtracking
from dead-alleys. The theorem prover executed tactics written in CAML,
in the LCF fashion. A basic set of tactics was predefined, which the
user could extend by his own specific tactics. This system (Version
4.10) was released in 1989. Then, the system was extended to deal
with the new calculus with inductive types by C. Paulin, with
corresponding new tactics for proofs by induction. A new standard set
of tactics was streamlined, and the vernacular extended for tactics
execution. A package to compile programs extracted from proofs to
actual computer programs in CAML or some other functional language was
designed and implemented by B. Werner. A new user-interface, relying
on a CAML-X interface by D. de Rauglaudre, was designed and
implemented by A. Felty. It allowed operation of the theorem-prover
through the manipulation of windows, menus, mouse-sensitive buttons,
and other widgets. This system (Version 5.6) was released in 1991.</P><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> was ported to the new implementation Caml-light of X. Leroy and
D. Doligez by D. de Rauglaudre (Version 5.7) in 1992. A new version
of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> was then coordinated by C. Murthy, with new tools designed
by C. Parent to prove properties of ML programs (this methodology is
dual to program extraction) and a new user-interaction loop. This
system (Version 5.8) was released in May 1993. A Centaur interface
<SPAN STYLE="font-variant:small-caps">CTCoq</SPAN> was then developed by Y. Bertot from the Croap project
from INRIA-Sophia-Antipolis.</P><P>In parallel, G. Dowek and H. Herbelin developed a new proof engine,
allowing the general manipulation of existential variables
consistently with dependent types in an experimental version of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
(V5.9).</P><P>The version V5.10 of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on a generic system for
manipulating terms with binding operators due to Chet Murthy. A new
proof engine allows the parallel development of partial proofs for
independent subgoals. The structure of these proof trees is a mixed
representation of derivation trees for the Calculus of Inductive
Constructions with abstract syntax trees for the tactics scripts,
allowing the navigation in a proof at various levels of details. The
proof engine allows generic environment items managed in an
object-oriented way. This new architecture, due to C. Murthy,
supports several new facilities which make the system easier to extend
and to scale up:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
User-programmable tactics are allowed
</LI><LI CLASS="li-itemize">It is possible to separately verify development modules, and to
load their compiled images without verifying them again - a quick
relocation process allows their fast loading
</LI><LI CLASS="li-itemize">A generic parsing scheme allows user-definable notations, with a
symmetric table-driven pretty-printer
</LI><LI CLASS="li-itemize">Syntactic definitions allow convenient abbreviations
</LI><LI CLASS="li-itemize">A limited facility of meta-variables allows the automatic
synthesis of certain type expressions, allowing generic notations
for e.g. equality, pairing, and existential quantification.
</LI></UL><P>In the Fall of 1994, C. Paulin-Mohring replaced the structure of
inductively defined types and families by a new structure, allowing
the mutually recursive definitions. P. Manoury implemented a
translation of recursive definitions into the primitive recursive
style imposed by the internal recursion operators, in the style of the
ProPre system. C. Muñoz implemented a decision procedure for
intuitionistic propositional logic, based on results of R. Dyckhoff.
J.C. Filliâtre implemented a decision procedure for first-order
logic without contraction, based on results of J. Ketonen and R.
Weyhrauch. Finally C. Murthy implemented a library of inversion
tactics, relieving the user from tedious definitions of &#X201C;inversion
predicates&#X201D;.</P><DIV CLASS="flushright">
Rocquencourt, Feb. 1st 1995<BR>
Gérard Huet
</DIV><H2 CLASS="section"><A NAME="toc3"></A>Credits: addendum for version 6.1</H2><P>The present version 6.1 of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on the V5.10 architecture. It
was ported to the new language Objective Caml by Bruno Barras. The
underlying framework has slightly changed and allows more conversions
between sorts. </P><P>The new version provides powerful tools for easier developments. </P><P>Cristina Cornes designed an extension of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> syntax to allow
definition of terms using a powerful pattern-matching analysis in the
style of ML programs.</P><P>Amokrane Saïbi wrote a mechanism to simulate
inheritance between types families extending a proposal by Peter
Aczel. He also developed a mechanism to automatically compute which
arguments of a constant may be inferred by the system and consequently
do not need to be explicitly written. </P><P>Yann Coscoy designed a command which explains a proof term using
natural language. Pierre Crégut built a new tactic which solves
problems in quantifier-free Presburger Arithmetic. Both
functionalities have been integrated to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system by Hugo
Herbelin.</P><P>Samuel Boutin designed a tactic for simplification of commutative
rings using a canonical set of rewriting rules and equality modulo
associativity and commutativity. </P><P>Finally the organisation of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> distribution has been supervised
by Jean-Christophe Filliâtre with the help of Judicaël Courant
and Bruno Barras.</P><DIV CLASS="flushright">
Lyon, Nov. 18th 1996<BR>
Christine Paulin
</DIV><H2 CLASS="section"><A NAME="toc4"></A>Credits: addendum for version 6.2</H2><P>In version 6.2 of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, the parsing is done using camlp4, a
preprocessor and pretty-printer for CAML designed by Daniel de
Rauglaudre at INRIA. Daniel de Rauglaudre made the first adaptation
of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> for camlp4, this work was continued by Bruno Barras who also
changed the structure of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> abstract syntax trees and the primitives
to manipulate them. The result of
these changes is a faster parsing procedure with greatly improved
syntax-error messages. The user-interface to introduce grammar or
pretty-printing rules has also changed.</P><P>Eduardo Giménez redesigned the internal 
tactic libraries, giving uniform names 
to Caml functions corresponding to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tactic names. </P><P>Bruno Barras wrote new more efficient reductions functions.</P><P>Hugo Herbelin introduced more uniform notations in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
specification language: the definitions by fixpoints and
pattern-matching have a more readable syntax. Patrick Loiseleur
introduced user-friendly notations for arithmetic expressions.</P><P>New tactics were introduced: Eduardo Giménez improved a mechanism to
introduce macros for tactics, and designed special tactics for
(co)inductive definitions; Patrick Loiseleur designed a tactic to
simplify polynomial expressions in an arbitrary commutative ring which
generalizes the previous tactic implemented by Samuel Boutin.
Jean-Christophe Filliâtre introduced a tactic for refining a goal,
using a proof term with holes as a proof scheme.</P><P>David Delahaye designed the <FONT COLOR=purple>SearchIsos</FONT> tool to search an
object in the library given its type (up to isomorphism).</P><P>Henri Laulhère produced the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> distribution for the Windows environment. </P><P>Finally, Hugo Herbelin was the main coordinator of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
documentation with principal contributions by Bruno Barras, David Delahaye, 
Jean-Christophe Filliâtre, Eduardo
Giménez, Hugo Herbelin and Patrick Loiseleur. </P><DIV CLASS="flushright">
Orsay, May 4th 1998<BR>
Christine Paulin
</DIV><H2 CLASS="section"><A NAME="toc5"></A>Credits: addendum for version 6.3</H2><P>
The main changes in version V6.3 was the introduction of a few new tactics
and the extension of the guard condition for fixpoint definitions.</P><P>B. Barras extended the unification algorithm to complete partial terms
and solved various tricky bugs related to universes.<BR>
D. Delahaye developed the <TT>AutoRewrite</TT> tactic. He also designed the new
behavior of <TT>Intro</TT> and provided the tacticals <TT>First</TT> and
<TT>Solve</TT>.<BR>
J.-C. Filliâtre developed the <TT>Correctness</TT> tactic.<BR>
E. Giménez extended the guard condition in fixpoints.<BR>
H. Herbelin designed the new syntax for definitions and extended the
<TT>Induction</TT> tactic.<BR>
P. Loiseleur developed the <TT>Quote</TT> tactic and 
the new design of the <TT>Auto</TT>
tactic, he also introduced the index of
errors in the documentation.<BR>
C. Paulin wrote the <TT>Focus</TT> command and introduced 
the reduction functions in definitions, this last feature 
was proposed by J.-F. Monin from CNET Lannion. </P><DIV CLASS="flushright">
Orsay, Dec. 1999<BR>
Christine Paulin
</DIV><H2 CLASS="section"><A NAME="toc6"></A>Credits: versions 7</H2><P>The version V7 is a new implementation started in September 1999 by
Jean-Christophe Filliâtre. This is a major revision with respect to
the internal architecture of the system. The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> version 7.0 was
distributed in March 2001, version 7.1 in September 2001, version
7.2 in January 2002, version 7.3 in May 2002 and version 7.4 in
February 2003.</P><P>Jean-Christophe Filliâtre designed the architecture of the new system, he
introduced a new representation for environments and wrote a new kernel
for type-checking terms. His approach was to use functional
data-structures in order to get more sharing, to prepare the addition
of modules and also to get closer to a certified kernel.</P><P>Hugo Herbelin introduced a new structure of terms with local
definitions. He introduced &#X201C;qualified&#X201D; names, wrote a new
pattern-matching compilation algorithm and designed a more compact
algorithm for checking the logical consistency of universes. He
contributed to the simplification of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> internal structures and the
optimisation of the system. He added basic tactics for forward
reasoning and coercions in patterns.</P><P>David Delahaye introduced a new language for tactics. General tactics
using pattern-matching on goals and context can directly be written
from the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel. He also provided primitives for the design
of user-defined tactics in <SPAN STYLE="font-variant:small-caps">Caml</SPAN>.</P><P>Micaela Mayero contributed the library on real numbers.
Olivier Desmettre extended this library with axiomatic
trigonometric functions, square, square roots, finite sums, Chasles
property and basic plane geometry.</P><P>Jean-Christophe Filliâtre and Pierre Letouzey redesigned a new
extraction procedure from <SPAN STYLE="font-variant:small-caps">Coq</SPAN> terms to <SPAN STYLE="font-variant:small-caps">Caml</SPAN> or
<SPAN STYLE="font-variant:small-caps">Haskell</SPAN> programs. This new 
extraction procedure, unlike the one implemented in previous version
of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is able to handle all terms in the Calculus of Inductive
Constructions, even involving universes and strong elimination. P.
Letouzey adapted user contributions to extract ML programs when it was
sensible.
Jean-Christophe Filliâtre wrote <CODE>coqdoc</CODE>, a documentation
tool for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> libraries usable from version 7.2.</P><P>Bruno Barras improved the reduction algorithms efficiency and
the confidence level in the correctness of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> critical type-checking
algorithm.</P><P>Yves Bertot designed the <TT>SearchPattern</TT> and
<TT>SearchRewrite</TT> tools and the support for the <SPAN STYLE="font-variant:small-caps">pcoq</SPAN> interface 
(<TT>http://www-sop.inria.fr/lemme/pcoq/</TT>).</P><P>Micaela Mayero and David Delahaye introduced <TT>Field</TT>, a decision tactic for commutative fields.</P><P>Christine Paulin changed the elimination rules for empty and singleton
propositional inductive types.</P><P>Loïc Pottier developed <TT>Fourier</TT>, a tactic solving linear inequalities on real numbers.</P><P>Pierre Crégut developed a new version based on reflexion of the <TT>Omega</TT>
decision tactic.</P><P>Claudio Sacerdoti Coen designed an XML output for the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
modules to be used in the Hypertextual Electronic Library of
Mathematics (HELM cf <TT>http://www.cs.unibo.it/helm</TT>).</P><P>A library for efficient representation of finite maps using binary trees
contributed by Jean Goubault was integrated in the basic theories.</P><P>Pierre Courtieu developed a command and a tactic to reason on the
inductive structure of recursively defined functions.</P><P>Jacek Chrz&#X105;szcz designed and implemented the module system of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> whose foundations are in Judicaël Courant's PhD thesis.</P><P><BR>
<BR>
</P><P>The development was coordinated by C. Paulin.</P><P>Many discussions within the Démons team and the LogiCal project
influenced significantly the design of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> especially with 
J. Courant, J. Duprat, J. Goubault, A. Miquel,
C. Marché, B. Monate and B. Werner.</P><P>Intensive users suggested improvements of the system : 
Y. Bertot, L. Pottier, L. Théry, P. Zimmerman from INRIA, 
C. Alvarado, P. Crégut, J.-F. Monin from France Telecom R &amp; D.
</P><DIV CLASS="flushright">
Orsay, May. 2002<BR>
Hugo Herbelin &amp; Christine Paulin
</DIV><H2 CLASS="section"><A NAME="toc7"></A>Credits: version 8.0</H2><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> version 8 is a major revision of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> proof assistant.
First, the underlying logic is slightly different. The so-called <EM>impredicativity</EM> of the sort <TT>Set</TT> has been dropped. The main
reason is that it is inconsistent with the principle of description
which is quite a useful principle for formalizing mathematics within classical logic. Moreover, even in an constructive
setting, the impredicativity of <TT>Set</TT> does not add so much in
practice and is even subject of criticism from a large part of the
intuitionistic mathematician community. Nevertheless, the
impredicativity of <TT>Set</TT> remains optional for users interested in
investigating mathematical developments which rely on it.</P><P>Secondly, the concrete syntax of terms has been completely
revised. The main motivations were</P><UL CLASS="itemize"><LI CLASS="li-itemize">
a more uniform, purified style: all constructions are now lowercase, 
with a functional programming perfume (e.g. abstraction is now
written <TT>fun</TT>), and more directly accessible to the novice
(e.g. dependent product is now written <TT>forall</TT> and allows
omission of types). Also, parentheses and are no longer mandatory
for function application.
</LI><LI CLASS="li-itemize">extensibility: some standard notations (e.g. &#X201C;&lt;&#X201D; and &#X201C;&gt;&#X201D;) were
incompatible with the previous syntax. Now all standard arithmetic
notations (=, +, *, /, &lt;, &lt;=, ... and more) are directly part of the
syntax.
</LI></UL><P>Together with the revision of the concrete syntax, a new mechanism of
<EM>interpretation scopes</EM> permits to reuse the same symbols
(typically +, -, *, /, &lt;, &lt;=) in various mathematical theories without
any ambiguities for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, leading to a largely improved readability of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> scripts. New commands to easily add new symbols are also
provided.</P><P>Coming with the new syntax of terms, a slight reform of the tactic
language and of the language of commands has been carried out. The
purpose here is a better uniformity making the tactics and commands
easier to use and to remember.</P><P>Thirdly, a restructuration and uniformisation of the standard library
of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> has been performed. There is now just one Leibniz' equality
usable for all the different kinds of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> objects. Also, the set of
real numbers now lies at the same level as the sets of natural and
integer numbers. Finally, the names of the standard properties of
numbers now follow a standard pattern and the symbolic
notations for the standard definitions as well.</P><P>The fourth point is the release of <SPAN STYLE="font-variant:small-caps">CoqIDE</SPAN>, a new graphical
gtk2-based interface fully integrated to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Close in style from
the Proof General Emacs interface, it is faster and its integration
with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> makes interactive developments more friendly. All
mathematical Unicode symbols are usable within <SPAN STYLE="font-variant:small-caps">CoqIDE</SPAN>.</P><P>Finally, the module system of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> completes the picture of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
version 8.0. Though released with an experimental status in the previous
version 7.4, it should be considered as a salient feature of the new
version.</P><P>Besides, <SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with its load of novelties and improvements: new
or improved tactics (including a new tactic for solving first-order
statements), new management commands, extended libraries.</P><P><BR>
<BR>
</P><P>Bruno Barras and Hugo Herbelin have been the main contributors of the 
reflexion and the implementation of the new syntax. The smart
automatic translator from old to new syntax released with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is also
their work with contributions by Olivier Desmettre.</P><P>Hugo Herbelin is the main designer and implementor of the notion of
interpretation scopes and of the commands for easily adding new notations.</P><P>Hugo Herbelin is the main implementor of the restructuration of the
standard library.</P><P>Pierre Corbineau is the main designer and implementor of the new
tactic for solving first-order statements in presence of inductive
types. He is also the maintainer of the non-domain specific automation
tactics.</P><P>Benjamin Monate is the developer of the <SPAN STYLE="font-variant:small-caps">CoqIDE</SPAN> graphical
interface with contributions by Jean-Christophe Filliâtre, Pierre
Letouzey, Claude Marché and Bruno Barras.</P><P>Claude Marché coordinated the edition of the Reference Manual for
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> V8.0.</P><P>Pierre Letouzey and Jacek Chrz&#X105;szcz respectively maintained the
extraction tool and module system of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><P>Jean-Christophe Filliâtre, Pierre Letouzey, Hugo Herbelin and 
contributors from Sophia-Antipolis and Nijmegen participated to the
extension of the library.</P><P>Julien Narboux built a NSIS-based automatic <SPAN STYLE="font-variant:small-caps">Coq</SPAN> installation tool for
the Windows platform.</P><P>Hugo Herbelin and Christine Paulin coordinated the development which
was under the responsability of Christine Paulin.</P><DIV CLASS="flushright">
Palaiseau &amp; Orsay, Apr. 2004<BR>
Hugo Herbelin &amp; Christine Paulin<BR>
(updated Apr. 2006)
</DIV><H2 CLASS="section"><A NAME="toc8"></A>Credits: version 8.1</H2><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> version 8.1 adds various new functionalities.</P><P>Benjamin Grégoire implemented an alternative algorithm to check the
convertibility of terms in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> type-checker. This alternative
algorithm works by compilation to an efficient bytecode that is
interpreted in an abstract machine similar to Xavier Leroy's ZINC
machine. Convertibility is performed by comparing the normal
forms. This alternative algorithm is specifically interesting for
proofs by reflection. More generally, it is convenient in case of
intensive computations.</P><P>Christine Paulin implemented an extension of inductive types allowing
recursively non uniform parameters. Hugo Herbelin implemented
sort-polymorphism for inductive types.</P><P>Claudio Sacerdoti Coen improved the tactics for rewriting on arbitrary
compatible equivalence relations. He also generalized rewriting to
arbitrary transition systems.</P><P>Claudio Sacerdoti Coen added new features to the module system. </P><P>Benjamin Grégoire, Assia Mahboubi and Bruno Barras developed a new
more efficient and more general simplification algorithm on rings and
semi-rings.</P><P>Laurent Théry and Bruno Barras developed a new significantly more efficient
simplification algorithm on fields.</P><P>Hugo Herbelin, Pierre Letouzey, Julien Forest, Julien Narboux and
Claudio Sacerdoti Coen added new tactic features.</P><P>Hugo Herbelin implemented matching on disjunctive patterns.</P><P>New mechanisms made easier the communication between <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and external
provers. Nicolas Ayache and Jean-Christophe Filliâtre implemented
connections with the provers <SPAN STYLE="font-variant:small-caps">cvcl</SPAN>, <SPAN STYLE="font-variant:small-caps">Simplify</SPAN> and <SPAN STYLE="font-variant:small-caps">zenon</SPAN>. Hugo Herbelin implemented an experimental protocol for calling
external tools from the tactic language.</P><P>Matthieu Sozeau developed <SPAN STYLE="font-variant:small-caps">Russell</SPAN>, an experimental language
to specify the behavior of programs with subtypes.</P><P>A mechanism to automatically use some specific tactic to solve
unresolved implicit has been implemented by Hugo Herbelin.</P><P>Laurent Théry's contribution on strings and Pierre Letouzey and
Jean-Christophe Filliâtre's contribution on finite maps have been
integrated to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library. Pierre Letouzey developed a
library about finite sets &#X201C;à la Objective Caml&#X201D;. With Jean-Marc
Notin, he extended the library on lists. Pierre Letouzey's
contribution on rational numbers has been integrated and extended..</P><P>Pierre Corbineau extended his tactic for solving first-order
statements. He wrote a reflection-based intuitionistic tautology
solver.</P><P>Pierre Courtieu, Julien Forest and Yves Bertot added extra support to
reason on the inductive structure of recursively defined functions.</P><P>Jean-Marc Notin significantly contributed to the general maintenance
of the system. He also took care of <FONT COLOR=purple>coqdoc</FONT>.</P><P>Pierre Castéran contributed to the documentation of (co-)inductive
types and suggested improvements to the libraries.</P><P>Pierre Corbineau implemented a declarative mathematical proof
language, usable in combination with the tactic-based style of proof.</P><P>Finally, many users suggested improvements of the system through the
Coq-Club mailing list and bug-tracker systems, especially user groups
from INRIA Rocquencourt, Radbout University, University of
Pennsylvania and Yale University.</P><DIV CLASS="flushright">
Palaiseau, July 2006<BR>
Hugo Herbelin
</DIV><HR>
<A HREF="Reference-Manual001.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual003.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
