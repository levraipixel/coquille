<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<LINK rel="stylesheet" type="text/css" href="Reference-Manual.css">
<TITLE>Tactics

</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual009.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual011.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc182">Chapter 8</A>  Tactics
<A NAME="@default438"></A>
<A NAME="Tactics"></A></H1><P>A deduction rule is a link between some (unique) formula, that we call
the <EM>conclusion</EM> and (several) formulas that we call the <EM>premises</EM>. Indeed, a deduction rule can be read in two ways. The first
one has the shape: <I>&#X201C;if I know this and this then I can deduce
this&#X201D;</I>. For instance, if I have a proof of <I>A</I> and a proof of <I>B</I>
then I have a proof of <I>A</I> &#X2227; <I>B</I>. This is forward reasoning from
premises to conclusion. The other way says: <I>&#X201C;to prove this I
have to prove this and this&#X201D;</I>. For instance, to prove <I>A</I> &#X2227; <I>B</I>, I
have to prove <I>A</I> and I have to prove <I>B</I>. This is backward reasoning
which proceeds from conclusion to premises. We say that the conclusion
is <EM>the goal</EM><A NAME="@default439"></A> to prove and premises are <EM>the
subgoals</EM><A NAME="@default440"></A>. The tactics implement <EM>backward
reasoning</EM>. When applied to a goal, a tactic replaces this goal with
the subgoals it generates. We say that a tactic reduces a goal to its
subgoal(s).</P><P>Each (sub)goal is denoted with a number. The current goal is numbered
1. By default, a tactic is applied to the current goal, but one can
address a particular goal in the list by writing <I><FONT COLOR=maroon>n:</FONT></I><FONT COLOR=maroon><I>tactic</I></FONT> which
means <I>&#X201C;apply tactic </I><I><FONT COLOR=maroon>tactic</FONT></I><I> to goal number </I><I><FONT COLOR=maroon>n</FONT></I><I>&#X201D;</I>.
We can show the list of subgoals by typing <TT>Show</TT> (see
Section <A HREF="Reference-Manual009.html#Show">7.3.1</A>). </P><P>Since not every rule applies to a given statement, every tactic cannot be
used to reduce any goal. In other words, before applying a tactic to a
given goal, the system checks that some <EM>preconditions</EM> are
satisfied. If it is not the case, the tactic raises an error message.</P><P>Tactics are build from atomic tactics and tactic expressions (which
extends the folklore notion of tactical) to combine those atomic
tactics. This chapter is devoted to atomic tactics. The tactic
language will be described in chapter <A HREF="Reference-Manual011.html#TacticLanguage">9</A>.</P><P>There are, at least, three levels of atomic tactics. The simplest one
implements basic rules of the logical framework. The second level is
the one of <EM>derived rules</EM> which are built by combination of other
tactics. The third one implements heuristics or decision procedures to
build a complete proof of a goal.</P><H2 CLASS="section"><A NAME="toc47"></A><A NAME="htoc183">8.1</A>  Invocation of tactics
<A NAME="tactic-syntax"></A>
<A NAME="@default441"></A></H2><P>A tactic is applied as an ordinary command. If the tactic does not
address the first subgoal, the command may be preceded by the wished
subgoal number as shown below:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>tactic_invocation</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>num</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>tactic</FONT></I> <TT>.</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>tactic</FONT></I> <TT>.</TT></TD></TR>
</TABLE><H2 CLASS="section"><A NAME="toc48"></A><A NAME="htoc184">8.2</A>  Explicit proof as a term</H2><H3 CLASS="subsection"><A NAME="htoc185">8.2.1</A>  <TT>exact </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default442"></A><A NAME="@tactic3"></A><TT>
</TT><A NAME="exact"></A></H3><P>This tactic applies to any goal. It gives directly the exact proof
term of the goal. Let <TT>T</TT> be our goal, let <TT>p</TT> be a term of type
<TT>U</TT> then <TT>exact p</TT> succeeds iff <TT>T</TT> and <TT>U</TT> are
convertible (see Section <A HREF="Reference-Manual006.html#conv-rules">4.3</A>).</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an exact proof</TT><A NAME="@error51"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>eexact </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default443"></A><A NAME="@tactic4"></A> <P>This tactic behaves like <TT>exact</TT> but is able to handle terms with meta-variables. </P></LI></OL><H3 CLASS="subsection"><A NAME="htoc186">8.2.2</A>  <TT>refine </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default444"></A><A NAME="@tactic5"></A><TT>
</TT><A NAME="refine"></A><TT>
</TT><A NAME="@default445"></A></H3><P>This tactic allows to give an exact proof but still with some
holes. The holes are noted &#X201C;<TT>_</TT>&#X201D;.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>invalid argument</TT><A NAME="@error52"></A>: 
the tactic <TT>refine</TT> doesn't know what to do
with the term you gave.
</LI><LI CLASS="li-enumerate"><TT>Refine passed ill-formed term</TT>: the term you gave is not
a valid proof (not easy to debug in general).
This message may also occur in higher-level tactics, which call 
<TT>refine</TT> internally.
</LI><LI CLASS="li-enumerate"><TT>Cannot infer a term for this placeholder</TT><A NAME="@error53"></A>
there is a hole in the term you gave
which type cannot be inferred. Put a cast around it.
</LI></OL><P>An example of use is given in section <A HREF="Reference-Manual012.html#refine-example">10.1</A>.</P><H2 CLASS="section"><A NAME="toc49"></A><A NAME="htoc187">8.3</A>  Basics
<A NAME="@default446"></A></H2><P>Tactics presented in this section implement the basic typing rules of
<SPAN STYLE="font-variant:small-caps">Cic</SPAN> given in Chapter <A HREF="Reference-Manual006.html#Cic">4</A>.</P><H3 CLASS="subsection"><A NAME="htoc188">8.3.1</A>  <TT>assumption</TT>
<A NAME="@default447"></A><A NAME="@tactic6"></A></H3><P>This tactic applies to any goal. It implements the
&#X201C;Var&#X201D;<A NAME="@default448"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A>. It looks in the local context for an
hypothesis which type is equal to the goal. If it is the case, the
subgoal is proved. Otherwise, it fails.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such assumption</TT><A NAME="@error54"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<A NAME="@default449"></A><A NAME="@tactic7"></A>
<TT>eassumption</TT><P>This tactic behaves like <TT>assumption</TT> but is able to handle
goals with meta-variables.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc189">8.3.2</A>  <TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default450"></A><A NAME="@tactic8"></A><TT>
</TT><A NAME="clear"></A></H3><P>This tactic erases the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I> in the local context
of the current goal. Then <I><FONT COLOR=maroon>ident</FONT></I> is no more displayed and no more
usable in the proof development.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT><P>This is equivalent to <TT>clear </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>. </TT><TT>&#X2026;</TT><TT> clear
</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT></P></LI><LI CLASS="li-enumerate"><TT>clearbody </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT><A NAME="@default451"></A><A NAME="@tactic9"></A><P>This tactic expects <I><FONT COLOR=maroon>ident</FONT></I> to be a local definition then clears
its body. Otherwise said, this tactic turns a definition into an
assumption.</P></LI><LI CLASS="li-enumerate"><TT>clear - </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>.</TT> <P>This tactic clears all hypotheses except the ones depending in <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>ident</FONT></I><TT> not found</TT><A NAME="@error55"></A>
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is used in the conclusion</TT><A NAME="@error56"></A> 
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is used in the hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><A NAME="@error57"></A> 
</LI></OL><H3 CLASS="subsection"><A NAME="htoc190">8.3.3</A>  <TT>move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default452"></A><A NAME="@tactic10"></A></H3><P>This moves the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> in the local context
after the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB>.</P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> comes before <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the order of dependences,
then all hypotheses between <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> which
(possibly indirectly) depend on <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> are moved also.</P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> comes after <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the order of dependences,
then all hypotheses between <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> which 
(possibly indirectly) occur in <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> are moved also.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> not found</TT><A NAME="@error58"></A></LI><LI CLASS="li-enumerate"><TT>Cannot move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>:
it occurs in </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><A NAME="@error59"></A></LI><LI CLASS="li-enumerate"><TT>Cannot move </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>:
it depends on </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><A NAME="@error60"></A></LI></OL><H3 CLASS="subsection"><A NAME="htoc191">8.3.4</A>  <TT>rename </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> into </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default453"></A><A NAME="@tactic11"></A></H3><P>This renames hypothesis <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> into <I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> in the current
context<SUP><A NAME="text14" HREF="#note14">1</A></SUP></P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT> not found</TT><A NAME="@error61"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT> is already used</TT><A NAME="@error62"></A></LI></OL><H3 CLASS="subsection"><A NAME="htoc192">8.3.5</A>  <TT>intro
</TT><A NAME="@default454"></A><A NAME="@tactic12"></A><TT>
</TT><A NAME="intro"></A></H3><P>This tactic applies to a goal which is either a product or starts with
a let binder. If the goal is a product, the tactic implements the
&#X201C;Lam&#X201D;<A NAME="@default455"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A><SUP><A NAME="text15" HREF="#note15">2</A></SUP>. If the
goal starts with a let binder then the tactic implements a mix of the
&#X201C;Let&#X201D;<A NAME="@default456"></A> and &#X201C;Conv&#X201D;<A NAME="@default457"></A>.</P><P>If the current goal is a dependent product <TT>forall </TT><TT><I>x</I></TT><TT>:</TT><TT><I>T</I></TT><TT>, </TT><TT><I>U</I></TT> (resp <TT>let </TT><TT><I>x</I></TT><TT>:=</TT><TT><I>t</I></TT><TT> in </TT><TT><I>U</I></TT>) then <TT>intro</TT> puts <TT><I>x</I></TT><TT>:</TT><TT><I>T</I></TT> (resp <TT><I>x</I></TT><TT>:=</TT><TT><I>t</I></TT>)
in the local context.
The new subgoal is <I>U</I>.
</P><P>If the goal is a non dependent product <TT><I>T</I></TT><TT> -&gt; </TT><TT><I>U</I></TT>, then it puts
in the local context either <TT>H</TT><I>n</I><TT>:</TT><TT><I>T</I></TT> (if <I>T</I> is of
type <TT>Set</TT> or <TT>Prop</TT>) or <TT>X</TT><I>n</I><TT>:</TT><TT><I>T</I></TT> (if the type
of <I>T</I> is <TT>Type</TT>). The optional index <I>n</I> is such that <TT>H</TT><I>n</I> or <TT>X</TT><I>n</I> is a fresh identifier.
In both cases the new subgoal is <I>U</I>.</P><P>If the goal is neither a product nor starting with a let definition,
the tactic <TT>intro</TT> applies the tactic <TT>red</TT> until the tactic
<TT>intro</TT> can be applied or the goal is not reducible.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error63"></A>
</LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I><TT> is already used</TT><A NAME="@error64"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>intros</TT><A NAME="@default458"></A><A NAME="@tactic13"></A><P>Repeats <TT>intro</TT> until it meets the head-constant. It never reduces
head-constants and it never fails.</P></LI><LI CLASS="li-enumerate"><TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><P>Applies <TT>intro</TT> but forces <I><FONT COLOR=maroon>ident</FONT></I> to be the name of the
introduced hypothesis.</P><P><BR>
<B>Error message: </B><TT>name </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> is already used</TT><A NAME="@error65"></A></P><P><BR>
<B>Remark: </B>If a name used by <TT>intro</TT> hides the base name of a global
constant then the latter can still be referred to by a qualified name
(see <A HREF="Reference-Manual004.html#LongNames">2.6.2</A>).</P></LI><LI CLASS="li-enumerate"><TT>intros </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>Is equivalent to the composed tactic <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; &#X2026; ;
intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.</P><P>More generally, the <TT>intros</TT> tactic takes a pattern as
argument in order to introduce names for components of an inductive
definition or to clear introduced hypotheses; This is explained
in <A HREF="#intros-pattern">8.7.3</A>.</P></LI><LI CLASS="li-enumerate"><TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I> <A NAME="@default459"></A><A NAME="@tactic14"></A><P>Repeats <TT>intro</TT> until it meets a premise of the goal having form
<TT>(</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> and discharges the variable
named <I><FONT COLOR=maroon>ident</FONT></I> of the current goal.</P><P><BR>
<B>Error message: </B><TT>No such hypothesis in current goal</TT><A NAME="@error66"></A></P></LI><LI CLASS="li-enumerate"><TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> <A NAME="@default460"></A><A NAME="@tactic15"></A><P>Repeats <TT>intro</TT> until the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent product. For
instance, on the subgoal <CODE>forall x y:nat, x=y -&gt; y=x</CODE> the tactic <TT>intros until 1</TT>
is equivalent to <TT>intros x y H</TT>, as <CODE>x=y -&gt; y=x</CODE> is the
first non-dependent product. And on the subgoal <CODE>forall x y z:nat, x=y -&gt; y=x</CODE> the tactic <TT>intros until 1</TT>
is equivalent to <TT>intros x y z</TT> as the product on <TT>z</TT>
can be rewritten as a non-dependent product: <CODE>forall x y:nat, nat -&gt; x=y -&gt; y=x</CODE></P><P><BR>
<B>Error message: </B><TT>No such hypothesis in current goal</TT><A NAME="@error67"></A></P><P>Happens when <I><FONT COLOR=maroon>num</FONT></I> is 0 or is greater than the number of non-dependent
products of the goal.</P></LI><LI CLASS="li-enumerate"><TT>intro after </TT><I><FONT COLOR=maroon>ident</FONT></I> <A NAME="@default461"></A><A NAME="@tactic16"></A><P>Applies <TT>intro</TT> but puts the introduced
hypothesis after the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> in the hypotheses.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error68"></A>
</LI><LI CLASS="li-enumerate"><TT>No such hypothesis</TT><A NAME="@error69"></A> : <I><FONT COLOR=maroon>ident</FONT></I>
</LI></OL></LI><LI CLASS="li-enumerate"><TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB>
<A NAME="@default462"></A><A NAME="@tactic17"></A><P>Behaves as previously but <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> is the name of the introduced
hypothesis. It is equivalent to <TT>intro </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; move
</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> after </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No product even after head-reduction</TT><A NAME="@error70"></A>
</LI><LI CLASS="li-enumerate"><TT>No such hypothesis</TT><A NAME="@error71"></A> : <I><FONT COLOR=maroon>ident</FONT></I>
</LI></OL></LI></OL><H3 CLASS="subsection"><A NAME="htoc193">8.3.6</A>  <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default463"></A><A NAME="@tactic18"></A><TT>
</TT><A NAME="apply"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is a term
well-formed in the local context. The tactic <TT>apply</TT> tries to
match the current goal against the conclusion of the type of <I><FONT COLOR=maroon>term</FONT></I>.
If it succeeds, then the tactic returns as many subgoals as the number
of non dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>. The tactic <TT>apply</TT> relies on first-order pattern-matching with dependent
types. See <TT>pattern</TT> in section <A HREF="#pattern">8.5.7</A> to transform a
second-order pattern-matching problem into a first-order one.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Impossible to unify &#X2026; with &#X2026;</TT><A NAME="@error72"></A> <P>The <TT>apply</TT>
tactic failed to match the conclusion of <I><FONT COLOR=maroon>term</FONT></I> and the current goal.
You can help the <TT>apply</TT> tactic by transforming your
goal with the <TT>change</TT> or <TT>pattern</TT> tactics (see 
sections <A HREF="#pattern">8.5.7</A>, <A HREF="#change">8.3.11</A>).</P></LI><LI CLASS="li-enumerate"><TT>generated subgoal </TT><I><FONT COLOR=maroon>term</FONT></I><TT>'</TT><TT> has metavariables in it</TT><A NAME="@error73"></A><P>This occurs when some instantiations of premises of <I><FONT COLOR=maroon>term</FONT></I> are not
deducible from the unification. This is the case, for instance, when
you want to apply a transitivity property. In this case, you have to
use one of the variants below:</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> 
<A NAME="@default464"></A><A NAME="@tactic19"></A><P>Provides <TT>apply</TT> with explicit instantiations for all dependent
premises of the type of <I><FONT COLOR=maroon>term</FONT></I> which do not occur in the conclusion
and consequently cannot be found by unification. Notice that
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> must be given according to the order
of these dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>.</P><P><BR>
<B>Error message: </B><TT>Not the right number of missing arguments</TT><A NAME="@error74"></A></P></LI><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>) &#X2026; (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
:= </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> <P>This also provides <TT>apply</TT> with values for instantiating
premises. But variables are referred by names and non dependent
products by order (see syntax in Section <A HREF="#Binding-list">8.3.12</A>).</P></LI><LI CLASS="li-enumerate"><TT>eapply </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default465"></A><A NAME="@tactic20"></A><A NAME="eapply"></A><P>The tactic <TT>eapply</TT> behaves as <TT>apply</TT> but does not fail
when no instantiation are deducible for some variables in the
premises. Rather, it turns these variables into so-called
existential variables which are variables still to instantiate. An
existential variable is identified by a name of the form <TT>?</TT><TT><I>n</I></TT>
where <I>n</I> is a number. The instantiation is intended to be found
later in the proof.</P><P>An example of use of <TT>eapply</TT> is given in
Section <A HREF="Reference-Manual012.html#eapply-example">10.2</A>. </P></LI><LI CLASS="li-enumerate"><TT>lapply </TT><I><FONT COLOR=maroon>term</FONT></I> <A NAME="@default466"></A><A NAME="@tactic21"></A> <P>This tactic applies to any goal, say <TT>G</TT>. The argument <I><FONT COLOR=maroon>term</FONT></I>
has to be well-formed in the current context, its type being
reducible to a non-dependent product <TT>A -&gt; B</TT> with <TT>B</TT>
possibly containing products. Then it generates two subgoals <TT>B-&gt;G</TT> and <TT>A</TT>. Applying <TT>lapply H</TT> (where <TT>H</TT> has type
<TT>A-&gt;B</TT> and <TT>B</TT> does not start with a product) does the same
as giving the sequence <TT>cut B. 2:apply H.</TT> where <TT>cut</TT> is
described below.</P><P><BR>
<B>Warning: </B>When <I><FONT COLOR=maroon>term</FONT></I> contains more than one non
dependent product the tactic <TT>lapply</TT> only takes into account the
first product.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc194">8.3.7</A>  <TT>set ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT>:=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> )</TT>
<A NAME="tactic:set"></A>
<A NAME="@default467"></A><A NAME="@tactic22"></A>
<A NAME="@default468"></A><A NAME="@tactic23"></A></H3><P>This replaces <I><FONT COLOR=maroon>term</FONT></I> by <I><FONT COLOR=maroon>ident</FONT></I> in the conclusion or in the
hypotheses of the current goal and adds the new definition <I><FONT COLOR=maroon>ident</FONT></I><TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> to the local context. The default is to make this
replacement only in the conclusion.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in *</TT><BR>
 <TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in * |- *</TT><BR>
 
This behaves as above but substitutes <I><FONT COLOR=maroon>term</FONT></I>
everywhere in the goal (both in conclusion and hypotheses).</LI><LI CLASS="li-enumerate"><TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in * |-</TT><P>This behaves the same but substitutes <I><FONT COLOR=maroon>term</FONT></I> in
the hypotheses only (not in the conclusion).</P></LI><LI CLASS="li-enumerate"><TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in |- *</TT><P>This is equivalent to <TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT>, i.e. it substitutes <I><FONT COLOR=maroon>term</FONT></I> in the conclusion only.</P></LI><LI CLASS="li-enumerate"><TT>set ( </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>0</TT></SUB><TT> </TT><TT>:=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>) in</TT><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><P>This behaves the same but substitutes <I><FONT COLOR=maroon>term</FONT></I> only in
the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>.</P></LI><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB><P>This notation allows to specify which occurrences of <I><FONT COLOR=maroon>term</FONT></I> have to
be substituted in the hypothesis named <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>. The occurrences
are numbered from left to right and are meaningful on a pure
expression using no implicit argument, notation or coercion. A
negative occurrence number means an occurrence which should not be
substituted. As an exception of the left-to-right order, the
occurrences in the <TT>return</TT> subexpression of a <TT>match</TT> are
considered <EM>before</EM> the occurrences in the matched term.</P><P>For expressions using notations, or hiding implicit arguments or
coercions, it is recommended to make explicit all occurrences in 
order by using <TT>Set Printing All</TT> (see
section <A HREF="Reference-Manual004.html#SetPrintingAll">2.9</A>).</P></LI><LI CLASS="li-enumerate"><TT>set ( </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in |- * at</TT>
<I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB><P>This allows to specify which occurrences of the conclusion are concerned.</P></LI><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB>1</SUB></SUB><SUP>1</SUP>, &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>m</I></SUP> &#X2026;<I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB><I>m</I></SUB></SUB><SUP><I>m</I></SUP><P>It substitutes <I><FONT COLOR=maroon>term</FONT></I> at occurrences <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>i</I></SUP> &#X2026;
 <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB><I>i</I></SUB></SUB><SUP><I>i</I></SUP> of hypothesis <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>. Each <TT>at</TT> part is
optional.</P></LI><LI CLASS="li-enumerate"><TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>0</SUB> <TT>:=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>) in</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB>1</SUB></SUB><SUP>1</SUP>, &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>m</I></SUP> &#X2026;<I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I><SUB><I>m</I></SUB></SUB><SUP><I>m</I></SUP>
<TT>|- *</TT> <TT>at</TT> <I><FONT COLOR=maroon>num</FONT></I>'<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I>'<SUB><I>n</I></SUB><P>This is the more general form which combines all the previous
possibilities.</P></LI><LI CLASS="li-enumerate"><TT>set </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This behaves as <TT>set (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> but <I><FONT COLOR=maroon>ident</FONT></I>
is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. This variant is available for the 
forms with <TT>in</TT> too.</P></LI><LI CLASS="li-enumerate"><TT>pose ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><TT>:=</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>)</TT><P>This adds the local definition <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> to the current
context without performing any replacement in the goal or in the
hypotheses.</P></LI><LI CLASS="li-enumerate"><TT>pose </TT><I><FONT COLOR=maroon>term</FONT></I><P>This behaves as <TT>pose (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT> but
<I><FONT COLOR=maroon>ident</FONT></I> is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc195">8.3.8</A>  <TT>assert ( </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>form</FONT></I><TT> )</TT>
<A NAME="@default469"></A><A NAME="@tactic24"></A></H3><P>This tactic applies to any goal. <TT>assert (H : U)</TT> adds a new
hypothesis of name <TT>H</TT> asserting <TT>U</TT> to the current goal
and opens a new subgoal <TT>U</TT><SUP><A NAME="text16" HREF="#note16">3</A></SUP>. The subgoal <TT>U</TT> comes first
in the list of subgoals remaining to prove.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not a proposition or a type</TT><A NAME="@error75"></A><P>Arises when the argument <I><FONT COLOR=maroon>form</FONT></I> is neither of type <TT>Prop</TT>, <TT>Set</TT> nor <TT>Type</TT>.</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><P>This behaves as <TT>assert (</TT> <I><FONT COLOR=maroon>ident</FONT></I> : <I><FONT COLOR=maroon>form</FONT></I> <TT>)</TT> but
<I><FONT COLOR=maroon>ident</FONT></I> is generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P></LI><LI CLASS="li-enumerate"><TT>assert (</TT> <I><FONT COLOR=maroon>ident</FONT></I> := <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT><P>This behaves as <TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>type</FONT></I><TT>);[exact
</TT><I><FONT COLOR=maroon>term</FONT></I><TT>|idtac]</TT> where <I><FONT COLOR=maroon>type</FONT></I> is the type of <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>cut </TT><I><FONT COLOR=maroon>form</FONT></I><A NAME="@default470"></A><A NAME="@tactic25"></A> <P>This tactic applies to any goal. It implements the non dependent
case of the &#X201C;App&#X201D;<A NAME="@default471"></A> rule given in
Section <A HREF="Reference-Manual006.html#Typed-terms">4.2</A>. (This is Modus Ponens inference rule.)
<TT>cut U</TT> transforms the current goal <TT>T</TT> into the two
following subgoals: <TT>U -&gt; T</TT> and <TT>U</TT>. The subgoal <TT>U
-&gt; T</TT> comes first in the list of remaining subgoal to prove.</P></LI><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><A NAME="@default472"></A><A NAME="@tactic26"></A><P>This tactic behaves like <TT>assert</TT> but tries to apply <I><FONT COLOR=maroon>tactic</FONT></I>
to any subgoals generated by <TT>assert</TT>.</P></LI><LI CLASS="li-enumerate"><TT>assert </TT><I><FONT COLOR=maroon>form</FONT></I><TT> as </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default473"></A><A NAME="@tactic27"></A><P>This tactic behaves like <TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> : </TT><I><FONT COLOR=maroon>form</FONT></I><TT>)</TT>.</P></LI><LI CLASS="li-enumerate"><TT>pose proof </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This tactic behaves like <TT>assert (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:T</TT><TT> by exact </TT><I><FONT COLOR=maroon>term</FONT></I> where
<TT>T</TT> is the type of <I><FONT COLOR=maroon>term</FONT></I>. </P></LI></OL><H3 CLASS="subsection"><A NAME="htoc196">8.3.9</A>  <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default474"></A><A NAME="@tactic28"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is a term
well-formed in the local context and the argument <I><FONT COLOR=maroon>ident</FONT></I> is an
hypothesis of the context. The tactic <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I>
tries to match the conclusion of the type of <I><FONT COLOR=maroon>ident</FONT></I> against a non
dependent premisses of the type of <I><FONT COLOR=maroon>term</FONT></I>, trying them from right to
left. If it succeeds, the statement of hypothesis <I><FONT COLOR=maroon>ident</FONT></I> is
replaced by the conclusion of the type of <I><FONT COLOR=maroon>ident</FONT></I>. The tactic also
returns as many subgoals as the number of other non dependent premises
in the type of <I><FONT COLOR=maroon>term</FONT></I> and of the non dependent premises of the type
of <I><FONT COLOR=maroon>ident</FONT></I>. The tactic <TT>apply</TT> relies on first-order
pattern-matching with dependent types.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Statement without assumptions</TT><A NAME="@error76"></A><P>This happens if the type of <I><FONT COLOR=maroon>term</FONT></I> has no non dependent premise.</P></LI><LI CLASS="li-enumerate"><TT>Unable to apply</TT><A NAME="@error77"></A><P>This happens if the conclusion of <I><FONT COLOR=maroon>ident</FONT></I> does not match any of the
non dependent premises of the type of <I><FONT COLOR=maroon>term</FONT></I>.
</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies each of <I><FONT COLOR=maroon>term</FONT></I> in sequence in <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> </TT><TT>,</TT><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT>,</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This does the same but uses the bindings in each <I><FONT COLOR=maroon>bindings_list</FONT></I> to 
instanciate the parameters of the corresponding type of <I><FONT COLOR=maroon>term</FONT></I>
(see syntax of bindings in Section <A HREF="#Binding-list">8.3.12</A>).</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc197">8.3.10</A>  <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default475"></A><A NAME="@tactic29"></A><TT>
</TT><A NAME="generalize"></A></H3><P>This tactic applies to any goal. It generalizes the conclusion w.r.t.
one subterm of it. For example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Show.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 </I></TT><TT><I>&lt;</I></TT><TT><I>= x + y + y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> generalize (x + y + y).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, 0 </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
</DIV><P>If the goal is <I>G</I> and <I>t</I> is a subterm of type <I>T</I> in the goal, then
<TT>generalize</TT> <I>t</I> replaces the goal by <TT>forall (x:</TT><TT><I>T</I></TT><TT>), </TT><TT><I>G</I>'</TT>
where <I>G</I>' is obtained from <I>G</I> by replacing all occurrences of <I>t</I> by
<TT>x</TT>. The name of the variable (here <TT>n</TT>) is chosen accordingly
to <I>T</I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>Is equivalent to <TT>generalize </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>; &#X2026; ; generalize
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB>. Note that the sequence of <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>'s are processed
from <I>n</I> to 1.</P></LI><LI CLASS="li-enumerate"><TT>generalize dependent </TT><I><FONT COLOR=maroon>term</FONT></I> <A NAME="@default476"></A><A NAME="@tactic30"></A><P>This generalizes <I><FONT COLOR=maroon>term</FONT></I> but also <EM>all</EM> hypotheses which depend
on <I><FONT COLOR=maroon>term</FONT></I>. It clears the generalized hypotheses.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc198">8.3.11</A>  <TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default477"></A><A NAME="@tactic31"></A><TT>
</TT><A NAME="change"></A></H3><P>This tactic applies to any goal. It implements the rule
&#X201C;Conv&#X201D;<A NAME="@default478"></A> given in section <A HREF="Reference-Manual006.html#Conv">4.3</A>. <TT>change U</TT> replaces the current goal <TT>T</TT> with <TT>U</TT> providing that
<TT>U</TT> is well-formed and that <TT>T</TT> and <TT>U</TT> are convertible.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not convertible</TT><A NAME="@error78"></A>
</LI></OL><P><A NAME="@default479"></A><A NAME="@tactic32"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> <P>This replaces the occurrences of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in the
current goal. The terms <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must be
convertible.</P></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> <P>This replaces the occurrences numbered <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB> of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in the current goal.
The terms <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must be convertible.</P><P><BR>
<B>Error message: </B><TT>Too few occurrences</TT></P></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>change </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> in
</TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies the <TT>change</TT> tactic not to the goal but to the
hypothesis <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><P><BR>
<B>See also: </B><A HREF="#Conversion-tactics">8.5</A>
</P><H3 CLASS="subsection"><A NAME="htoc199">8.3.12</A>  Bindings list
<A NAME="@default480"></A>
<A NAME="Binding-list"></A></H3><P>A bindings list is generally used after the keyword <TT>with</TT> in
tactics. The general shape of a bindings list is <TT>(</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> :=
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>) &#X2026; (</TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> where <I><FONT COLOR=maroon>ref</FONT></I> is either an
<I><FONT COLOR=maroon>ident</FONT></I> or a <I><FONT COLOR=maroon>num</FONT></I>. It is used to provide a tactic with a list of
values (<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB>) that have to be substituted
respectively to <I><FONT COLOR=maroon>ref</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ref</FONT></I><SUB><I>n</I></SUB>. For all <I>i</I> &#X2208; [1&#X2026; 
<I>n</I>], if <I><FONT COLOR=maroon>ref</FONT></I><SUB><I>i</I></SUB> is <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> then it references the dependent
product <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>i</I></TT></SUB><TT>:T</TT> (for some type <TT>T</TT>); if <I><FONT COLOR=maroon>ref</FONT></I><SUB><I>i</I></SUB> is
<I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB> then it references the <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB>-th non dependent premise.</P><P>A bindings list can also be a simple list of terms <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>. In that case the references to which
these terms correspond are determined by the tactic. In case of <TT>elim</TT> (see section <A HREF="#elim">5</A>) the terms should correspond to
all the dependent products in the type of <I><FONT COLOR=maroon>term</FONT></I> while in the case of
<TT>apply</TT> only the dependent products which are not bound in
the conclusion of the type are given.</P><H3 CLASS="subsection"><A NAME="htoc200">8.3.13</A>  <TT>evar (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>:</TT><I><FONT COLOR=maroon>term</FONT></I><TT>)
</TT><A NAME="@default481"></A><A NAME="@tactic33"></A><TT>
</TT><A NAME="evar"></A></H3><P>The <TT>evar</TT> tactic creates a new local definition named <I><FONT COLOR=maroon>ident</FONT></I> with
type <I><FONT COLOR=maroon>term</FONT></I> in the context. The body of this binding is a fresh
existential variable.</P><H3 CLASS="subsection"><A NAME="htoc201">8.3.14</A>  <TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:= </TT><I><FONT COLOR=maroon>term</FONT></I><TT>)
</TT><A NAME="@default482"></A><A NAME="@tactic34"></A><TT>
</TT><A NAME="instantiate"></A></H3><P>The <TT>instantiate</TT> tactic allows to solve an existential variable
with the term <I><FONT COLOR=maroon>term</FONT></I>. The <I><FONT COLOR=maroon>num</FONT></I>  argument is the position of the
existential variable from right to left in the conclusion. This cannot be
the number of the existential variable since this number is different
in every session.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-enumerate"><TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in (Value of </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT></LI><LI CLASS="li-enumerate"><TT>instantiate (</TT><I><FONT COLOR=maroon>num</FONT></I><TT>:=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>) in (Type of </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>)</TT><P>These allow to refer respectively to existential variables occurring in 
a hypothesis or in the body or the type of a local definition. </P></LI></OL><H2 CLASS="section"><A NAME="toc50"></A><A NAME="htoc202">8.4</A>  Negation and contradiction</H2><H3 CLASS="subsection"><A NAME="htoc203">8.4.1</A>  <TT>absurd </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default483"></A><A NAME="@tactic35"></A><TT>
</TT><A NAME="absurd"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> is any
proposition <TT>P</TT> of type <TT>Prop</TT>. This tactic applies <TT>False</TT> elimination, that is it deduces the current goal from <TT>False</TT>, and generates as subgoals <TT>&#X223C;</TT><TT>P</TT> and <TT>P</TT>. It is
very useful in proofs by cases, where some cases are impossible. In
most cases, <TT>P</TT> or &#X223C;<TT>P</TT> is one of the hypotheses of
the local context.</P><H3 CLASS="subsection"><A NAME="htoc204">8.4.2</A>  <TT>contradiction
</TT><A NAME="contradiction"></A><TT>
</TT><A NAME="@default484"></A><A NAME="@tactic36"></A></H3><P>This tactic applies to any goal. The <TT>contradiction</TT> tactic
attempts to find in the current context (after all <TT>intros</TT>) one
which is equivalent to <TT>False</TT>. It permits to prune irrelevant
cases. This tactic is a macro for the tactics sequence <TT>intros;
elimtype False; assumption</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such assumption</TT><A NAME="@error79"></A>
</LI></OL><H2 CLASS="section"><A NAME="toc51"></A><A NAME="htoc205">8.5</A>  Conversion tactics
<A NAME="@default485"></A>
<A NAME="Conversion-tactics"></A></H2><P>This set of tactics implements different specialized usages of the
tactic <TT>change</TT>.</P><P>All conversion tactics (including <TT>change</TT>) can be
parameterized by the parts of the goal where the conversion can
occur. The specification of such parts are called <EM>clauses</EM>. It
can be either the conclusion, or an hypothesis. In the case of a
defined hypothesis it is possible to specify if the conversion should
occur on the type part, the body part or both (default).</P><P><A NAME="@default486"></A> Clauses are written after a conversion tactic (tactics
<TT>set</TT> <A HREF="#tactic:set">8.3.7</A>, <TT>rewrite</TT> <A HREF="#rewrite">8.8.1</A>,
<TT>replace</TT> <A HREF="#tactic:replace">8.8.3</A> and
<TT>autorewrite</TT> <A HREF="#tactic:autorewrite">8.12.12</A> also use clauses) and
are introduced by the keyword <TT>in</TT>. If no clause is provided,
the default is to perform the conversion only in the conclusion.</P><P>The syntax and description of the various clauses follows:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B><TT>in H</TT></B><SUB><B><TT>1</TT></B></SUB><B><TT> </TT></B><B><TT>&#X2026;</TT></B><B><TT> H</TT></B><SUB><B><TT><I>n</I></TT></B></SUB><B><TT> |- </TT></B></DT><DD CLASS="dd-description"> only in hypotheses <I>H</I><SUB>1</SUB>
&#X2026; <I>H</I><SUB><I>n</I></SUB>
</DD><DT CLASS="dt-description"><B><TT>in H</TT></B><SUB><B><TT>1</TT></B></SUB><B><TT> </TT></B><B><TT>&#X2026;</TT></B><B><TT> H</TT></B><SUB><B><TT><I>n</I></TT></B></SUB><B><TT> |- *</TT></B></DT><DD CLASS="dd-description"> in hypotheses <I>H</I><SUB>1</SUB> &#X2026;
<I>H</I><SUB><I>n</I></SUB> and in the conclusion
</DD><DT CLASS="dt-description"><B><TT>in * |-</TT></B></DT><DD CLASS="dd-description"> in every hypothesis
</DD><DT CLASS="dt-description"><B><TT>in *</TT></B></DT><DD CLASS="dd-description"> (equivalent to <TT>in * |- *</TT>) everywhere
</DD><DT CLASS="dt-description"><B><TT>in (type of H</TT></B><SUB><B><TT>1</TT></B></SUB><B><TT>) (value of H</TT></B><SUB><B><TT>2</TT></B></SUB><B><TT>) </TT></B><B><TT>&#X2026;</TT></B><B><TT> |-</TT></B></DT><DD CLASS="dd-description"> in
type part of <I>H</I><SUB>1</SUB>, in the value part of <I>H</I><SUB>2</SUB>, etc. 
</DD></DL><P>For backward compatibility, the notation <TT>in</TT> <I>H</I><SUB>1</SUB>&#X2026; <I>H</I><SUB><I>n</I></SUB>
performs the conversion in hypotheses <I>H</I><SUB>1</SUB>&#X2026; <I>H</I><SUB><I>n</I></SUB>.</P><H3 CLASS="subsection"><A NAME="htoc206">8.5.1</A>  <TT>cbv </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT><I>n</I></TT></SUB>, <TT>lazy </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT>1</TT></SUB><TT>
&#X2026; </TT><I><FONT COLOR=maroon>flag</FONT></I><SUB><TT><I>n</I></TT></SUB> and <TT>compute</TT>
<A NAME="@default487"></A><A NAME="@tactic37"></A>
<A NAME="@default488"></A><A NAME="@tactic38"></A>
<A NAME="@default489"></A><A NAME="@tactic39"></A>
<A NAME="@default490"></A><A NAME="@tactic40"></A></H3><P>
<A NAME="vmcompute"></A></P><P>These parameterized reduction tactics apply to any goal and perform
the normalization of the goal according to the specified flags. Since
the reduction considered in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> include &#X3B2; (reduction of
functional application), &#X3B4; (unfolding of transparent constants,
see <A HREF="Reference-Manual008.html#Transparent">6.2.5</A>), &#X3B9; (reduction of <TT>Cases</TT>, <TT>Fix</TT>
and <TT>CoFix</TT> expressions) and &#X3B6; (removal of local
definitions), every flag is one of <TT>beta</TT>, <TT>delta</TT>, <TT>iota</TT>, <TT>zeta</TT>, <TT>[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT> and <TT>-[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT>. The last two flags give the list
of constants to unfold, or the list of constants not to unfold. These
two flags can occur only after the <TT>delta</TT> flag. 
If alone (i.e. not
followed by <TT>[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT> or <TT>-[</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>k</I></TT></SUB><TT>]</TT>), the <TT>delta</TT> flag means that all constants must be unfolded.
However, the <TT>delta</TT> flag does not apply to variables bound by a
let-in construction whose unfolding is controlled by the <TT>zeta</TT> flag only.</P><P>The goal may be normalized with two strategies: <EM>lazy</EM> (<TT>lazy</TT>
tactic), or <EM>call-by-value</EM> (<TT>cbv</TT> tactic). The lazy strategy
is a call-by-need strategy, with sharing of reductions: the arguments of a
function call are partially evaluated only when necessary, but if an
argument is used several times, it is computed only once. This
reduction is efficient for reducing expressions with dead code. For
instance, the proofs of a proposition &#X2203;<SUB><I>T</I></SUB>  <I>x</I>. <I>P</I>(<I>x</I>) reduce to a
pair of a witness <I>t</I>, and a proof that <I>t</I> verifies the predicate
<I>P</I>. Most of the time, <I>t</I> may be computed without computing the proof
of <I>P</I>(<I>t</I>), thanks to the lazy strategy.</P><P>The call-by-value strategy is the one used in ML languages: the
arguments of a function call are evaluated first, using a weak
reduction (no reduction under the &#X3BB;-abstractions). Despite the
lazy strategy always performs fewer reductions than the call-by-value
strategy, the latter should be preferred for evaluating purely
computational expressions (i.e. with few dead code).</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>compute</TT> <A NAME="@default491"></A><A NAME="@tactic41"></A> <P>This tactic is an alias for <TT>cbv beta delta iota zeta</TT>.</P></LI><LI CLASS="li-enumerate"><TT>vm_compute</TT> <A NAME="@default492"></A><A NAME="@tactic42"></A><P>This tactic evaluates the goal using the optimized call-by-value
evaluation bytecode-based virtual machine. This algorithm is
dramatically more efficient than the algorithm used for the <TT>cbv</TT> tactic, but it cannot be fine-tuned. It is specially
interesting for full evaluation of algebraic objects. This includes
the case of reflexion-based tactics.</P></LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Delta must be specified before</TT><A NAME="@error80"></A><P>A list of constants appeared before the <TT>delta</TT> flag.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc207">8.5.2</A>  <TT>red</TT>
<A NAME="@default493"></A><A NAME="@tactic43"></A></H3><P>This tactic applies to a goal which has the form <TT>forall (x:T1)&#X2026;(xk:Tk), c t1 &#X2026; tn</TT> where <TT>c</TT> is a constant. If
<TT>c</TT> is transparent then it replaces <TT>c</TT> with its definition
(say <TT>t</TT>) and then reduces <TT>(t t1 &#X2026; tn)</TT> according to
&#X3B2;&#X3B9;&#X3B6;-reduction rules.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not reducible</TT><A NAME="@error81"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc208">8.5.3</A>  <TT>hnf</TT>
<A NAME="@default494"></A><A NAME="@tactic44"></A></H3><P>This tactic applies to any goal. It replaces the current goal with its
head normal form according to the &#X3B2;&#X3B4;&#X3B9;&#X3B6;-reduction rules.
<TT>hnf</TT> does not produce a real head normal form but either a
product or an applicative term in head normal form or a variable.</P><P><BR>
<B>Example: </B>The term <CODE>forall n:nat, (plus (S n) (S n))</CODE> is not reduced by <TT>hnf</TT>.</P><P><BR>
<B>Remark: </B>The &#X3B4; rule only applies to transparent constants
(see section <A HREF="Reference-Manual008.html#Opaque">6.2.4</A> on transparency and opacity).</P><H3 CLASS="subsection"><A NAME="htoc209">8.5.4</A>  <TT>simpl
</TT><A NAME="@default495"></A><A NAME="@tactic45"></A></H3><P>This tactic applies to any goal. The tactic <TT>simpl</TT> first applies
&#X3B2;&#X3B9;-reduction rule. Then it expands transparent constants
and tries to reduce <TT>T'</TT> according, once more, to &#X3B2;&#X3B9;
rules. But when the &#X3B9; rule is not applicable then possible
&#X3B4;-reductions are not applied. For instance trying to use <TT>simpl</TT> on <TT>(plus n O)=n</TT> does change nothing.</P><P><A NAME="@default496"></A><A NAME="@tactic46"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>simpl </TT><I><FONT COLOR=maroon>term</FONT></I><P>This applies <TT>simpl</TT> only to the occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the
current goal.</P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><P>This applies <TT>simpl</TT> only to the <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB>
occurrences of <I><FONT COLOR=maroon>term</FONT></I> in the current goal.</P><P><BR>
<B>Error message: </B><TT>Too few occurrences</TT></P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This applies <TT>simpl</TT> only to the applicative subterms whose head
occurrence is <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>simpl </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><P>This applies <TT>simpl</TT> only to the <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB>
applicative subterms whose head occurrence is <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc210">8.5.5</A>  <TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@default497"></A><A NAME="@tactic47"></A><TT>
</TT><A NAME="unfold"></A></H3><P>This tactic applies to any goal. The argument <I><FONT COLOR=maroon>qualid</FONT></I> must denote a
defined transparent constant or local definition (see Sections <A HREF="Reference-Manual003.html#Simpl-definitions">1.3.2</A> and <A HREF="Reference-Manual008.html#Transparent">6.2.5</A>). The tactic <TT>unfold</TT> applies the &#X3B4; rule to each occurrence of the constant
to which <I><FONT COLOR=maroon>qualid</FONT></I> refers in the current goal and then replaces it
with its &#X3B2;&#X3B9;-normal form.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>qualid</FONT></I> <TT>does not denote an evaluable constant</TT><A NAME="@error82"></A></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default498"></A><A NAME="@tactic48"></A><P>Replaces <EM>simultaneously</EM> <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>n</I></SUB>
with their definitions and replaces the current goal with its
&#X3B2;&#X3B9; normal form.</P></LI><LI CLASS="li-enumerate"><TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT>1</TT></SUP><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>i</I></TT></SUB><SUP><TT>1</TT></SUP><TT>,
&#X2026;, </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT><I>n</I></TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>j</I></TT></SUB><SUP><TT><I>n</I></TT></SUP><P>The lists <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB><SUP>1</SUP> and <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>n</I></SUP>, &#X2026;,
<I><FONT COLOR=maroon>num</FONT></I><SUB><I>j</I></SUB><SUP><I>n</I></SUP> specify the occurrences of <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB>, &#X2026;,
<I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>n</I></SUB> to be unfolded. Occurrences are located from left to
right.</P><P><BR>
<B>Error message: </B><TT>bad occurrence number of </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>i</I></TT></SUB></P><P><BR>
<B>Error message: </B><I><FONT COLOR=maroon>qualid</FONT></I><SUB><I>i</I></SUB> <TT>does not occur</TT></P></LI></OL><H3 CLASS="subsection"><A NAME="htoc211">8.5.6</A>  <TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><A NAME="@default499"></A><A NAME="@tactic49"></A></H3><P>This tactic applies to any goal. The term <I><FONT COLOR=maroon>term</FONT></I> is reduced using the <TT>red</TT>
tactic. Every occurrence of the resulting term in the goal is then
substituted for <I><FONT COLOR=maroon>term</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> <P>Equivalent to <TT>fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>;</TT>&#X2026;<TT>; fold</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB>.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc212">8.5.7</A>  <TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I>
<A NAME="@default500"></A><A NAME="@tactic50"></A>
<A NAME="pattern"></A></H3><P>This command applies to any goal. The argument <I><FONT COLOR=maroon>term</FONT></I> must be a free
subterm of the current goal. The command <TT>pattern</TT> performs
&#X3B2;-expansion (the inverse of &#X3B2;-reduction) of the current goal
(say <TT>T</TT>) by
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
replacing all occurrences of <I><FONT COLOR=maroon>term</FONT></I> in <TT>T</TT> with a fresh variable
</LI><LI CLASS="li-enumerate">abstracting this variable
</LI><LI CLASS="li-enumerate">applying the abstracted goal to <I><FONT COLOR=maroon>term</FONT></I>
</LI></OL><P>For instance, if the current goal <I>T</I> is expressible has &#X3C6;(<I>t</I>)
where the notation captures all the instances of <I>t</I> in &#X3C6;(<I>t</I>),
then <TT>pattern </TT><TT><I>t</I></TT> transforms it into <TT>(fun x:</TT><TT><I>A</I></TT><TT> =&gt; </TT><TT>&#X3C6;(</TT><TT>x</TT><TT>)</TT><TT>) </TT><TT><I>t</I></TT>. This command can be used, for instance, when the tactic
<TT>apply</TT> fails on matching.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Only the occurrences <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>num</FONT></I><SUB><I>n</I></SUB> of <I><FONT COLOR=maroon>term</FONT></I> will be
considered for &#X3B2;-expansion. Occurrences are located from left
to right.</P></LI><LI CLASS="li-enumerate"><TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Starting from a goal &#X3C6;(<I>t</I><SUB>1</SUB> &#X2026; <I>t</I><SUB><I>m</I></SUB>), the tactic
<TT>pattern </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT>, &#X2026;, </TT><TT><I>t</I></TT><SUB><TT><I>m</I></TT></SUB> generates the equivalent goal <TT>(fun (x</TT><SUB><TT>1</TT></SUB><TT>:</TT><TT><I>A</I></TT><SUB><TT>1</TT></SUB><TT>) &#X2026; (x</TT><SUB><TT><I>m</I></TT></SUB><TT>:</TT><TT><I>A</I></TT><SUB><TT><I>m</I></TT></SUB><TT>) =&gt; </TT><TT>&#X3C6;(</TT><TT>x</TT><SUB><TT>1</TT></SUB><TT>&#X2026;
 x</TT><SUB><TT><I>m</I></TT></SUB><TT>)</TT><TT>) </TT><TT><I>t</I></TT><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><TT><I>t</I></TT><SUB><TT><I>m</I></TT></SUB>.<BR>
If <I>t</I><SUB><I>i</I></SUB> occurs in one of the
generated types <I>A</I><SUB><I>j</I></SUB> these occurrences will also be considered and
possibly abstracted.</P></LI><LI CLASS="li-enumerate"><TT>pattern </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT>1</TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT><SUB><TT>1</TT></SUB></SUB><SUP><TT>1</TT></SUP><TT>, &#X2026;,
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> at </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><SUP><TT><I>m</I></TT></SUP><TT> &#X2026; </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT><I>n</I></TT><SUB><TT><I>m</I></TT></SUB></SUB><SUP><TT><I>m</I></TT></SUP><P>This behaves as above but processing only the occurrences <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP>1</SUP>,
&#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>i</I></SUB><SUP>1</SUP> of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>m</I></SUP>, &#X2026;, <I><FONT COLOR=maroon>num</FONT></I><SUB><I>j</I></SUB><SUP><I>m</I></SUP>
of <I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB> starting from <I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc213">8.5.8</A>  Conversion tactics applied to hypotheses</H3><P><I><FONT COLOR=maroon>conv_tactic</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> </P><P>Applies the conversion tactic <I><FONT COLOR=maroon>conv_tactic</FONT></I> to the
hypotheses <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>. The tactic <I><FONT COLOR=maroon>conv_tactic</FONT></I> is
any of the conversion tactics listed in this section. </P><P>If <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> is a local definition, then <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> can be replaced
by (Type of <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>) to address not the body but the type of the
local definition. Example: <TT>unfold not in (Type of H1) (Type of H3).</TT></P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>No such hypothesis</TT><A NAME="@error83"></A> : <I><FONT COLOR=maroon>ident</FONT></I>.
</LI></OL><H2 CLASS="section"><A NAME="toc52"></A><A NAME="htoc214">8.6</A>  Introductions</H2><P>Introduction tactics address goals which are inductive constants.
They are used when one guesses that the goal can be obtained with one
of its constructors' type.</P><H3 CLASS="subsection"><A NAME="htoc215">8.6.1</A>  <TT>constructor </TT><I><FONT COLOR=maroon>num</FONT></I><A NAME="constructor"></A><TT>
</TT><A NAME="@default501"></A><A NAME="@tactic51"></A></H3><P>This tactic applies to a goal such that the head of its conclusion is
an inductive constant (say <TT>I</TT>). The argument <I><FONT COLOR=maroon>num</FONT></I> must be less
or equal to the numbers of constructor(s) of <TT>I</TT>. Let <TT>ci</TT> be
the <TT>i</TT>-th constructor of <TT>I</TT>, then <TT>constructor i</TT> is
equivalent to <TT>intros; apply ci</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an inductive product</TT><A NAME="@error84"></A>
</LI><LI CLASS="li-enumerate"><TT>Not enough constructors</TT><A NAME="@error85"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>constructor</TT> <P>This tries <TT>constructor 1</TT> then <TT>constructor 2</TT>,
&#X2026; , then <TT>constructor</TT> <I>n</I> where <I>n</I> if
the number of constructors of the head of the goal.</P></LI><LI CLASS="li-enumerate"><TT>constructor </TT><I><FONT COLOR=maroon>num</FONT></I><TT> with</TT> <I><FONT COLOR=maroon>bindings_list</FONT></I>
<A NAME="@default502"></A><A NAME="@tactic52"></A><P>Let <TT>ci</TT> be the <TT>i</TT>-th constructor of <TT>I</TT>, then <TT>constructor i with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I> is equivalent to <TT>intros;
apply ci with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P><P><BR>
<B>Warning: </B>the terms in the <I><FONT COLOR=maroon>bindings_list</FONT></I> are checked
in the context where <TT>constructor</TT> is executed and not in the
context where <TT>apply</TT> is executed (the introductions are not
taken into account).</P></LI><LI CLASS="li-enumerate"><TT>split</TT><A NAME="@default503"></A><A NAME="@tactic53"></A><P>Applies if <TT>I</TT> has only one constructor, typically in the case
of conjunction <I>A</I>&#X2227; <I>B</I>. Then, it is equivalent to <TT>constructor 1</TT>.</P></LI><LI CLASS="li-enumerate"><TT>exists </TT><I><FONT COLOR=maroon>bindings_list</FONT></I><A NAME="@default504"></A><A NAME="@tactic54"></A> <P>Applies if <TT>I</TT> has only one constructor, for instance in the
case of existential quantification &#X2203; <I>x</I>· <I>P</I>(<I>x</I>). 
Then, it is equivalent to <TT>intros; constructor 1 with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>left</TT><A NAME="@default505"></A><A NAME="@tactic55"></A>, <TT>right</TT><A NAME="@default506"></A><A NAME="@tactic56"></A><P>Apply if <TT>I</TT> has two constructors, for instance in the case of
disjunction <I>A</I>&#X2228; <I>B</I>. Then, they are respectively equivalent to <TT>constructor 1</TT> and <TT>constructor 2</TT>.</P></LI><LI CLASS="li-enumerate"><TT>left </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>, <TT>right </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>, <TT>split
</TT><I><FONT COLOR=maroon>bindings_list</FONT></I><P>As soon as the inductive type has the right number of constructors,
these expressions are equivalent to the corresponding <TT>constructor </TT><TT><I>i</I></TT><TT> with </TT><I><FONT COLOR=maroon>bindings_list</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>econstructor</TT><P>This tactic behaves like <TT>constructor</TT> but is able to
introduce existential variables if an instanciation for a variable
cannot be found (cf <TT>eapply</TT>). The tactics <TT>eexists</TT>,
<TT>esplit</TT>, <TT>eleft</TT> and <TT>eright</TT> follows the same
behaviour.</P></LI></OL><H2 CLASS="section"><A NAME="toc53"></A><A NAME="htoc216">8.7</A>  Eliminations (Induction and Case Analysis)</H2><P>
<A NAME="Tac-induction"></A>
Elimination tactics are useful to prove statements by induction or
case analysis. Indeed, they make use of the elimination (or
induction) principles generated with inductive definitions (see
Section <A HREF="Reference-Manual006.html#Cic-inductive-definitions">4.5</A>).</P><H3 CLASS="subsection"><A NAME="htoc217">8.7.1</A>  <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default507"></A><A NAME="@tactic57"></A></H3><P>This tactic applies to any goal. The type of the argument <I><FONT COLOR=maroon>term</FONT></I> must
be an inductive constant. Then, the tactic <TT>induction</TT>
generates subgoals, one for each possible form of <I><FONT COLOR=maroon>term</FONT></I>, i.e. one
for each constructor of the inductive type.</P><P>The tactic <TT>induction</TT> automatically replaces every occurrences
of <I><FONT COLOR=maroon>term</FONT></I> in the conclusion and the hypotheses of the goal. It
automatically adds induction hypotheses (using names of the form <TT>IHn1</TT>) to the local context. If some hypothesis must not be taken
into account in the induction hypothesis, then it needs to be removed
first (you can also use the tactics <TT>elim</TT> or <TT>simple induction</TT>,
see below).</P><P>There are particular cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is an identifier <I><FONT COLOR=maroon>ident</FONT></I> denoting a quantified
variable of the conclusion of the goal, then <TT>induction </TT><I><FONT COLOR=maroon>ident</FONT></I>
behaves as <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; induction </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is a <I><FONT COLOR=maroon>num</FONT></I>, then <TT>induction </TT><I><FONT COLOR=maroon>num</FONT></I> behaves as
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by <TT>induction</TT> applied to the
last introduced hypothesis.<P><BR>
<B>Remark: </B>For simple induction on a numeral, use syntax <TT>induction
(</TT><I><FONT COLOR=maroon>num</FONT></I><TT>)</TT> (not very interesting anyway).</P></LI></UL><P><BR>
<B>Example: </B></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma induction_test : forall n:nat, n = n -</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n = n -</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : n = n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction n.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 0 = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 </I></TT><TT><I>&lt;</I></TT><TT><I>= 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> S n </I></TT><TT><I>&lt;</I></TT><TT><I>= S n</I></TT><BR>
</DIV><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Not an inductive product</TT><A NAME="@error86"></A>
</LI><LI CLASS="li-enumerate"><TT>Cannot refine to conclusions with meta-variables</TT><A NAME="@error87"></A><P>As <TT>induction</TT> uses <TT>apply</TT>, see Section <A HREF="#apply">8.3.6</A> and
the variant <TT>elim &#X2026; with &#X2026;</TT> below.
</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> but uses the names in
<I><FONT COLOR=maroon>intro_pattern</FONT></I> to names the variables introduced in the context.
The <I><FONT COLOR=maroon>intro_pattern</FONT></I> must have the form <TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT> <I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of constructors of the type of
<I><FONT COLOR=maroon>term</FONT></I>. Each variable introduced by <TT>induction</TT> in the context
of the <I>i</I><SUP><I>th</I></SUP> goal gets its name from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If there are not enough names, <TT>induction</TT>
invents names for the remaining variables to introduce. More
generally, the <I>p</I>'s can be any introduction patterns (see
Section <A HREF="#intros-pattern">8.7.3</A>). This provides a concise notation for
nested induction.</P><P><BR>
<B>Remark: </B>for an inductive type with one constructor, the pattern notation
<TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>,&#X2026;,</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> can be used instead of
<TT>[</TT> <I>p</I><SUB>1</SUB> &#X2026;<I>p</I><SUB><I>n</I></SUB> <TT>]</TT>.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>This behaves as <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I> but using the induction
scheme of name <I><FONT COLOR=maroon>qualid</FONT></I>. It does not expect that the type of
<I><FONT COLOR=maroon>term</FONT></I> is inductive.</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>where <I><FONT COLOR=maroon>qualid</FONT></I> is an induction principle with complex predicates
(like the ones generated by function induction).</P></LI><LI CLASS="li-enumerate"><TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This combines <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I>
and <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="elim"></A><P>This is a more basic induction tactic. Again, the type of the
argument <I><FONT COLOR=maroon>term</FONT></I> must be an inductive constant. Then according to
the type of the goal, the tactic <TT>elim</TT> chooses the right
destructor and applies it (as in the case of the <TT>apply</TT>
tactic). For instance, assume that our proof context contains <TT>n:nat</TT>, assume that our current goal is <TT>T</TT> of type <TT>Prop</TT>, then <TT>elim n</TT> is equivalent to <TT>apply nat_ind with
(n:=n)</TT>. The tactic <TT>elim</TT> does not affect the hypotheses of
the goal, neither introduces the induction loading into the context
of hypotheses.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I> <P>also works when the type of <I><FONT COLOR=maroon>term</FONT></I> starts with products and the
head symbol is an inductive definition. In that case the tactic
tries both to find an object in the inductive definition and to use
this inductive definition for elimination. In case of non-dependent
products in the type, subgoals are generated corresponding to the
hypotheses. In the case of dependent products, the tactic will try
to find an instance for which the elimination lemma applies.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default508"></A><A NAME="@tactic58"></A> 
 
Allows the user to give explicitly the values for dependent
premises of the elimination schema. All arguments must be given.<P><BR>
<B>Error message: </B><TT>Not the right number of dependent arguments</TT><A NAME="@error88"></A></P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>
:= </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> <P>Provides also <TT>elim</TT> with values for instantiating premises by
associating explicitly variables (or non dependent products) with
their intended instance.</P></LI><LI CLASS="li-enumerate"><TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>
<A NAME="@default509"></A><A NAME="@tactic59"></A> <P>Allows the user to give explicitly an elimination predicate
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> which is not the standard one for the underlying inductive
type of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>. Each of the <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> is either
a simple term or a term with a bindings list (see <A HREF="#Binding-list">8.3.12</A>).</P></LI><LI CLASS="li-enumerate"><TT>elimtype </TT><I><FONT COLOR=maroon>form</FONT></I><A NAME="@default510"></A><A NAME="@tactic60"></A><P>The argument <I><FONT COLOR=maroon>form</FONT></I> must be inductively defined. <TT>elimtype I</TT>
is equivalent to <TT>cut I. intro H</TT><I><FONT COLOR=maroon>n</FONT></I><TT>; elim H</TT><I><FONT COLOR=maroon>n</FONT></I><TT>;
clear H</TT><I><FONT COLOR=maroon>n</FONT></I>. Therefore the hypothesis <TT>H</TT><I><FONT COLOR=maroon>n</FONT></I> will
not appear in the context(s) of the subgoal(s). Conversely, if <TT>t</TT> is a term of (inductive) type <TT>I</TT> and which does not occur
in the goal then <TT>elim t</TT> is equivalent to <TT>elimtype I; 2:
exact t.</TT></P><P><BR>
<B>Error message: </B><TT>Impossible to unify &#X2026; with &#X2026;</TT><A NAME="@error89"></A> </P><P>Arises when <I><FONT COLOR=maroon>form</FONT></I> needs to be applied to parameters.</P></LI><LI CLASS="li-enumerate"><TT>simple induction </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default511"></A><A NAME="@tactic61"></A><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; elim </TT><I><FONT COLOR=maroon>ident</FONT></I> when <I><FONT COLOR=maroon>ident</FONT></I> is a quantified
variable of the goal.</P></LI><LI CLASS="li-enumerate"><TT>simple induction </TT><I><FONT COLOR=maroon>num</FONT></I><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>num</FONT></I><TT>; elim </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the name given by
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> to the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent premise of
the goal.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc218">8.7.2</A>  <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default512"></A><A NAME="@tactic62"></A></H3><P>The tactic <TT>destruct</TT> is used to perform case analysis without
recursion. Its behavior is similar to <TT>induction</TT> except
that no induction hypothesis is generated. It applies to any goal and
the type of <I><FONT COLOR=maroon>term</FONT></I> must be inductively defined. There are particular cases:</P><UL CLASS="itemize"><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is an identifier <I><FONT COLOR=maroon>ident</FONT></I> denoting a quantified
variable of the conclusion of the goal, then <TT>destruct </TT><I><FONT COLOR=maroon>ident</FONT></I>
behaves as <TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; destruct </TT><I><FONT COLOR=maroon>ident</FONT></I></LI><LI CLASS="li-itemize">If <I><FONT COLOR=maroon>term</FONT></I> is a <I><FONT COLOR=maroon>num</FONT></I>, then <TT>destruct </TT><I><FONT COLOR=maroon>num</FONT></I> behaves as
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> followed by <TT>destruct</TT> applied to the
last introduced hypothesis.<P><BR>
<B>Remark: </B>For destruction of a numeral, use syntax <TT>destruct
(</TT><I><FONT COLOR=maroon>num</FONT></I><TT>)</TT> (not very interesting anyway).</P></LI></UL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This behaves as <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I> but uses the names in
<I><FONT COLOR=maroon>intro_pattern</FONT></I> to names the variables introduced in the context.
The <I><FONT COLOR=maroon>intro_pattern</FONT></I> must have the form <TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT> <I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of constructors of the type of
<I><FONT COLOR=maroon>term</FONT></I>. Each variable introduced by <TT>destruct</TT> in the context
of the <I>i</I><SUP><I>th</I></SUP> goal gets its name from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If there are not enough names, <TT>destruct</TT>
invents names for the remaining variables to introduce. More
generally, the <I>p</I>'s can be any introduction patterns (see
Section <A HREF="#intros-pattern">8.7.3</A>). This provides a concise notation for
nested destruction.</P><P><BR>
<B>Remark: </B>for an inductive type with one constructor, the pattern notation
<TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>,&#X2026;,</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT> can be used instead of
<TT>[</TT> <I>p</I><SUB>1</SUB> &#X2026;<I>p</I><SUB><I>n</I></SUB> <TT>]</TT>.</P></LI><LI CLASS="li-enumerate"><TT>pose proof </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This tactic behaves like <TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>This is a synonym of <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>destruct </TT><I><FONT COLOR=maroon>term</FONT></I><TT> as </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>This is a synonym of <TT>induction </TT><I><FONT COLOR=maroon>term</FONT></I><TT> using </TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> as
</TT><I><FONT COLOR=maroon>intro_pattern</FONT></I>.</P></LI><LI CLASS="li-enumerate"><TT>case </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="case"></A><A NAME="@default513"></A><A NAME="@tactic63"></A><P>The tactic <TT>case</TT> is a more basic tactic to perform case
analysis without recursion. It behaves as <TT>elim </TT><I><FONT COLOR=maroon>term</FONT></I> but using
a case-analysis elimination principle and not a recursive one.</P></LI><LI CLASS="li-enumerate"><TT>case </TT><I><FONT COLOR=maroon>term</FONT></I><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default514"></A><A NAME="@tactic64"></A><P>Analogous to <TT>elim &#X2026; with</TT> above.</P></LI><LI CLASS="li-enumerate"><TT>simple destruct </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default515"></A><A NAME="@tactic65"></A><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; case </TT><I><FONT COLOR=maroon>ident</FONT></I> when <I><FONT COLOR=maroon>ident</FONT></I> is a quantified
variable of the goal.</P></LI><LI CLASS="li-enumerate"><TT>simple destruct </TT><I><FONT COLOR=maroon>num</FONT></I><P>This tactic behaves as <TT>intros until
</TT><I><FONT COLOR=maroon>num</FONT></I><TT>; case </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the name given by
<TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> to the <I><FONT COLOR=maroon>num</FONT></I>-th non-dependent premise of
the goal.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc219">8.7.3</A>  <TT>intros </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT> </TT><TT>&#X2026;</TT><TT> </TT><I><FONT COLOR=maroon>intro_pattern</FONT></I><TT>
</TT><A NAME="intros-pattern"></A><TT>
</TT><A NAME="@default516"></A><A NAME="@tactic66"></A></H3><P>The tactic <TT>intros</TT> applied to introduction patterns performs both
introduction of variables and case analysis in order to give names to
components of an hypothesis.</P><P>An introduction pattern is either:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the wildcard: <TT>_</TT>
</LI><LI CLASS="li-itemize">the pattern <TT>?</TT>
</LI><LI CLASS="li-itemize">a variable
</LI><LI CLASS="li-itemize">a disjunction of lists of patterns:
<TT>[</TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT>1<I>m</I></TT><SUB><TT>1</TT></SUB></SUB><TT> | </TT><TT>&#X2026;</TT><TT> | </TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT><I>nm</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT>]</TT>
</LI><LI CLASS="li-itemize">a conjunction of patterns: <TT>(</TT> <I>p</I><SUB>1</SUB> <TT>,</TT> &#X2026; <TT>,</TT> <I>p</I><SUB><I>n</I></SUB> <TT>)</TT>
</LI></UL><P>The behavior of <TT>intros</TT> is defined inductively over the
structure of the pattern given as argument:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
introduction on the wildcard do the introduction and then
immediately clear (cf <A HREF="#clear">8.3.2</A>) the corresponding hypothesis;
</LI><LI CLASS="li-itemize">introduction on <TT>?</TT> do the introduction, and let Coq
choose a fresh name for the variable;
</LI><LI CLASS="li-itemize">introduction on a variable behaves like described in <A HREF="#intro">8.3.5</A>; 
</LI><LI CLASS="li-itemize">introduction over a
list of patterns <I>p</I><SUB>1</SUB> &#X2026; <I>p</I><SUB><I>n</I></SUB> is equivalent to the sequence of
introductions over the patterns namely:
<TT>intros </TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>;&#X2026;; intros </TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB>, the goal should start with
at least <I>n</I> products;
</LI><LI CLASS="li-itemize">introduction over a
disjunction of list of patterns
<TT>[</TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT>1<I>m</I></TT><SUB><TT>1</TT></SUB></SUB><TT> | </TT><TT>&#X2026;</TT><TT> | </TT><TT><I>p</I></TT><SUB><TT>11</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT><I>nm</I></TT><SUB><TT><I>n</I></TT></SUB></SUB><TT>]</TT>. It introduces a new variable <I>X</I>, its type should be an inductive
definition with <I>n</I>
constructors, then it performs a case analysis over <I>X</I> 
(which generates <I>n</I> subgoals), it 
clears <I>X</I> and performs on each generated subgoals the corresponding
<TT>intros</TT> <I>p</I><SUB><I>i</I>1</SUB> &#X2026; <I>p</I><SUB><I>im</I><SUB><I>i</I></SUB></SUB> tactic;
</LI><LI CLASS="li-itemize">introduction over a 
conjunction of patterns (<I>p</I><SUB>1</SUB>,&#X2026;,<I>p</I><SUB><I>n</I></SUB>), it
introduces a new variable <I>X</I>, its type should be an inductive 
definition with 1
constructor with (at least) <I>n</I> arguments, then it performs a case 
analysis over <I>X</I> 
(which generates 1 subgoal with at least <I>n</I> products), it 
clears <I>X</I> and performs an introduction over the list of patterns <I>p</I><SUB>1</SUB> &#X2026; <I>p</I><SUB><I>n</I></SUB>.
</LI></UL><P><BR>
<B>Remark: </B>The pattern <TT>(</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT>, </TT><TT>&#X2026;</TT><TT>, </TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT>
is a synonym for the pattern <TT>[</TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT> </TT><TT>&#X2026;</TT><TT> </TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT>]</TT>, i.e. it
corresponds to the decomposition of an hypothesis typed by an
inductive type with a single constructor.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma intros_test : forall A B C:Prop, A </TT><TT>\</TT><TT>/ B /</TT><TT>\</TT><TT> C -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> C) -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ B /</I></TT><TT><I>\</I></TT><TT><I> C -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros A B C [a| [_ c]] f.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  a : A</I></TT><BR>
<TT><I>  f : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply (f a).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  c : C</I></TT><BR>
<TT><I>  f : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exact c.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros A B C [a| (_, c)] f.</I></TT><BR>
<TT><I> apply (f a).</I></TT><BR>
<TT><I>exact c.</I></TT><BR>
<TT><I>intros_test is defined</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc220">8.7.4</A>  <TT>double induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default517"></A><A NAME="@tactic67"></A></H3><P>This tactic applies to any goal. If the variables <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> and
<I><FONT COLOR=maroon>ident</FONT></I><SUB>2</SUB> of the goal have an inductive type, then this tactic
performs double induction on these variables. For instance, if the
current goal is <CODE>forall n m:nat, P n m</CODE> then, <TT>double induction n
m</TT> yields the four cases with their respective inductive hypotheses.
In particular the case for <CODE>(P (S n) (S m))</CODE> with the induction
hypotheses <CODE>(P (S n) m)</CODE> and <CODE>(m:nat)(P n m)</CODE> (hence
<CODE>(P n m)</CODE> and <CODE>(P n (S m))</CODE>).</P><P><BR>
<B>Remark: </B>When the induction hypothesis <CODE>(P (S n) m)</CODE> is not
needed, <TT>induction </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; destruct </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB> produces
more concise subgoals.</P><P><BR>
<B>Variant: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>double induction </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>num</FONT></I><SUB><TT>2</TT></SUB><P>This applies double induction on the <I><FONT COLOR=maroon>num</FONT></I><SUB>1</SUB><SUP><I>th</I></SUP> and <I><FONT COLOR=maroon>num</FONT></I><SUB>2</SUB><SUP><I>th</I></SUP> <I>non dependent</I> premises of the goal. More generally, any combination of an
<I><FONT COLOR=maroon>ident</FONT></I> and an <I><FONT COLOR=maroon>num</FONT></I> is valid.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc221">8.7.5</A>  <TT>decompose [ </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> ] </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="decompose"></A><TT>
</TT><A NAME="@default518"></A><A NAME="@tactic68"></A></H3><P>This tactic allows to recursively decompose a
complex proposition in order to obtain atomic ones.
Example: </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma ex1 : forall A B C:Prop, A /</TT><TT>\</TT><TT> B /</TT><TT>\</TT><TT> C </TT><TT>\</TT><TT>/ B /</TT><TT>\</TT><TT> C </TT><TT>\</TT><TT>/ C /</TT><TT>\</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C </I></TT><TT><I>\</I></TT><TT><I>/ B /</I></TT><TT><I>\</I></TT><TT><I> C </I></TT><TT><I>\</I></TT><TT><I>/ C /</I></TT><TT><I>\</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros A B C H; decompose [and or] H; assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P><TT>decompose</TT> does not work on right-hand sides of implications or products.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>decompose sum </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default519"></A><A NAME="@tactic69"></A>
This decomposes sum types (like <TT>or</TT>).
</LI><LI CLASS="li-enumerate"><TT>decompose record </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default520"></A><A NAME="@tactic70"></A>
This decomposes record types (inductive types with one constructor,
like <TT>and</TT> and <TT>exists</TT> and those defined with the
<TT>Record</TT> macro, see p. <A HREF="Reference-Manual004.html#Record">??</A>).
</LI></OL><H3 CLASS="subsection"><A NAME="htoc222">8.7.6</A>  <TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>).
</TT><A NAME="@default521"></A><A NAME="@tactic71"></A><TT>
</TT><A NAME="FunInduction"></A></H3><P>The <EM>experimental</EM> tactic <TT>functional induction</TT> performs
case analysis and induction following the definition of a function. It
makes use of a principle generated by <TT>Function</TT>
(section <A HREF="Reference-Manual004.html#Function">2.3</A>) or <TT>Functional Scheme</TT>
(section <A HREF="#FunScheme">8.15</A>).</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Functional Scheme minus_ind := Induction for minus Sort Prop.</TT><BR>
<TT><I>minus_equation is defined</I></TT><BR>
<TT><I>minus_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma le_minus : forall n m:nat, (n - m </TT><TT>&lt;</TT><TT>= n).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, n - m </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n - m </I></TT><TT><I>&lt;</I></TT><TT><I>= n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> functional induction (minus n m); simpl; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P><BR>
<B>Remark: </B><TT>(</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)</TT> must be a correct
full application of <I><FONT COLOR=maroon>qualid</FONT></I>. In particular, the rules for implicit
arguments are the same as usual. For example use <TT>@</TT><I><FONT COLOR=maroon>qualid</FONT></I> if
you want to write implicit arguments explicitly.</P><P><BR>
<B>Remark: </B>Parenthesis over <I><FONT COLOR=maroon>qualid</FONT></I>&#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>n</I></SUB> are mandatory.</P><P><BR>
<B>Remark: </B><TT>functional induction (f x1 x2 x3)</TT> is actually a wrapper
for <TT>induction x1 x2 x3 (f x1 x2 x3) using </TT><I><FONT COLOR=maroon>qualid</FONT></I> followed by
a cleaning phase, where <I><FONT COLOR=maroon>qualid</FONT></I> is the induction principle
registered for <I>f</I> (by the <TT>Function</TT> (section <A HREF="Reference-Manual004.html#Function">2.3</A>)
or <TT>Functional Scheme</TT> (section <A HREF="#FunScheme">8.15</A>) command)
corresponding to the sort of the goal. Therefore <TT>functional
induction</TT> may fail if the induction scheme (<I><FONT COLOR=maroon>qualid</FONT></I>) is
not defined. See also section <A HREF="Reference-Manual004.html#Function">2.3</A> for the function terms
accepted by <TT>Function</TT>.</P><P><BR>
<B>Remark: </B>There is a difference between obtaining an induction scheme for a
function by using <TT>Function</TT> (section <A HREF="Reference-Manual004.html#Function">2.3</A>) and by
using <TT>Functional Scheme</TT> after a normal definition using
<TT>Fixpoint</TT> or <TT>Definition</TT>. See <A HREF="Reference-Manual004.html#Function">2.3</A> for
details.</P><P><BR>
<B>See also: </B><A HREF="Reference-Manual004.html#Function">2.3</A>,<A HREF="#FunScheme">8.15</A>,<A HREF="Reference-Manual012.html#FunScheme-examples">10.4</A>,
<A HREF="#sec:functional-inversion">8.10.3</A></P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Cannot find induction information on </TT><I><FONT COLOR=maroon>qualid</FONT></I><A NAME="@error90"></A><P> </P></LI><LI CLASS="li-enumerate"><TT>Not the right number of induction arguments</TT><A NAME="@error91"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)
using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I>+1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Similar to <TT>Induction</TT> and <TT>elim</TT>
(section <A HREF="#Tac-induction">8.7</A>), allows to give explicitly the
induction principle and the values of dependent premises of the
elimination scheme, including <EM>predicates</EM> for mutual induction
when <I><FONT COLOR=maroon>qualid</FONT></I>is mutually recursive.</P></LI><LI CLASS="li-enumerate"><TT>functional induction (</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>)
using </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>m</I>+1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT>1</TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT> &#X2026;
 </TT><I><FONT COLOR=maroon>ref</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Similar to <TT>induction</TT> and <TT>elim</TT>
(section <A HREF="#Tac-induction">8.7</A>).</P></LI><LI CLASS="li-enumerate">All previous variants can be extended by the usual <TT>as
</TT><I><FONT COLOR=maroon>intro_pattern</FONT></I> construction, similarly for example to
<TT>induction</TT> and <TT>elim</TT> (section <A HREF="#Tac-induction">8.7</A>).</LI></OL><H2 CLASS="section"><A NAME="toc54"></A><A NAME="htoc223">8.8</A>  Equality</H2><P>These tactics use the equality <TT>eq:forall A:Type, A-&gt;A-&gt;Prop</TT>
defined in file <TT>Logic.v</TT> (see Section <A HREF="Reference-Manual005.html#Equality">3.1.2</A>). The
notation for <TT>eq</TT> <I>T</I> <I>t</I> <I>u</I> is simply <TT><I>t</I></TT><TT>=</TT><TT><I>u</I></TT> dropping the
implicit type of <I>t</I> and <I>u</I>.</P><H3 CLASS="subsection"><A NAME="htoc224">8.8.1</A>  <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="rewrite"></A><TT>
</TT><A NAME="@default522"></A><A NAME="@tactic72"></A></H3><P>This tactic applies to any goal. The type of <I><FONT COLOR=maroon>term</FONT></I>
must have the form</P><P><TT>(x</TT><SUB><TT>1</TT></SUB><TT>:A</TT><SUB><TT>1</TT></SUB><TT>) &#X2026; (x</TT><SUB><TT><I>n</I></TT></SUB><TT>:A</TT><SUB><TT><I>n</I></TT></SUB><TT>)</TT><TT>eq</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>. </P><P>where <TT>eq</TT> is the Leibniz equality or a registered
setoid equality.</P><P>Then <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I> replaces every occurrence of 
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> by <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> in the goal. Some of the variables x<SUB>1</SUB> are
solved by unification, and some of the types <TT>A</TT><SUB>1</SUB>, &#X2026;,
<TT>A</TT><SUB><I>n</I></SUB> become new subgoals.</P><P><BR>
<B>Remark: </B>In case the type of 
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> contains occurrences of variables bound in the
type of <I><FONT COLOR=maroon>term</FONT></I>, the tactic tries first to find a subterm of the goal
which matches this term in order to find a closed instance <I><FONT COLOR=maroon>term</FONT></I>'<SUB>1</SUB>
of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>, and then all instances of <I><FONT COLOR=maroon>term</FONT></I>'<SUB>1</SUB> will be replaced.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>The term provided does not end with an equation</TT><A NAME="@error92"></A></LI><LI CLASS="li-enumerate"><TT>Tactic generated a subgoal identical to the original goal</TT><A NAME="@error93"></A><BR>
This happens if <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> does not occur in the goal.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>rewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default523"></A><A NAME="@tactic73"></A><BR>
 Is equivalent to <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I></LI><LI CLASS="li-enumerate"><TT>rewrite &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default524"></A><A NAME="@tactic74"></A><BR>
 Uses the equality <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> from right to left</LI><LI CLASS="li-enumerate"><TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><TT><I>clause</I></TT>
<A NAME="@default525"></A><A NAME="@tactic75"></A><BR>
 Analogous to <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I> but rewriting is done following
<I>clause</I> (similarly to <A HREF="#Conversion-tactics">8.5</A>). For
instance:
<UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>rewrite H in H1</TT> will rewrites <TT>H</TT> in the hypothesis
<TT>H1</TT> instead of the current goal.
</LI><LI CLASS="li-itemize"><TT>rewrite H in H1,H2 |- *</TT> means <TT>rewrite H; rewrite H in H1;
rewrite H in H2</TT>. In particular a failure will happen if any of
these three simplier tactics fails. 
</LI><LI CLASS="li-itemize"><TT>rewrite H in * |- </TT> will do <TT>rewrite H in
H</TT><SUB><TT><I>i</I></TT></SUB> for all hypothesis <TT>H</TT><SUB><TT><I>i</I></TT></SUB><TT> &lt;&gt; H</TT>. A success will happen
as soon as at least one of these simplier tactics succeeds.
</LI><LI CLASS="li-itemize"><TT>rewrite H in *</TT> is a combination of <TT>rewrite H</TT> 
and <TT>rewrite H in * |-</TT> that succeeds if at
least one of these two tactics succeeds. 
</LI></UL></LI><LI CLASS="li-enumerate"><TT>rewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><TT><I>clause</I></TT>
<A NAME="@default526"></A><A NAME="@tactic76"></A><BR>
 Behaves as <TT>rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><TT><I>clause</I></TT>.</LI><LI CLASS="li-enumerate"><TT>rewrite &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><TT> in </TT><TT><I>clause</I></TT><BR>
 <A NAME="@default527"></A><A NAME="@tactic77"></A>
Uses the equality <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> from right to left to
rewrite in <I>clause</I> as explained above.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc225">8.8.2</A>  <TT>cutrewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="cutrewrite"></A><TT>
</TT><A NAME="@default528"></A><A NAME="@tactic78"></A></H3><P>This tactic acts like <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>
(see below).</P><H3 CLASS="subsection"><A NAME="htoc226">8.8.3</A>  <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="tactic:replace"></A><TT>
</TT><A NAME="@default529"></A><A NAME="@tactic79"></A></H3><P>This tactic applies to any goal. It replaces all free occurrences of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> in the current goal with <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> and generates the
equality <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> as a subgoal. This equality is
automatically solved if it occurs amongst the assumption, or if its
symmetric form occurs. It is equivalent to <TT>cut
</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>; [intro H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>; rewrite &lt;- H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>; clear H</TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT>| assumption || symmetry; try assumption]</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>terms do not have convertible types</TT><A NAME="@error94"></A>
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This acts
as <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> but try to solve the
generated subgoal <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB> using <I><FONT COLOR=maroon>tactic</FONT></I>.
</LI><LI CLASS="li-enumerate"><TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>' using the
first assumption which type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>'</TT> or <I><FONT COLOR=maroon>term</FONT></I><TT>'=</TT><I><FONT COLOR=maroon>term</FONT></I>
</LI><LI CLASS="li-enumerate"><TT>replace -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>' using the
first assumption which type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><TT>'</TT>
</LI><LI CLASS="li-enumerate"><TT>replace &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
Replace <I><FONT COLOR=maroon>term</FONT></I> with <I><FONT COLOR=maroon>term</FONT></I>' using the
first assumption which type has the form <I><FONT COLOR=maroon>term</FONT></I><TT>'=</TT><I><FONT COLOR=maroon>term</FONT></I>
</LI><LI CLASS="li-enumerate"><TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT><TT><I>clause</I></TT><TT> </TT><BR>
 <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT><TT><I>clause</I></TT><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
 <TT>replace </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 <TT>replace -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 <TT>replace -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><TT> </TT><TT><I>clause</I></TT><BR>
 Act as before but the replacements take place in <I>clause</I> <A HREF="#Conversion-tactics">8.5</A> an not only in the conclusion of the goal.<BR>
 The <I>clause</I> arg must not contain any <TT>type of</TT> nor <TT>value of</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc227">8.8.4</A>  <TT>reflexivity
</TT><A NAME="reflexivity"></A><TT>
</TT><A NAME="@default530"></A><A NAME="@tactic80"></A></H3><P>This tactic applies to a goal which has the form <TT>t=u</TT>. It checks
that <TT>t</TT> and <TT>u</TT> are convertible and then solves the goal.
It is equivalent to <TT>apply refl_equal</TT>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>The conclusion is not a substitutive equation</TT><A NAME="@error95"></A>
</LI><LI CLASS="li-enumerate"><TT>Impossible to unify &#X2026; with ..</TT><A NAME="@error96"></A>
</LI></OL><H3 CLASS="subsection"><A NAME="htoc228">8.8.5</A>  <TT>symmetry
</TT><A NAME="@default531"></A><A NAME="@tactic81"></A><TT>
</TT><A NAME="@default532"></A><A NAME="@tactic82"></A></H3><P>
This tactic applies to a goal which has the form <TT>t=u</TT> and changes it
into <TT>u=t</TT>.</P><P><BR>
<B>Variant: </B><TT>symmetry in </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
If the statement of the hypothesis <I><FONT COLOR=maroon>ident</FONT></I> has the form <TT>t=u</TT>,
the tactic changes it to <TT>u=t</TT>.</P><H3 CLASS="subsection"><A NAME="htoc229">8.8.6</A>  <TT>transitivity </TT><I><FONT COLOR=maroon>term</FONT></I><A NAME="@default533"></A><A NAME="@tactic83"></A></H3><P>
This tactic applies to a goal which has the form <TT>t=u</TT>
and transforms it into the two subgoals 
<TT>t=</TT><I><FONT COLOR=maroon>term</FONT></I> and <I><FONT COLOR=maroon>term</FONT></I><TT>=u</TT>.</P><H3 CLASS="subsection"><A NAME="htoc230">8.8.7</A>  <TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default534"></A><A NAME="@tactic84"></A></H3><P>This tactic applies to a goal which has <I><FONT COLOR=maroon>ident</FONT></I> in its context and
(at least) one hypothesis, say <TT>H</TT>, of type <I><FONT COLOR=maroon>ident</FONT></I><TT>=t</TT> or <TT>t=</TT><I><FONT COLOR=maroon>ident</FONT></I>. Then it replaces 
<I><FONT COLOR=maroon>ident</FONT></I> by <TT>t</TT> everywhere in the goal (in the hypotheses 
and in the conclusion) and clears <I><FONT COLOR=maroon>ident</FONT></I> and <TT>H</TT> from the context.</P><P><BR>
<B>Remark: </B>When several hypotheses have the form <I><FONT COLOR=maroon>ident</FONT></I><TT>=t</TT> or <TT>t=</TT><I><FONT COLOR=maroon>ident</FONT></I>, the first one is used. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
 Is equivalent to <TT>subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>; &#X2026;; subst </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.
</LI><LI CLASS="li-enumerate"><TT>subst</TT><BR>
 Applies <TT>subst</TT> repeatedly to all identifiers from the context
for which an equality exists.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc231">8.8.8</A>  <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I></H3><P>
<A NAME="@default535"></A><A NAME="@tactic85"></A></P><P>This tactic is for chaining rewriting steps. It assumes a goal of the
form &#X201C;<I>R</I> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X201D; where <I>R</I> is a binary relation
and relies on a database of lemmas of the form <TT>forall</TT> <I>x</I> <I>y</I>
<I>z</I>, <I>R</I> <I>x</I> <I>y</I> <TT>-&gt;</TT> <I>eq</I> <I>x</I> <I>z</I> <TT>-&gt;</TT> <I>R</I> <I>z</I> <I>y</I> where <I>eq</I>
is typically a setoid equality. The application of <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I>
then replaces the goal by &#X201C;<I>R</I> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>&#X201D; and adds a new
goal stating &#X201C;<I>eq</I> <I><FONT COLOR=maroon>term</FONT></I> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB>&#X201D;.</P><P>Lemmas are added to the database using the command 
<A NAME="@default536"></A><A NAME="@command168"></A>
</P><BLOCKQUOTE CLASS="quote">
<TT>Declare Left Step </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT>
</BLOCKQUOTE><P>The tactic is especially useful for parametric setoids which are not
accepted as regular setoids for <TT>rewrite</TT> and <TT>setoid_replace</TT> (see chapter <A HREF="Reference-Manual026.html#setoid_replace">21</A>).</P><P><A NAME="@default537"></A><A NAME="@tactic86"></A>
<A NAME="@default538"></A><A NAME="@command169"></A>
<BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I><TT><I><FONT COLOR=maroon>n</FONT></I></TT><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This applies <TT>stepl </TT><I><FONT COLOR=maroon>term</FONT></I> then applies <I><FONT COLOR=maroon>tactic</FONT></I> to the second goal.</LI><LI CLASS="li-enumerate"><TT>stepr </TT><I><FONT COLOR=maroon>term</FONT></I><BR>
 <TT>stepr </TT><I><FONT COLOR=maroon>term</FONT></I><TT> by </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
This behaves as <TT>stepl</TT> but on the right-hand-side of the binary relation.
Lemmas are expected to be of the form
&#X201C;<TT>forall</TT> <I>x</I> <I>y</I>
<I>z</I>, <I>R</I> <I>x</I> <I>y</I> <TT>-&gt;</TT> <I>eq</I> <I>y</I> <I>z</I> <TT>-&gt;</TT> <I>R</I> <I>x</I> <I>z</I>&#X201D;
and are registered using the command
<BLOCKQUOTE CLASS="quote">
<TT>Declare Right Step </TT><I><FONT COLOR=maroon>term</FONT></I><TT>.</TT>
</BLOCKQUOTE>
</LI></OL><H2 CLASS="section"><A NAME="toc55"></A><A NAME="htoc232">8.9</A>  Equality and inductive sets</H2><P>We describe in this section some special purpose tactics dealing with
equality and inductive sets or types. These tactics use the equality
<TT>eq:forall (A:Type), A-&gt;A-&gt;Prop</TT>, simply written with the
infix symbol <TT>=</TT>.</P><H3 CLASS="subsection"><A NAME="htoc233">8.9.1</A>  <TT>decide equality
</TT><A NAME="decideequality"></A><TT>
</TT><A NAME="@default539"></A><A NAME="@tactic87"></A></H3><P>This tactic solves a goal of the form
<TT>forall </TT><TT><I>x</I></TT><TT> </TT><TT><I>y</I></TT><TT>:</TT><TT><I>R</I></TT><TT>, {</TT><TT><I>x</I></TT><TT>=</TT><TT><I>y</I></TT><TT>}+{</TT><CODE><TT>~</TT></CODE><TT><I>x</I></TT><TT>=</TT><TT><I>y</I></TT><TT>}</TT>, where <I>R</I>
is an inductive type such that its constructors do not take proofs or
functions as arguments, nor objects in dependent types.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>decide equality </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT> </TT>.<BR>
 Solves a goal of the form <TT>{</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>}+{</TT><CODE><TT>~</TT></CODE><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB><TT>}</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc234">8.9.2</A>  <TT>compare </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB><TT>
</TT><A NAME="@default540"></A><A NAME="@tactic88"></A></H3><P>This tactic compares two given objects <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> 
of an inductive datatype. If <I>G</I> is the current goal, it leaves the sub-goals
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> <TT>-&gt;</TT> <I>G</I> and <CODE>~</CODE><I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>
<TT>-&gt;</TT> <I>G</I>. The type
of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> must satisfy the same restrictions as in the tactic
<TT>decide equality</TT>.</P><H3 CLASS="subsection"><A NAME="htoc235">8.9.3</A>  <TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="discriminate"></A><TT>
</TT><A NAME="@default541"></A><A NAME="@tactic89"></A></H3><P>This tactic proves any goal from an absurd hypothesis stating that two
structurally different terms of an inductive set are equal. For
example, from the hypothesis <TT>(S (S O))=(S O)</TT> we can derive by
absurdity any proposition. Let <I><FONT COLOR=maroon>ident</FONT></I> be a hypothesis of type
<I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> in the local context, <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> being elements of an inductive set. To build the proof,
the tactic traverses the normal forms<SUP><A NAME="text17" HREF="#note17">4</A></SUP> of
<I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> looking for a couple of subterms <TT>u</TT>
and <TT>w</TT> (<TT>u</TT> subterm of the normal form of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<TT>w</TT> subterm of the normal form of <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>), placed at the same
positions and whose head symbols are two different constructors. If
such a couple of subterms exists, then the proof of the current goal
is completed, otherwise the tactic fails.</P><P><BR>
<B>Remark: </B>If <I><FONT COLOR=maroon>ident</FONT></I> does not denote an hypothesis in the local context
but refers to an hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>ident</FONT></I> <TT>Not a discriminable equality</TT><A NAME="@error97"></A><BR>
 occurs when the type of the specified hypothesis is not an equation.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>discriminate</TT> <I><FONT COLOR=maroon>num</FONT></I><BR>
 This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the last
introduced hypothesis.
</LI><LI CLASS="li-enumerate"><TT>discriminate</TT><A NAME="@default542"></A><A NAME="@tactic90"></A><BR>
 It applies to a goal of the form <CODE><TT>~</TT></CODE><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> and it is equivalent to: 
<TT>unfold not; intro </TT><I><FONT COLOR=maroon>ident</FONT></I>; <TT>discriminate
</TT><I><FONT COLOR=maroon>ident</FONT></I>.<P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=a><LI CLASS="li-enumerate">
<TT>No discriminable equalities</TT><A NAME="@error98"></A><BR>
 occurs when the goal does not verify the expected preconditions.
</LI></OL></LI></OL><H3 CLASS="subsection"><A NAME="htoc236">8.9.4</A>  <TT>injection </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="injection"></A><TT>
</TT><A NAME="@default543"></A><A NAME="@tactic91"></A></H3><P>The <TT>injection</TT> tactic is based on the fact that constructors of
inductive sets are injections. That means that if <I>c</I> is a constructor
of an inductive set, and if (<I>c</I> <I>t</I><SUB>1</SUB><SUP>&#X2192;</SUP>) and (<I>c</I> <I>t</I><SUB>2</SUB><SUP>&#X2192;</SUP>) are two
terms that are equal then  <I>t</I><SUB>1</SUB><SUP>&#X2192;</SUP> and  <I>t</I><SUB>2</SUB><SUP>&#X2192;</SUP> are equal
too.</P><P>If <I><FONT COLOR=maroon>ident</FONT></I> is an hypothesis of type <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB>,
then <TT>injection</TT> behaves as applying injection as deep as possible to
derive the equality of all the subterms of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>
placed in the same positions. For example, from the hypothesis <TT>(S
(S n))=(S (S (S m))</TT> we may derive <TT>n=(S m)</TT>. To use this
tactic <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> should be elements of an inductive
set and they should be neither explicitly equal, nor structurally
different. We mean by this that, if <TT>n</TT><SUB><TT>1</TT></SUB> and <TT>n</TT><SUB><TT>2</TT></SUB> are
their respective normal forms, then:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>n</TT><SUB><TT>1</TT></SUB> and <TT>n</TT><SUB><TT>2</TT></SUB> should not be syntactically equal,
</LI><LI CLASS="li-itemize">there must not exist any couple of subterms <TT>u</TT> and <TT>w</TT>,
<TT>u</TT> subterm of <TT>n</TT><SUB><TT>1</TT></SUB> and <TT>w</TT> subterm of <TT>n</TT><SUB><TT>2</TT></SUB> ,
placed in the same positions and having different constructors as
head symbols.
</LI></UL><P>
If these conditions are satisfied, then, the tactic derives the
equality of all the subterms of <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> placed in
the same positions and puts them as antecedents of the current goal.</P><P><BR>
<B>Example: </B>Consider the following goal:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive list : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | nil : list</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | cons : nat -</TT><TT>&gt;</TT><TT> list -</TT><TT>&gt;</TT><TT> list.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P : list -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Show.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : list</I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : P nil</I></TT><BR>
<TT><I>  H0 : cons n l = cons 0 nil</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   P l</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> injection H0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : list</I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : P nil</I></TT><BR>
<TT><I>  H0 : cons n l = cons 0 nil</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   l = nil -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P l</I></TT><BR>
</DIV><P>Beware that <TT>injection</TT> yields always an equality in a sigma type
whenever the injected object has a dependent type.</P><P><BR>
<B>Remark: </B>If <I><FONT COLOR=maroon>ident</FONT></I> does not denote an hypothesis in the local context
but refers to an hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<I><FONT COLOR=maroon>ident</FONT></I> <TT>is not a projectable equality</TT><A NAME="@error99"></A> 
occurs when the type of
the hypothesis <I>id</I> does not verify the preconditions.
</LI><LI CLASS="li-enumerate"><TT>Not an equation</TT><A NAME="@error100"></A> occurs when the type of the
hypothesis <I>id</I> is not an equation.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>injection</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>injection </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the last
introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><TT>injection</TT><A NAME="@default544"></A><A NAME="@tactic92"></A> <P>If the current goal is of the form <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> <TT>&lt;&gt;</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB>,
the tactic computes the head normal form of the goal and then
behaves as the sequence: <TT>unfold not; intro </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; injection
</TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Error message: </B><TT>goal does not satisfy the expected preconditions</TT><A NAME="@error101"></A></P></LI><LI CLASS="li-enumerate"><TT>injection</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>injection</TT> <I><FONT COLOR=maroon>num</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<TT>injection</TT> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> &#X2026; <I><FONT COLOR=maroon>intro_pattern</FONT></I><BR>
<A NAME="@default545"></A><A NAME="@tactic93"></A><P>These variants apply <TT>intros</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>  &#X2026;  <I><FONT COLOR=maroon>intro_pattern</FONT></I> after the call to <TT>injection</TT>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc237">8.9.5</A>  <TT>simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default546"></A><A NAME="@tactic94"></A><TT>
</TT><A NAME="simplify-eq"></A></H3><P>Let <I><FONT COLOR=maroon>ident</FONT></I> be the name of an hypothesis of type <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>=</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>2</TT></SUB> in the local context. If <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> and
<I><FONT COLOR=maroon>term</FONT></I><SUB>2</SUB> are structurally different (in the sense described for the
tactic <TT>discriminate</TT>), then the tactic <TT>simplify_eq</TT> behaves as <TT>discriminate </TT><I><FONT COLOR=maroon>ident</FONT></I> otherwise it behaves as <TT>injection
</TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Remark: </B>If <I><FONT COLOR=maroon>ident</FONT></I> does not denote an hypothesis in the local context
but refers to an hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>simplify_eq</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the last
introduced hypothesis.
</P></LI><LI CLASS="li-enumerate"><TT>simplify_eq</TT>
If the current goal has form <CODE>~</CODE><I>t</I><SUB>1</SUB>=<I>t</I><SUB>2</SUB>, then this tactic does 
<TT>hnf; intro </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>; simplify_eq </TT><I><FONT COLOR=maroon>ident</FONT></I>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc238">8.9.6</A>  <TT>dependent rewrite -&gt; </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default547"></A><A NAME="@tactic95"></A><TT>
</TT><A NAME="dependent-rewrite"></A></H3><P>This tactic applies to any goal. If <I><FONT COLOR=maroon>ident</FONT></I> has type 
<CODE>(existS A B a b)=(existS A B a' b')</CODE> 
in the local context (i.e. each term of the
equality has a sigma type { <I>a</I>:<I>A</I>  &amp; (<I>B</I> <I>a</I>)}) this tactic rewrites
<CODE>a</CODE> into <CODE>a'</CODE> and <CODE>b</CODE> into <CODE>b'</CODE> in the current
goal. This tactic works even if <I>B</I> is also a sigma type. This kind
of equalities between dependent pairs may be derived by the injection
and inversion tactics.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>dependent rewrite &lt;- </TT><I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default548"></A><A NAME="@tactic96"></A><BR>
Analogous to <TT>dependent rewrite -&gt;</TT> but uses the equality from
right to left.
</LI></OL><H2 CLASS="section"><A NAME="toc56"></A><A NAME="htoc239">8.10</A>  Inversion
<A NAME="inversion"></A></H2><H3 CLASS="subsection"><A NAME="htoc240">8.10.1</A>  <TT>inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
</TT><A NAME="@default549"></A><A NAME="@tactic97"></A></H3><P>Let the type of <I><FONT COLOR=maroon>ident</FONT></I>  in the local context be (<I>I</I> <I>t</I><SUP>&#X2192;</SUP>),
where <I>I</I> is a (co)inductive predicate. Then,
<TT>inversion</TT> applied to <I><FONT COLOR=maroon>ident</FONT></I>  derives for each possible
constructor <I>c</I><SUB><I>i</I></SUB> of (<I>I</I> <I>t</I><SUP>&#X2192;</SUP>), <B>all</B> the necessary
conditions that should hold for the instance (<I>I</I> <I>t</I><SUP>&#X2192;</SUP>) to be
proved by <I>c</I><SUB><I>i</I></SUB>.</P><P><BR>
<B>Remark: </B>If <I><FONT COLOR=maroon>ident</FONT></I> does not denote an hypothesis in the local context
but refers to an hypothesis quantified in the goal, then the
latter is first introduced in the local context using
<TT>intros until </TT><I><FONT COLOR=maroon>ident</FONT></I>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>inversion </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the identifier for the
last introduced hypothesis.</P></LI><LI CLASS="li-enumerate"><A NAME="@default550"></A><A NAME="@tactic98"></A> <TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I><P>This behaves as <TT>inversion</TT> and then erases <I><FONT COLOR=maroon>ident</FONT></I>  from the
context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default551"></A><A NAME="@tactic99"></A> <TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This behaves as <TT>inversion</TT> but using names in
<I><FONT COLOR=maroon>intro_pattern</FONT></I> for naming hypotheses. The <I><FONT COLOR=maroon>intro_pattern</FONT></I> must have
the form <TT>[</TT> <I>p</I><SUB>11</SUB> &#X2026;<I>p</I><SUB>1<I>n</I><SUB>1</SUB></SUB> <TT>|</TT> &#X2026; <TT>|</TT>
<I>p</I><SUB><I>m</I>1</SUB> &#X2026;<I>p</I><SUB><I>mn</I><SUB><I>m</I></SUB></SUB> <TT>]</TT> with <I>m</I> being the number of
constructors of the type of <I><FONT COLOR=maroon>ident</FONT></I>. Be careful that the list must
be of length <I>m</I> even if <TT>inversion</TT> discards some cases (which
is precisely one of its roles): for the discarded cases, just use an
empty list (i.e. <I>n</I><SUB><I>i</I></SUB>=0).</P><P>The arguments of the <I>i</I><SUP><I>th</I></SUP> constructor and the
equalities that <TT>inversion</TT> introduces in the context of the
goal corresponding to the <I>i</I><SUP><I>th</I></SUP> constructor, if it exists, get
their names from the list <I>p</I><SUB><I>i</I>1</SUB> &#X2026;<I>p</I><SUB><I>in</I><SUB><I>i</I></SUB></SUB> in order. If
there are not enough names, <TT>induction</TT> invents names for the
remaining variables to introduce. In case an equation splits into
several equations (because <TT>inversion</TT> applies <TT>injection</TT>
on the equalities it generates), the corresponding name <I>p</I><SUB><I>ij</I></SUB> in
the list must be replaced by a sublist of the form <TT>[</TT><TT><I>p</I></TT><SUB><TT><I>ij</I>1</TT></SUB><TT>
&#X2026;</TT><TT><I>p</I></TT><SUB><TT><I>ijq</I></TT></SUB><TT>]</TT> (or, equivalently, <TT>(</TT><TT><I>p</I></TT><SUB><TT><I>ij</I>1</TT></SUB><TT>,
&#X2026;, </TT><TT><I>p</I></TT><SUB><TT><I>ijq</I></TT></SUB><TT>)</TT>) where <I>q</I> is the number of subequations
obtained from splitting the original equation. Here is an example.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive contains0 : list nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | in_hd : forall l, contains0 (0 :: l)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | in_tl : forall l b, contains0 l -</TT><TT>&gt;</TT><TT> contains0 (b :: l).</TT><BR>
<TT><I>contains0 is defined</I></TT><BR>
<TT><I>contains0_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall l:list nat, contains0 (1 :: l) -</TT><TT>&gt;</TT><TT> contains0 l.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall l : list nat, contains0 (1 :: l) -</I></TT><TT><I>&gt;</I></TT><TT><I> contains0 l</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros l H; inversion H as [ | l' p Hl' [Heqp Heql'] ].</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  l : list nat</I></TT><BR>
<TT><I>  H : contains0 (1 :: l)</I></TT><BR>
<TT><I>  l' : list nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  Hl' : contains0 l</I></TT><BR>
<TT><I>  Heqp : p = 1</I></TT><BR>
<TT><I>  Heql' : l' = l</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   contains0 l</I></TT><BR>
</DIV></LI><LI CLASS="li-enumerate"><TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced by
<TT>inversion</TT> <I><FONT COLOR=maroon>num</FONT></I> in the context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default552"></A><A NAME="@tactic100"></A> <TT>inversion_clear</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced by
<TT>inversion_clear</TT> in the context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default553"></A><A NAME="@tactic101"></A> <TT>inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I>
<TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>Let <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, be identifiers in the local context. This
tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, and
then performing <TT>inversion</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default554"></A><A NAME="@tactic102"></A> <TT>inversion </TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; 
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This allows to name the hypotheses introduced in the context by
<TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; 
<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default555"></A><A NAME="@tactic103"></A> <TT>inversion_clear</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>Let <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, be identifiers in the local context. This
tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>, and
then performing <TT>inversion_clear</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default556"></A><A NAME="@tactic104"></A>
<TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>
<TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This allows to name the hypotheses introduced in the context by
<TT>inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default557"></A><A NAME="@tactic105"></A> <TT>dependent inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <P>That must be used when <I><FONT COLOR=maroon>ident</FONT></I> appears in the current goal. It acts
like <TT>inversion</TT> and then substitutes <I><FONT COLOR=maroon>ident</FONT></I> for the
corresponding term in the goal.</P></LI><LI CLASS="li-enumerate"><A NAME="@default558"></A><A NAME="@tactic106"></A> <TT>dependent
inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default559"></A><A NAME="@tactic107"></A> <TT>dependent
inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <P>Like <TT>dependent inversion</TT>, except that <I><FONT COLOR=maroon>ident</FONT></I> is cleared
from the local context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default560"></A><A NAME="@tactic108"></A>
<TT>dependent inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I><TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I></P></LI><LI CLASS="li-enumerate"><A NAME="@default561"></A><A NAME="@tactic109"></A> <TT>dependent
inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This variant allow to give the good generalization of the goal. It
is useful when the system fails to generalize the goal automatically. If
<I><FONT COLOR=maroon>ident</FONT></I> has type (<I>I</I> <I>t</I><SUP>&#X2192;</SUP>) and <I>I</I> has type
<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>s</I>, then <I><FONT COLOR=maroon>term</FONT></I>  must be of type
<I>I</I>:<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>I</I> <I>x</I><SUP>&#X2192;</SUP>&#X2192; <I>s</I>' where <I>s</I>' is the
type of the goal.</P></LI><LI CLASS="li-enumerate"><A NAME="@default562"></A><A NAME="@tactic110"></A>
<TT>dependent inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I>
<TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default563"></A><A NAME="@tactic111"></A>
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>Like <TT>dependent inversion &#X2026; with</TT> but clears <I><FONT COLOR=maroon>ident</FONT></I>from
the local context.</P></LI><LI CLASS="li-enumerate"><A NAME="@default564"></A><A NAME="@tactic112"></A>
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT>
<I><FONT COLOR=maroon>intro_pattern</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I><P>This allows to name the hypotheses introduced in the context by
<TT>dependent inversion_clear </TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT> with </TT> <I><FONT COLOR=maroon>term</FONT></I>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default565"></A><A NAME="@tactic113"></A> <TT>simple inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I><P>It is a very primitive inversion tactic that derives all the necessary
equalities but it does not simplify the constraints as
<TT>inversion</TT> do.</P></LI><LI CLASS="li-enumerate"><A NAME="@default566"></A><A NAME="@tactic114"></A> <TT>simple inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>as</TT> <I><FONT COLOR=maroon>intro_pattern</FONT></I> <P>This allows to name the hypotheses introduced in the context by
<TT>simple inversion</TT>.</P></LI><LI CLASS="li-enumerate"><A NAME="@default567"></A><A NAME="@tactic115"></A> <TT>inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I><TT> using</TT> <I><FONT COLOR=maroon>ident</FONT></I>' <P>Let <I><FONT COLOR=maroon>ident</FONT></I> have type (<I>I</I> <I>t</I><SUP>&#X2192;</SUP>) (<I>I</I> an inductive
predicate) in the local context, and <I><FONT COLOR=maroon>ident</FONT></I>' be a (dependent) inversion
lemma. Then, this tactic refines the current goal with the specified
lemma.</P></LI><LI CLASS="li-enumerate"><A NAME="@default568"></A><A NAME="@tactic116"></A> <TT>inversion</TT>
<I><FONT COLOR=maroon>ident</FONT></I> <TT>using</TT> <I><FONT COLOR=maroon>ident</FONT></I>' <TT>in</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This tactic behaves as generalizing <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>,
then doing <TT>inversion</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>using</TT> <I><FONT COLOR=maroon>ident</FONT></I>'.</P></LI></OL><P><BR>
<B>See also: </B> <A HREF="Reference-Manual012.html#inversion-examples">10.5</A> for detailed examples</P><H3 CLASS="subsection"><A NAME="htoc241">8.10.2</A>  <TT>Derive Inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> with
</TT><TT><I>forall</I> (</TT><TT><I>x</I></TT><SUP><TT>&#X2192;</TT></SUP><TT>:</TT><TT><I>T</I></TT><SUP><TT>&#X2192;</TT></SUP><TT>),</TT><TT> <I>I</I> </TT><TT><I>t</I></TT><SUP><TT>&#X2192;</TT></SUP><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><A NAME="Derive-Inversion"></A><TT>
</TT><A NAME="@default569"></A><A NAME="@command170"></A></H3><P>This command generates an inversion principle for the
<TT>inversion &#X2026; using</TT> tactic.
Let <I>I</I> be an inductive predicate and <I>x</I><SUP>&#X2192;</SUP> the variables
occurring in <I>t</I><SUP>&#X2192;</SUP>. This command generates and stocks the
inversion lemma for the sort <I><FONT COLOR=maroon>sort</FONT></I>  corresponding to the instance
<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>I</I> <I>t</I><SUP>&#X2192;</SUP> with the name <I><FONT COLOR=maroon>ident</FONT></I> in the <B>global</B> environment. When applied it is equivalent to have inverted
the instance with the tactic <TT>inversion</TT>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Derive Inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<A NAME="@default570"></A><A NAME="@command171"></A>
<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>I</I> <I>t</I><SUP>&#X2192;</SUP> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default571"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>inversion</TT>
replaced by the tactic <TT>inversion_clear</TT>.
</LI><LI CLASS="li-enumerate"><TT>Derive Dependent Inversion</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>I</I> <I>t</I><SUP>&#X2192;</SUP> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default572"></A><A NAME="@command172"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>dependent inversion</TT>.
</LI><LI CLASS="li-enumerate"><TT>Derive Dependent Inversion_clear</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>with</TT>
<I>forall</I> (<I>x</I><SUP>&#X2192;</SUP>:<I>T</I><SUP>&#X2192;</SUP>), <I>I</I> <I>t</I><SUP>&#X2192;</SUP> <TT>Sort</TT> <I><FONT COLOR=maroon>sort</FONT></I> <BR>
 <A NAME="@default573"></A><A NAME="@command173"></A>
When applied it is equivalent to having
inverted the instance with the tactic <TT>dependent inversion_clear</TT>.
</LI></OL><P><BR>
<B>See also: </B><A HREF="Reference-Manual012.html#inversion-examples">10.5</A> for examples</P><H3 CLASS="subsection"><A NAME="htoc242">8.10.3</A>  <TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I></H3><P>
<A NAME="sec:functional-inversion"></A></P><P><TT>functional inversion</TT> is a <EM>highly</EM> experimental tactic
which performs inversion on hypothesis <I><FONT COLOR=maroon>ident</FONT></I> of the form
<I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> = </TT><I><FONT COLOR=maroon>term</FONT></I> or <I><FONT COLOR=maroon>term</FONT></I><TT> =
</TT><I><FONT COLOR=maroon>qualid</FONT></I><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> where <I><FONT COLOR=maroon>qualid</FONT></I> must have been
defined using <TT>Function</TT> (section <A HREF="Reference-Manual004.html#Function">2.3</A>).</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>must contain at least one Function</TT><A NAME="@error102"></A>
</LI><LI CLASS="li-enumerate"><TT>Cannot find inversion information for hypothesis </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@error103"></A>
This error may be raised when some inversion lemma failed to be
generated by Function.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>functional inversion </TT><I><FONT COLOR=maroon>num</FONT></I><P>This does the same thing as <TT>intros until </TT><I><FONT COLOR=maroon>num</FONT></I> then
<TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I> where <I><FONT COLOR=maroon>ident</FONT></I> is the
identifier for the last introduced hypothesis.
</P></LI><LI CLASS="li-enumerate"><TT>functional inversion </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
 <TT>functional inversion </TT><I><FONT COLOR=maroon>num</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>In case the hypothesis <I><FONT COLOR=maroon>ident</FONT></I>(or <I><FONT COLOR=maroon>num</FONT></I>) has a type of the form
<I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>1</TT></SUB><TT> </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> =</TT><I><FONT COLOR=maroon>qualid</FONT></I><SUB><TT>2</TT></SUB><TT>
 </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I>+<I>m</I></TT></SUB> where <I><FONT COLOR=maroon>qualid</FONT></I><SUB>1</SUB> and <I><FONT COLOR=maroon>qualid</FONT></I><SUB>2</SUB>
are valid candidates to functional inversion, this variant allows to
chose which must be inverted.
</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc243">8.10.4</A>  <TT>quote </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="@default574"></A><A NAME="@tactic117"></A><TT>
</TT><A NAME="@default575"></A></H3><P>This kind of inversion has nothing to do with the tactic
<TT>inversion</TT> above. This tactic does <TT>change (</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>
 t)</TT>, where <TT>t</TT> is a term build in order to ensure the
convertibility. In other words, it does inversion of the function
<I><FONT COLOR=maroon>ident</FONT></I>. This function must be a fixpoint on a simple recursive
datatype: see <A HREF="Reference-Manual012.html#quote-examples">10.7</A> for the full details.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>quote: not a simple fixpoint</TT><A NAME="@error104"></A><BR>
 Happens when <TT>quote</TT> is not able to perform inversion properly.
</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>quote </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> [ </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> ]</TT><BR>
 All terms that are build only with <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> will be
considered by <TT>quote</TT> as constants rather than variables.
</LI></OL><H2 CLASS="section"><A NAME="toc57"></A><A NAME="htoc244">8.11</A>  Classical tactics</H2><P>
<A NAME="ClassicalTactics"></A></P><P>In order to ease the proving process, when the <TT>Classical</TT> module is loaded. A few more tactics are available. Make sure to load the module using the <TT>Require Import</TT> command.</P><H3 CLASS="subsection"><A NAME="htoc245">8.11.1</A>  <TT>classical_left, classical_right</TT> <A NAME="@default576"></A><A NAME="@tactic118"></A> <A NAME="@default577"></A><A NAME="@tactic119"></A></H3><P>The tactics <TT>classical_left</TT> and <TT>classical_right</TT> are the analog of the <TT>left</TT> and <TT>right</TT> but using classical logic. They can only be used for disjunctions.
Use <TT>classical_left</TT> to prove the left part of the disjunction with the assumption that the negation of right part holds. 
Use <TT>classical_left</TT> to prove the right part of the disjunction with the assumption that the negation of left part holds. </P><H2 CLASS="section"><A NAME="toc58"></A><A NAME="htoc246">8.12</A>  Automatizing
<A NAME="Automatizing"></A></H2><H3 CLASS="subsection"><A NAME="htoc247">8.12.1</A>  <TT>auto
</TT><A NAME="auto"></A><TT>
</TT><A NAME="@default578"></A><A NAME="@tactic120"></A></H3><P>This tactic implements a Prolog-like resolution procedure to solve the
current goal. It first tries to solve the goal using the <TT>assumption</TT> tactic, then it reduces the goal to an atomic one using
<TT>intros</TT> and introducing the newly generated hypotheses as hints.
Then it looks at the list of tactics associated to the head symbol of
the goal and tries to apply one of them (starting from the tactics
with lower cost). This process is recursively applied to the generated
subgoals. </P><P>By default, <TT>auto</TT> only uses the hypotheses of the current goal and the
hints of the database named <TT>core</TT>. </P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>auto </TT><I><FONT COLOR=maroon>num</FONT></I><P>Forces the search depth to be <I><FONT COLOR=maroon>num</FONT></I>. The maximal search depth is 5 by
default. </P></LI><LI CLASS="li-enumerate"><TT>auto with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><P>Uses the hint databases <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> in addition to
the database <TT>core</TT>. See Section <A HREF="#Hints-databases">8.13.1</A> for the
list of pre-defined databases and the way to create or extend a
database. This option can be combined with the previous one.</P></LI><LI CLASS="li-enumerate"><TT>auto with *</TT><P>Uses all existing hint databases, minus the special database
<TT>v62</TT>. See Section <A HREF="#Hints-databases">8.13.1</A></P></LI><LI CLASS="li-enumerate"><TT>auto using </TT><TT><I>lemma</I></TT><SUB><TT>1</TT></SUB><TT>, &#X2026;, <I>lemma</I></TT><SUB><TT><I>n</I></TT></SUB><P>Uses <I>lemma</I><SUB>1</SUB>, &#X2026;, <I>lemma</I><SUB><I>n</I></SUB> in addition to hints (can be conbined
with the <TT>with </TT><I><FONT COLOR=maroon>ident</FONT></I> option).</P></LI><LI CLASS="li-enumerate"><TT>trivial</TT><A NAME="@default579"></A><A NAME="@tactic121"></A><P>This tactic is a restriction of <TT>auto</TT> that is not recursive and 
tries only hints which cost is 0. Typically it solves trivial
equalities like <I>X</I>=<I>X</I>.</P></LI><LI CLASS="li-enumerate"><TT>trivial with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB></LI><LI CLASS="li-enumerate"><TT>trivial with *</TT></LI></OL><P><BR>
<B>Remark: </B><TT>auto</TT> either solves completely the goal or else leave it
intact. <TT>auto</TT> and <TT>trivial</TT> never fail.</P><P><BR>
<B>See also: </B>Section <A HREF="#Hints-databases">8.13.1</A></P><H3 CLASS="subsection"><A NAME="htoc248">8.12.2</A>  <TT>eauto
</TT><A NAME="@default580"></A><A NAME="@tactic122"></A><TT>
</TT><A NAME="eauto"></A></H3><P>This tactic generalizes <TT>auto</TT>. In contrast with 
the latter, <TT>eauto</TT> uses unification of the goal
against the hints rather than pattern-matching
(in other words, it uses <TT>eapply</TT> instead of
<TT>apply</TT>).
As a consequence, <TT>eauto</TT> can solve such a goal:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve ex_intro.</TT><BR>
<TT><I>Warning: the hint: eapply ex_intro will only be used by eauto</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall P:nat -</TT><TT>&gt;</TT><TT> Prop, P 0 -</TT><TT>&gt;</TT><TT>  exists n, P n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop, P0 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> exists n : nat, P0 n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Note that <TT>ex_intro</TT> should be declared as an
hint.</P><P><BR>
<B>See also: </B>Section <A HREF="#Hints-databases">8.13.1</A></P><H3 CLASS="subsection"><A NAME="htoc249">8.12.3</A>  <TT>tauto
</TT><A NAME="@default581"></A><A NAME="@tactic123"></A><TT>
</TT><A NAME="tauto"></A></H3><P>This tactic implements a decision procedure for intuitionistic propositional
calculus based on the contraction-free sequent calculi LJT* of Roy Dyckhoff
[<A HREF="biblio.html#Dyc92"><CITE>50</CITE></A>]. Note that <TT>tauto</TT> succeeds on any instance of an
intuitionistic tautological proposition. <TT>tauto</TT> unfolds negations
and logical equivalence but does not unfold any other definition.</P><P>The following goal can be proved by <TT>tauto</TT> whereas <TT>auto</TT>
would fail:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (x:nat) (P:nat -</TT><TT>&gt;</TT><TT> Prop), x = 0 </TT><TT>\</TT><TT>/ P x -</TT><TT>&gt;</TT><TT> x </TT><TT>&lt;</TT><TT>&gt;</TT><TT> 0 -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall (x : nat) (P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop), x = 0 </I></TT><TT><I>\</I></TT><TT><I>/ P0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  H : x = 0 </I></TT><TT><I>\</I></TT><TT><I>/ P0 x</I></TT><BR>
<TT><I>  H0 : x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Moreover, if it has nothing else to do, <TT>tauto</TT> performs
introductions. Therefore, the use of <TT>intros</TT> in the previous
proof is unnecessary. <TT>tauto</TT> can for instance prove the
following:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> (* auto would fail *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (A:Prop) (P:nat -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     A </TT><TT>\</TT><TT>/ (forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall (A : Prop) (P0 : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ (forall x : nat, </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x) -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x : nat, </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> P0 x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P><BR>
<B>Remark: </B>In contrast, <TT>tauto</TT> cannot solve the following goal</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall (A:Prop) (P:nat -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     A </TT><TT>\</TT><TT>/ (forall x:nat, </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall x:nat, </TT><TT>~</TT><TT> </TT><TT>~</TT><TT> (A </TT><TT>\</TT><TT>/ P x).</TT><BR>
</DIV><P>because <CODE>(forall x:nat, ~ A -&gt; P x)</CODE> cannot be treated as atomic and an
instantiation of <CODE>x</CODE> is necessary.</P><H3 CLASS="subsection"><A NAME="htoc250">8.12.4</A>  <TT>intuition </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>
</TT><A NAME="@default582"></A><A NAME="@tactic124"></A><TT>
</TT><A NAME="intuition"></A></H3><P>The tactic <TT>intuition</TT> takes advantage of the search-tree built
by the decision procedure involved in the tactic <TT>tauto</TT>. It uses
this information to generate a set of subgoals equivalent to the
original one (but simpler than it) and applies the tactic 
<I><FONT COLOR=maroon>tactic</FONT></I> to them [<A HREF="biblio.html#Mun94"><CITE>96</CITE></A>]. If this tactic fails on some goals then
<TT>intuition</TT> fails. In fact, <TT>tauto</TT> is simply <TT>intuition
fail</TT>.</P><P>For instance, the tactic <TT>intuition auto</TT> applied to the goal
</P><PRE CLASS="verbatim">(forall (x:nat), P x)/\B -&gt; (forall (y:nat),P y)/\ P O \/B/\ P O
</PRE><P>internally replaces it by the equivalent one:
</P><PRE CLASS="verbatim">(forall (x:nat), P x), B |- P O
</PRE><P>and then uses <TT>auto</TT> which completes the proof.</P><P>Originally due to César Muñoz, these tactics (<TT>tauto</TT> and <TT>intuition</TT>)
have been completely reengineered by David Delahaye using mainly the tactic
language (see chapter <A HREF="Reference-Manual011.html#TacticLanguage">9</A>). The code is now quite shorter and
a significant increase in performances has been noticed. The general behavior
with respect to dependent types, unfolding and introductions has
slightly changed to get clearer semantics. This may lead to some
incompatibilities.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>intuition</TT><BR>
 Is equivalent to <TT>intuition auto with *</TT>.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc251">8.12.5</A>  <TT>rtauto
</TT><A NAME="@default583"></A><A NAME="@tactic125"></A><TT>
</TT><A NAME="rtauto"></A></H3><P>The <TT>rtauto</TT> tactic solves propositional tautologies similarly to what <TT>tauto</TT> does. The main difference is that the proof term is built using a reflection scheme applied to a sequent calculus proof of the goal. The search procedure is also implemented using a different technique. </P><P>Users should be aware that this difference may result in faster proof-search but slower proof-checking, and <TT>rtauto</TT> might not solve goals that <TT>tauto</TT> would be able to solve (e.g. goals involving universal quantifiers). </P><H3 CLASS="subsection"><A NAME="htoc252">8.12.6</A>  <TT>firstorder</TT>
<A NAME="@default584"></A><A NAME="@tactic126"></A>
<A NAME="firstorder"></A></H3><P>The tactic <TT>firstorder</TT> is an <I>experimental</I> extension of
<TT>tauto</TT> to 
first-order reasoning, written by Pierre Corbineau. 
It is not restricted to usual logical connectives but
instead may reason about any first-order class inductive definition.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>firstorder </TT><I><FONT COLOR=maroon>tactic</FONT></I>
<A NAME="@default585"></A><A NAME="@tactic127"></A><P>Tries to solve the goal with <I><FONT COLOR=maroon>tactic</FONT></I> when no logical rule may apply.</P></LI><LI CLASS="li-enumerate"><TT>firstorder with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT>
<A NAME="@default586"></A><A NAME="@tactic128"></A><P>Adds lemmas <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> to the proof-search
environment.</P></LI><LI CLASS="li-enumerate"><TT>firstorder using </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> </TT>
<A NAME="@default587"></A><A NAME="@tactic129"></A><P>Adds lemmas in <TT>auto</TT> hints bases <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>
to the proof-search environment.
</P></LI></OL><P>Proof-search is bounded by a depth parameter which can be set by typing the
<TT>Set Firstorder Depth </TT><TT><I>n</I></TT> <A NAME="@default588"></A><A NAME="@command174"></A> 
vernacular command.</P><H3 CLASS="subsection"><A NAME="htoc253">8.12.7</A>  <TT>congruence
</TT><A NAME="@default589"></A><A NAME="@tactic130"></A><TT>
</TT><A NAME="congruence"></A></H3><P>The tactic <TT>congruence</TT>, by Pierre Corbineau, implements the standard Nelson and Oppen
congruence closure algorithm, which is a decision procedure for ground
equalities with uninterpreted symbols. It also include the constructor theory
(see <A HREF="#injection">8.9.4</A> and <A HREF="#discriminate">8.9.3</A>).
If the goal is a non-quantified equality, <TT>congruence</TT> tries to
prove it with non-quantified equalities in the context. Otherwise it
tries to infer a discriminable equality from those in the context. Alternatively, congruence tries to prove that an hypothesis is equal to the goal or to the negation of another hypothesis.</P><P><TT>congruence</TT> is also able to take advantage of hypotheses stating quantified equalities, you have to provide a bound for the number of extra equalities generated that way. Please note that one of the memebers of the equality must contain all the quantified variables in order for <TT>congruence</TT> to match against it. </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem T: </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   a=(f a) -</TT><TT>&gt;</TT><TT> (g b (f a))=(f (f a)) -</TT><TT>&gt;</TT><TT> (g a b)=(f (g b a)) -</TT><TT>&gt;</TT><TT> (g a b)=a.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   a = f a -</I></TT><TT><I>&gt;</I></TT><TT><I> g b (f a) = f (f a) -</I></TT><TT><I>&gt;</I></TT><TT><I> g a b = f (g b a) -</I></TT><TT><I>&gt;</I></TT><TT><I> g a b = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : a = f a</I></TT><BR>
<TT><I>  H0 : g b (f a) = f (f a)</I></TT><BR>
<TT><I>  H1 : g a b = f (g b a)</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   g a b = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem inj : f = pair a -</TT><TT>&gt;</TT><TT> Some (f c) = Some (f d) -</TT><TT>&gt;</TT><TT> c=d.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f = pair (B:=A) a -</I></TT><TT><I>&gt;</I></TT><TT><I> Some (f c) = Some (f d) -</I></TT><TT><I>&gt;</I></TT><TT><I> c = d</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : f = pair (B:=A) a</I></TT><BR>
<TT><I>  H0 : Some (f c) = Some (f d)</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   c = d</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>congruence </TT><TT><I><FONT COLOR=maroon>n</FONT></I></TT><BR>
 Tries to add at most <TT><I><FONT COLOR=maroon>n</FONT></I></TT> instances of hypotheses satting quantifiesd equalities to the problem in order to solve it. A bigger value of <TT><I><FONT COLOR=maroon>n</FONT></I></TT> does not make success slower, only failure. You might consider adding some lemmata as hypotheses using <TT>assert</TT> in order for congruence to use them.</LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>congruence with </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><BR>
 Adds <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> to the pool of terms used by
<TT>congruence</TT>. This helps in case you have partially applied
constructors in your goal.
</LI></OL><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>I don't know how to handle dependent equality</TT><A NAME="@error105"></A><BR>
 The decision procedure managed to find a proof of the goal or of
a discriminable equality but this proof couldn't be built in Coq
because of dependently-typed functions.
</LI><LI CLASS="li-enumerate"><TT>I couldn't solve goal</TT><A NAME="@error106"></A><BR>
 The decision procedure didn't find any way to solve the goal.
</LI><LI CLASS="li-enumerate"><TT>Goal is solvable by congruence but some arguments are missing. Try "congruence with &#X2026;", replacing metavariables by arbitrary terms.</TT><A NAME="@error107"></A><BR>
 The decision procedure could solve the goal with the provision
that additional arguments are supplied for some partially applied
constructors. Any term of an appropriate type will allow the
tactic to successfully solve the goal. Those additional arguments
can be given to <TT>congruence</TT> by filling in the holes in the
terms given in the error message, using the <TT>with</TT> variant
described below.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc254">8.12.8</A>  <TT>omega
</TT><A NAME="@default590"></A><A NAME="@tactic131"></A><TT>
</TT><A NAME="omega"></A></H3><P>The tactic <TT>omega</TT>, due to Pierre Crégut,
is an automatic decision procedure for Presburger
arithmetic. It solves quantifier-free 
formulas built with <CODE>~</CODE>, <CODE>\/</CODE>, <CODE>/\</CODE>,
<CODE>-&gt;</CODE> on top of equalities and inequalities on
both the type <TT>nat</TT> of natural numbers and <TT>Z</TT> of binary
integers. This tactic must be loaded by the command <TT>Require Import
Omega</TT>. See the additional documentation about <TT>omega</TT>
(chapter <A HREF="Reference-Manual022.html#OmegaChapter">17</A>).</P><H3 CLASS="subsection"><A NAME="htoc255">8.12.9</A>  <TT>ring</TT> and <TT>ring_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
<A NAME="@default591"></A><A NAME="@tactic132"></A>
<A NAME="@default592"></A><A NAME="@tactic133"></A>
<A NAME="@default593"></A><A NAME="@command175"></A></H3><P>The <TT>ring</TT> tactic solves equations upon polynomial expressions of
a ring (or semi-ring) structure. It proceeds by normalizing both hand
sides of the equation (w.r.t. associativity, commutativity and
distributivity, constant propagation) and comparing syntactically the
results.</P><P><TT>ring_simplify</TT> applies the normalization procedure described
above to the terms given. The tactic then replaces all occurrences of
the terms given in the conclusion of the goal by their normal
forms. If no term is given, then the conclusion should be an equation
and both hand sides are normalized.</P><P>See chapter <A HREF="Reference-Manual025.html#ring">20</A> for more information on the tactic and how to
declare new ring structures.</P><H3 CLASS="subsection"><A NAME="htoc256">8.12.10</A>  <TT>field</TT>, <TT>field_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
and <TT>field_simplify_eq</TT>
<A NAME="@default594"></A><A NAME="@tactic134"></A>
<A NAME="@default595"></A><A NAME="@tactic135"></A>
<A NAME="@default596"></A><A NAME="@tactic136"></A>
<A NAME="@default597"></A><A NAME="@command176"></A></H3><P>The <TT>field</TT> tactic is built on the same ideas as <TT>ring</TT>: this
is a reflexive tactic that solves or simplifies equations in a field
structure. The main idea is to reduce a field expression (which is an
extension of ring expressions with the inverse and division
operations) to a fraction made of two polynomial expressions.</P><P>Tactic <TT>field</TT> is used to solve subgoals, whereas <TT>field_simplify </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT>&#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> replaces the provided terms
by their reducted fraction. <TT>field_simplify_eq</TT> applies when the
conclusion is an equation: it simplifies both hand sides and multiplies
so as to cancel denominators. So it produces an equation without
division nor inverse.</P><P>All of these 3 tactics may generate a subgoal in order to prove that
denominators are different from zero.</P><P>See chapter <A HREF="Reference-Manual025.html#ring">20</A> for more information on the tactic and how to
declare new field structures.</P><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y:R,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     (x * y </TT><TT>&gt;</TT><TT> 0)%R -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     (x * (1 / x + x / (x + y)))%R =</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     ((- 1 / y) * y * (- x * (x / (x + y)) - 1))%R.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros; field.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : R</I></TT><BR>
<TT><I>  y : R</I></TT><BR>
<TT><I>  H : (x * y </I></TT><TT><I>&gt;</I></TT><TT><I> 0)%R</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (x + y)%R </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R /</I></TT><TT><I>\</I></TT><TT><I> y </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R /</I></TT><TT><I>\</I></TT><TT><I> x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0%R</I></TT><BR>
</DIV><P><BR>
<B>See also: </B>file <TT>contrib/setoid_ring/RealField.v</TT> for an example of instantiation,<BR>
    theory <TT>theories/Reals</TT> for many examples of use of <TT>field</TT>.</P><H3 CLASS="subsection"><A NAME="htoc257">8.12.11</A>  <TT>fourier
</TT><A NAME="@default598"></A><A NAME="@tactic137"></A></H3><P>This tactic written by Loïc Pottier solves linear inequations on
real numbers using Fourier's method [<A HREF="biblio.html#Fourier"><CITE>59</CITE></A>]. This tactic must
be loaded by <TT>Require Import Fourier</TT>.</P><P><BR>
<B>Example: </B>
</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Fourier.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y:R, (x </TT><TT>&lt;</TT><TT> y)%R -</TT><TT>&gt;</TT><TT> (y + 1 </TT><TT>&gt;</TT><TT>= x - 1)%R.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros; fourier.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc258">8.12.12</A>  <TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.
</TT><A NAME="tactic:autorewrite"></A><TT>
</TT><A NAME="@default599"></A><A NAME="@tactic138"></A></H3><P>This tactic <SUP><A NAME="text18" HREF="#note18">5</A></SUP> carries out rewritings according
the rewriting rule bases <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>.</P><P>Each rewriting rule of a base <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> is applied to the main subgoal until
it fails. Once all the rules have been processed, if the main subgoal has
progressed (e.g., if it is distinct from the initial main goal) then the rules
of this base are processed again. If the main subgoal has not progressed then
the next base is processed. For the bases, the behavior is exactly similar to
the processing of the rewriting rules.</P><P>The rewriting rule bases are built with the <TT>Hint Rewrite</TT> vernacular
command.</P><P><BR>
<B>Warning: </B> This tactic may loop if you build non terminating rewriting systems.</P><P><BR>
<B>Variant: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>tactic</FONT></I><BR>
Performs, in the same way, all the rewritings of the bases <TT><I>ident</I></TT><SUB><TT>1</TT></SUB><TT> </TT><TT>...</TT><TT>
</TT><TT><I>ident</I></TT><SUB><TT><I>n</I></TT></SUB> applying <I><FONT COLOR=maroon>tactic</FONT></I> to the main subgoal after each rewriting step.</LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>Performs all the rewritings in hypothesis <I><FONT COLOR=maroon>qualid</FONT></I>.
</P></LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><I><FONT COLOR=maroon>qualid</FONT></I><P>Performs all the rewritings in hypothesis <I><FONT COLOR=maroon>qualid</FONT></I> applying <I><FONT COLOR=maroon>tactic</FONT></I> to the main subgoal after each rewriting step.</P></LI><LI CLASS="li-enumerate"><TT>autorewrite with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> in </TT><TT><I>clause</I></TT>
Performs all the rewritings in the clause <I>clause</I>.<BR>
 The <I>clause</I> arg must not contain any <TT>type of</TT> nor <TT>value of</TT>.</LI></OL><P><BR>
<B>See also: </B>section <A HREF="#HintRewrite">8.13.4</A> for feeding the database of lemmas used by <TT>autorewrite</TT>.</P><P><BR>
<B>See also: </B>section <A HREF="Reference-Manual012.html#autorewrite-example">10.6</A> for examples showing the use of
this tactic. </P><H2 CLASS="section"><A NAME="toc59"></A><A NAME="htoc259">8.13</A>  Controlling automation</H2><H3 CLASS="subsection"><A NAME="htoc260">8.13.1</A>  The hints databases for <TT>auto</TT> and <TT>eauto</TT>
<A NAME="@default600"></A>
<A NAME="Hints-databases"></A>
<A NAME="@default601"></A><A NAME="@command177"></A></H3><P>The hints for <TT>auto</TT> and <TT>eauto</TT> are stored in
databases. Each database maps head symbols to a list of hints. One can
use the command <TT>Print Hint </TT><I><FONT COLOR=maroon>ident</FONT></I> to display the hints
associated to the head symbol <I><FONT COLOR=maroon>ident</FONT></I> (see <A HREF="#PrintHint">8.13.3</A>). Each
hint has a cost that is an nonnegative integer, and a pattern. 
The hints with lower cost are tried first. A hint is tried by 
<TT>auto</TT> when the conclusion of the current goal
matches its pattern. The general
command to add a hint to some database <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> is:
</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP>
<TT>Hint</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>
</TD></TR>
</TABLE><P>
where <I><FONT COLOR=maroon>hint_definition</FONT></I> is one of the following expressions:</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I> 
<A NAME="@default602"></A><A NAME="@command178"></A><P>This command adds <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> to the hint list
with the head symbol of the type of <I><FONT COLOR=maroon>term</FONT></I>. The cost of that hint is
the number of subgoals generated by <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I>.</P><P>In case the inferred type of <I><FONT COLOR=maroon>term</FONT></I> does not start with a product the
tactic added in the hint list is <TT>exact </TT><I><FONT COLOR=maroon>term</FONT></I>. In case this
type can be reduced to a type starting with a product, the tactic <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> is also stored in the hints list.</P><P>If the inferred type of <I><FONT COLOR=maroon>term</FONT></I> does contain a dependent
quantification on a predicate, it is added to the hint list of <TT>eapply</TT> instead of the hint list of <TT>apply</TT>. In this case, a
warning is printed since the hint is only used by the tactic <TT>eauto</TT> (see <A HREF="#eauto">8.12.2</A>). A typical example of hint that is used
only by <TT>eauto</TT> is a transitivity lemma.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Bound head variable</TT><A NAME="@error108"></A><P>The head symbol of the type of <I><FONT COLOR=maroon>term</FONT></I> is a bound variable such
that this tactic cannot be associated to a constant.</P></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>term</FONT></I> <TT>cannot be used as a hint</TT><A NAME="@error109"></A><P>The type of <I><FONT COLOR=maroon>term</FONT></I> contains products over variables which do not
appear in the conclusion. A typical example is a transitivity axiom.
In that case the <TT>apply</TT> tactic fails, and thus is useless.</P></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB><P>Adds each <TT>Resolve</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Immediate </TT><I><FONT COLOR=maroon>term</FONT></I> 
<A NAME="@default603"></A><A NAME="@command179"></A><P>This command adds <TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I><TT>; trivial</TT> to the hint list
associated with the head symbol of the type of <I><FONT COLOR=maroon>ident</FONT></I>in the given
database. This tactic will fail if all the subgoals generated by
<TT>apply </TT><I><FONT COLOR=maroon>term</FONT></I> are not solved immediately by the <TT>trivial</TT>
tactic which only tries tactics with cost 0.</P><P>This command is useful for theorems such that the symmetry of equality
or <I>n</I>+1=<I>m</I>+1 &#X2192; <I>n</I>=<I>m</I> that we may like to introduce with a
limited use in order to avoid useless proof-search.</P><P>The cost of this tactic (which never generates subgoals) is always 1,
so that it is not used by <TT>trivial</TT> itself.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Bound head variable</TT><A NAME="@error110"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>term</FONT></I> <TT>cannot be used as a hint</TT><A NAME="@error111"></A> </LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Immediate</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>term</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Immediate</TT> <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I>
<A NAME="@default604"></A><A NAME="@command180"></A><P>If <I><FONT COLOR=maroon>ident</FONT></I> is an inductive type, this command adds all its
constructors as hints of type <TT>Resolve</TT>. Then, when the
conclusion of current goal has the form <TT>(</TT><I><FONT COLOR=maroon>ident</FONT></I><TT> &#X2026;)</TT>,
<TT>auto</TT> will try to apply each constructor.</P><P><BR>
<B>Error messages: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I> <TT>is not an inductive type</TT><A NAME="@error112"></A></LI><LI CLASS="li-enumerate"><I><FONT COLOR=maroon>ident</FONT></I> <TT>not declared</TT><A NAME="@error113"></A></LI></OL><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Constructors</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Unfold</TT> <I><FONT COLOR=maroon>qualid</FONT></I>
<A NAME="@default605"></A><A NAME="@command181"></A><P>This adds the tactic <TT>unfold </TT><I><FONT COLOR=maroon>qualid</FONT></I> to the hint list that
will only be used when the head constant of the goal is <I><FONT COLOR=maroon>ident</FONT></I>. Its
cost is 4.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Unfold</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB> <P>Adds each <TT>Unfold</TT> <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB>.</P></LI></OL></LI><LI CLASS="li-itemize"><TT>Extern </TT><I><FONT COLOR=maroon>num</FONT></I><TT> </TT><I><FONT COLOR=maroon>pattern</FONT></I><TT> =&gt; </TT><I><FONT COLOR=maroon>tactic</FONT></I>
<A NAME="@default606"></A><A NAME="@command182"></A><P>This hint type is to extend <TT>auto</TT> with tactics other than
<TT>apply</TT> and <TT>unfold</TT>. For that, we must specify a
cost, a pattern and a tactic to execute. Here is an example:</P><BLOCKQUOTE CLASS="quotation">
<PRE CLASS="verbatim">Hint Extern 4 ~(?=?) =&gt; discriminate.
</PRE></BLOCKQUOTE><P>Now, when the head of the goal is a disequality, <TT>auto</TT> will
try <TT>discriminate</TT> if it does not succeed to solve the goal
with hints with a cost less than 4.</P><P>One can even use some sub-patterns of the pattern in the tactic
script. A sub-pattern is a question mark followed by an ident, like
<TT>?X1</TT> or <TT>?X2</TT>. Here is an example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import List.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Extern 5   ({?X1 = ?X2} + {?X1 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> ?X2}) =</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  generalize X1 X2; decide equality : eqdec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> forall a b:list (nat * nat), {a = b} + {a </TT><TT>&lt;</TT><TT>&gt;</TT><TT> b}.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b : list (nat * nat), {a = b} + {a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> b}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> info auto with eqdec.</TT><BR>
<TT><I> == intro a; intro b; generalize a b;  decide equality; </I></TT><BR>
<TT><I>    generalize a1 p;  decide equality.</I></TT><BR>
<TT><I>    generalize b1 n0;  decide equality.</I></TT><BR>
<TT><I>    </I></TT><BR>
<TT><I>    generalize a3 n;  decide equality.</I></TT><BR>
<TT><I>    </I></TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV></LI></UL><P><BR>
<B>Remark: </B>There is currently (in the 8.1 release) no way to do
pattern-matching on hypotheses.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hint</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <P>No database name is given : the hint is registered in the <TT>core</TT> 
database. </P></LI><LI CLASS="li-enumerate"><TT>Hint Local</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <TT>:</TT>
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB><P>This is used to declare hints that must not be exported to the other
modules that require and import the current module. Inside a
section, the option <TT>Local</TT> is useless since hints do not
survive anyway to the closure of sections.</P></LI><LI CLASS="li-enumerate"><TT>Hint Local</TT> <I><FONT COLOR=maroon>hint_definition</FONT></I> <P>Idem for the <TT>core</TT> database.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc261">8.13.2</A>  Hint databases defined in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library</H3><P>Several hint databases are defined in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library. The
actual content of a database is the collection of the hints declared
to belong to this database in each of the various modules currently
loaded. Especially, requiring new modules potentially extend a
database. At <SPAN STYLE="font-variant:small-caps">Coq</SPAN> startup, only the <TT>core</TT> and <TT>v62</TT>
databases are non empty and can be used.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>core</TT></B></DT><DD CLASS="dd-description"> This special database is automatically used by
<TT>auto</TT>. It contains only basic lemmas about negation,
conjunction, and so on from. Most of the hints in this database come 
from the <TT>Init</TT> and <TT>Logic</TT> directories.</DD><DT CLASS="dt-description"><B><TT>arith</TT></B></DT><DD CLASS="dd-description"> This database contains all lemmas about Peano's
arithmetic proven in the directories <TT>Init</TT> and
<TT>Arith</TT></DD><DT CLASS="dt-description"><B><TT>zarith</TT></B></DT><DD CLASS="dd-description"> contains lemmas about binary signed integers from
the directories <TT>theories/ZArith</TT>. When required, the module
<TT>Omega</TT> also extends the database <TT>zarith</TT> with a high-cost
hint that calls <TT>omega</TT> on equations and inequations in <TT>nat</TT> or <TT>Z</TT>.</DD><DT CLASS="dt-description"><B><TT>bool</TT></B></DT><DD CLASS="dd-description"> contains lemmas about booleans, mostly from directory
<TT>theories/Bool</TT>.</DD><DT CLASS="dt-description"><B><TT>datatypes</TT></B></DT><DD CLASS="dd-description"> is for lemmas about lists, streams and so on that 
are mainly proven in the <TT>Lists</TT> subdirectory.</DD><DT CLASS="dt-description"><B><TT>sets</TT></B></DT><DD CLASS="dd-description"> contains lemmas about sets and relations from the 
directories <TT>Sets</TT> and <TT>Relations</TT>.
</DD></DL><P>There is also a special database called <TT>v62</TT>. It collects all
hints that were declared in the versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> prior to version
6.2.4 when the databases <TT>core</TT>, <TT>arith</TT>, and so on were
introduced. The purpose of the database <TT>v62</TT> is to ensure
compatibility with further versions of Coq for developments done in
versions prior to 6.2.4 (<TT>auto</TT> being replaced by <TT>auto with v62</TT>).
The database <TT>v62</TT> is intended not to be extended (!). It is not
included in the hint databases list used in the <TT>auto with *</TT> tactic.</P><P>Furthermore, you are advised not to put your own hints in the
<TT>core</TT> database, but use one or several databases specific to your
development.</P><H3 CLASS="subsection"><A NAME="htoc262">8.13.3</A>  <TT>Print Hint
</TT><A NAME="PrintHint"></A><TT>
</TT><A NAME="@default607"></A><A NAME="@command183"></A></H3><P>This command displays all hints that apply to the current goal. It
fails if no proof is being edited, while the two variants can be used at
every moment.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate"><TT>Print Hint </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT><P>This command displays only tactics associated with <I><FONT COLOR=maroon>ident</FONT></I> in the
hints list. This is independent of the goal being edited, to this
command will not fail if no goal is being edited.</P></LI><LI CLASS="li-enumerate"><TT>Print Hint *</TT><P>This command displays all declared hints. </P></LI><LI CLASS="li-enumerate"><TT>Print HintDb </TT><I><FONT COLOR=maroon>ident</FONT></I><TT> </TT>
<A NAME="PrintHintDb"></A>
<A NAME="@default608"></A><A NAME="@command184"></A><P>This command displays all hints from database <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc263">8.13.4</A>  <TT>Hint Rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><A NAME="HintRewrite"></A><TT>
</TT><A NAME="@default609"></A><A NAME="@command185"></A></H3><P>This vernacular command adds the terms <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB>
(their types must be equalities) in the rewriting base <I><FONT COLOR=maroon>ident</FONT></I>
with the default orientation (left to right). Notice that the
rewriting bases are distinct from the <TT>auto</TT> hint bases and that
<TT>auto</TT> does not take them into account.</P><P>This command is synchronous with the section mechanism (see <A HREF="Reference-Manual004.html#Section">2.4</A>):
when closing a section, all aliases created by <TT>Hint Rewrite</TT> in that
section are lost. Conversely, when loading a module, all <TT>Hint Rewrite</TT>
declarations at the global level of that module are loaded.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Hint Rewrite -&gt; </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
This is strictly equivalent to the command above (we only make explicit the
orientation which otherwise defaults to <TT>-&gt;</TT>).</LI><LI CLASS="li-enumerate"><TT>Hint Rewrite &lt;- </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
Adds the rewriting rules <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> with a right-to-left
orientation in the base <I><FONT COLOR=maroon>ident</FONT></I>.</LI><LI CLASS="li-enumerate"><TT>Hint Rewrite </TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB><TT> using </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT> : </TT><I><FONT COLOR=maroon>ident</FONT></I><BR>
When the rewriting rules <I><FONT COLOR=maroon>term</FONT></I><SUB><TT>1</TT></SUB><TT> &#X2026;</TT><I><FONT COLOR=maroon>term</FONT></I><SUB><TT><I>n</I></TT></SUB> in <I><FONT COLOR=maroon>ident</FONT></I> will
be used, the tactic <I><FONT COLOR=maroon>tactic</FONT></I> will be applied to the generated subgoals, the
main subgoal excluded.</LI><LI CLASS="li-enumerate"><TT>Print Rewrite HintDb </TT><I><FONT COLOR=maroon>ident</FONT></I><P>This command displays all rewrite hints contained in <I><FONT COLOR=maroon>ident</FONT></I>.</P></LI></OL><H3 CLASS="subsection"><A NAME="htoc264">8.13.5</A>  Hints and sections
<A NAME="Hint-and-Section"></A></H3><P>Hints provided by the <TT>Hint</TT> commands are erased when closing a
section. Conversely, all hints of a module <TT>A</TT> that are not
defined inside a section (and not defined with option <TT>Local</TT>) become
available when the module <TT>A</TT> is imported (using
e.g. <TT>Require Import A.</TT>).</P><H3 CLASS="subsection"><A NAME="htoc265">8.13.6</A>  Setting implicit automation tactics</H3><H4 CLASS="subsubsection"><TT>Proof with </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>.</TT></H4><P>
<A NAME="ProofWith"></A>
<A NAME="@default610"></A><A NAME="@command186"></A></P><P>This command may be used to start a proof. It defines a default
tactic to be used each time a tactic command <I><FONT COLOR=maroon>tactic</FONT></I><SUB>1</SUB> is ended by
&#X201C;<CODE>...</CODE>&#X201D;. In this case the tactic command typed by the user is
equivalent to <I><FONT COLOR=maroon>tactic</FONT></I><SUB>1</SUB>;<I><FONT COLOR=maroon>tactic</FONT></I>.</P><P><BR>
<B>See also: </B><TT>Proof.</TT> in section <A HREF="Reference-Manual009.html#BeginProof">7.1.5</A>.</P><H4 CLASS="subsubsection"><TT>Declare Implicit Tactic </TT><I><FONT COLOR=maroon>tactic</FONT></I><TT>.</TT></H4><P>
<A NAME="@default611"></A><A NAME="@command187"></A></P><P>This command declares a tactic to be used to solve implicit arguments
that <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not know how to solve by unification. It is used
every time the term argument of a tactic has one of its holes not
fully resolved.</P><P>Here is an example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Parameter quo : nat -</TT><TT>&gt;</TT><TT> forall n:nat, n</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> nat.</TT><BR>
<TT><I>quo is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Notation "x // y" := (quo x y _) (at level 40).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Declare Implicit Tactic assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall n m, m</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> { q:nat &amp; { r | q * m + r = n } }.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> {q : nat &amp;  {r : nat | q * m + r = n}}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  H : m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   {q : nat &amp;  {r : nat | q * m + r = n}}</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exists (n // m).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  H : m </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   {r : nat | n // m * m + r = n}</I></TT><BR>
</DIV><P>The tactic <TT>exists (n // m)</TT> did not fail. The hole was solved by
<TT>assumption</TT> so that it behaved as <TT>exists (quo n m H)</TT>.</P><H2 CLASS="section"><A NAME="toc60"></A><A NAME="htoc266">8.14</A>  Generation of induction principles with <TT>Scheme</TT>
<A NAME="Scheme"></A>
<A NAME="@default612"></A><A NAME="@command188"></A></H2><P>The <TT>Scheme</TT> command is a high-level tool for generating
automatically (possibly mutual) induction principles for given types
and sorts. Its syntax follows the schema:
</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP>
<TT>Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB>
</TD></TR>
</TABLE><P>
<I><FONT COLOR=maroon>ident</FONT></I>'<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><I>m</I></SUB> are different inductive type
identifiers belonging to the same package of mutual inductive
definitions. This command generates <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026; <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB>
to be mutually recursive definitions. Each term <I><FONT COLOR=maroon>ident</FONT></I><SUB><I>i</I></SUB> proves a
general principle of mutual induction for objects in type <I><FONT COLOR=maroon>term</FONT></I><SUB><I>i</I></SUB>.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Minimality for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Minimality for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB><P>Same as before but defines a non-dependent elimination principle more
natural in case of inductively defined relations. 
</P></LI></OL><P><BR>
<B>See also: </B><A HREF="Reference-Manual012.html#Scheme-examples">10.3</A></P><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual012.html#Scheme-examples">10.3</A></P><H2 CLASS="section"><A NAME="toc61"></A><A NAME="htoc267">8.15</A>  Generation of induction principles with <TT>Functional Scheme</TT>
<A NAME="FunScheme"></A>
<A NAME="@default613"></A><A NAME="@command189"></A></H2><P>The <TT>Functional Scheme</TT> command is a high-level experimental
tool for generating automatically induction principles
corresponding to (possibly mutually recursive) functions. Its
syntax follows the schema:
</P><TABLE border=0 cellspacing=0 cellpadding=0><TR><TD ALIGN=left NOWRAP>
<TT>Functional Scheme </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT>1</TT></SUB><TT> Sort </TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT>1</TT></SUB><TT><BR>
 with<BR>
  &#X2026;<BR>
 with </TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>m</I></TT></SUB><TT> := Induction for </TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><I>m</I></TT></SUB><TT> Sort
</TT><I><FONT COLOR=maroon>sort</FONT></I><SUB><TT><I>m</I></TT></SUB>
</TD></TR>
</TABLE><P> 
<I><FONT COLOR=maroon>ident</FONT></I>'<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><I>m</I></SUB> are different mutually defined function
names (they must be in the same order as when they were defined).
This command generates the induction principles
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>&#X2026;<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>m</I></SUB>, following the recursive structure and case
analyses of the functions <I><FONT COLOR=maroon>ident</FONT></I>'<SUB>1</SUB> &#X2026; <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><I>m</I></SUB>.</P><H5 CLASS="paragraph"><TT>Functional Scheme</TT></H5><P> 
There is a difference between obtaining an induction scheme by using
<TT>Functional Scheme</TT> on a function defined by <TT>Function</TT>
or not. Indeed <TT>Function</TT> generally produces smaller
principles, closer to the definition written by the user.</P><P><BR>
<B>See also: </B>Section <A HREF="Reference-Manual012.html#FunScheme-examples">10.4</A></P><H2 CLASS="section"><A NAME="toc62"></A><A NAME="htoc268">8.16</A>  Simple tactic macros
<A NAME="@default614"></A>
<A NAME="@default615"></A><A NAME="@command190"></A>
<A NAME="TacticDefinition"></A></H2><P>A simple example has more value than a long explanation: </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac Solve := simpl; intros; auto.</TT><BR>
<TT><I>Solve is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac ElimBoolRewrite b H1 H2 :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   elim b; [ intros; rewrite H1; eauto | intros; rewrite H2; eauto ].</TT><BR>
<TT><I>ElimBoolRewrite is defined</I></TT><BR>
</DIV><P>The tactics macros are synchronous with the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> section mechanism:
a tactic definition is deleted from the current environment
when you close the section (see also <A HREF="Reference-Manual004.html#Section">2.4</A>) 
where it was defined. If you want that a
tactic macro defined in a module is usable in the modules that
require it, you should put it outside of any section.</P><P>The chapter <A HREF="Reference-Manual011.html#TacticLanguage">9</A> gives examples of more complex
user-defined tactics.</P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note14" HREF="#text14">1</A></DT><DD CLASS="dd-thefootnotes">but it does not rename the hypothesis in the
proof-term...
</DD><DT CLASS="dt-thefootnotes"><A NAME="note15" HREF="#text15">2</A></DT><DD CLASS="dd-thefootnotes">Actually, only the second subgoal will be
generated since the other one can be automatically checked.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note16" HREF="#text16">3</A></DT><DD CLASS="dd-thefootnotes">This corresponds to the
cut rule of sequent calculus.
</DD><DT CLASS="dt-thefootnotes"><A NAME="note17" HREF="#text17">4</A></DT><DD CLASS="dd-thefootnotes">Recall: opaque
constants will not be expanded by &#X3B4; reductions
</DD><DT CLASS="dt-thefootnotes"><A NAME="note18" HREF="#text18">5</A></DT><DD CLASS="dd-thefootnotes">The behavior of this tactic has much changed compared to
the versions available in the previous distributions (V6). This may cause
significant changes in your theories to obtain the same result. As a drawback
of the reengineering of the code, this tactic has also been completely revised
to get a very compact and readable version.
</DD></DL>
<HR>
<A HREF="Reference-Manual009.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual011.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
