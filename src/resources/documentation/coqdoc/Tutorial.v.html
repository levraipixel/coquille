<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Tutorial.v</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -exec xxdate.exe Tutorial.v -->
<!--CUT DEF chapter 1 --><DIV CLASS="center">
<FONT SIZE=7>
</FONT><FONT SIZE=7><B>
The Coq Proof Assistant<BR>
<BR>

A Tutorial<BR>
</B></FONT><FONT SIZE=7>
</FONT>
<BR>
<BR>

<FONT SIZE=5><B>April 23, 2007<BR>
</B></FONT><FONT SIZE=5><B>Version </B></FONT><FONT SIZE=5><B>
</B></FONT><SUP><A NAME="text1" HREF="#note1"><FONT SIZE=5><B>1</B></FONT></A></SUP><FONT SIZE=5><B><BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>
<BR>

</B></FONT><FONT SIZE=5><B>Gérard Huet, Gilles Kahn and Christine Paulin-Mohring</B></FONT><FONT SIZE=5><B><BR>
</B></FONT><FONT SIZE=5><B>LogiCal Project</B></FONT><FONT SIZE=5><B><BR>
<BR>

</B></FONT></DIV><DIV CLASS="flushleft">
<FONT SIZE=4>©INRIA 1999-2004 (</FONT><FONT SIZE=4><SPAN STYLE="font-variant:small-caps">Coq</SPAN></FONT><FONT SIZE=4> versions 7.x)</FONT><BR>
<FONT SIZE=4>©INRIA 2004-2006 (</FONT><FONT SIZE=4><SPAN STYLE="font-variant:small-caps">Coq</SPAN></FONT><FONT SIZE=4> versions 8.x)</FONT><BR>

</DIV><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note1" HREF="#text1">1</A></DT><DD CLASS="dd-thefootnotes">This research was partly supported by IST working group &#X201C;Types&#X201D;
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Getting started-->
<H1 CLASS="chapter"><!--SEC ANCHOR -->Getting started</H1><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> is a Proof Assistant for a Logical Framework known as the Calculus
of Inductive Constructions. It allows the interactive construction of
formal proofs, and also the manipulation of functional programs 
consistently with their specifications. It runs as a computer program
on many architectures.
It is available with a variety of user interfaces. The present
document does not attempt to present a comprehensive view of all the
possibilities of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, but rather to present in the most elementary
manner a tutorial on the basic specification language, called Gallina,
in which formal axiomatisations may be developed, and on the main
proof tools. For more advanced information, the reader could refer to
the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> Reference Manual or the <I>Coq'Art</I>, a new book by Y.
Bertot and P. Castéran on practical uses of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system.</P><P>Coq can be used from a standard teletype-like shell window but
preferably through the graphical user interface
CoqIde<SUP><A NAME="text2" HREF="#note2">1</A></SUP>.</P><P>Instructions on installation procedures, as well as more comprehensive
documentation, may be found in the standard distribution of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>,
which may be obtained from <SPAN STYLE="font-variant:small-caps">Coq</SPAN> web site <TT>http://coq.inria.fr</TT>.</P><P>In the following, we assume that <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  is called from a standard
teletype-like shell window. All examples preceded by the prompting
sequence <CODE>Coq &lt; </CODE> represent user input, terminated by a
period. </P><P>The following lines usually show <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s answer as it appears on the
users screen. When used from a graphical user interface such as
CoqIde, the prompt is not displayed: user input is given in one window
and <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s answers are displayed in a different window.</P><P>The sequence of such examples is a valid <SPAN STYLE="font-variant:small-caps">Coq</SPAN> 
session, unless otherwise specified. This version of the tutorial has
been prepared on a PC workstation running Linux. The standard
invocation of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> delivers a message such as:</P><DIV CLASS="flushleft">
<PRE CLASS="verbatim">unix:~&gt; coqtop
Welcome to Coq 8.0 (Mar 2004)

Coq &lt; 
</PRE></DIV><P>The first line gives a banner stating the precise version of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> 
used. You should always return this banner when you report an
anomaly to our hot-line <CODE>coq-bugs@pauillac.inria.fr</CODE> or on our
bug-tracking system :<CODE>http</CODE>//coq.inria.fr/bin/coq-bugs:</P><!--BEGIN NOTES chapter-->
<HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note2" HREF="#text2">1</A></DT><DD CLASS="dd-thefootnotes">Alternative graphical interfaces exist: Proof General
and Pcoq.
</DD></DL>
<!--END NOTES-->
<!--TOC chapter Basic Predicate Calculus-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc1">Chapter 1</A>  Basic Predicate Calculus</H1><!--SEC END --><!--TOC section An overview of the specification language Gallina-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">1.1</A>  An overview of the specification language Gallina</H2><!--SEC END --><P>A formal development in Gallina consists in a sequence of <I><FONT COLOR=maroon>declarations</FONT></I>
and <I><FONT COLOR=maroon>definitions</FONT></I>. You may also send <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  <I><FONT COLOR=maroon>commands</FONT></I> which are
not really part of the formal development, but correspond to information
requests, or service routine invocations. For instance, the command:
</P><PRE CLASS="verbatim">Coq &lt; Quit.
</PRE><P>terminates the current session.</P><!--TOC subsection Declarations-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc3">1.1.1</A>  Declarations</H3><!--SEC END --><P>A declaration associates a <I><FONT COLOR=maroon>name</FONT></I> with 
a <I><FONT COLOR=maroon>specification</FONT></I>. 
A name corresponds roughly to an identifier in a programming
language, i.e. to a string of letters, digits, and a few ASCII symbols like
underscore (<CODE>_</CODE>) and prime (<CODE>'</CODE>), starting with a letter. 
We use case distinction, so that the names <CODE>A</CODE> and <CODE>a</CODE> are distinct.
Certain strings are reserved as key-words of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, and thus are forbidden 
as user identifiers.</P><P>A specification is a formal expression which classifies the notion which is
being declared. There are basically three kinds of specifications: 
<I><FONT COLOR=maroon>logical propositions</FONT></I>, <I><FONT COLOR=maroon>mathematical collections</FONT></I>, and
<I><FONT COLOR=maroon>abstract types</FONT></I>. They are classified by the three basic sorts
of the system, called respectively <CODE>Prop</CODE>, <CODE>Set</CODE>, and
<CODE>Type</CODE>, which are themselves atomic abstract types.</P><P>Every valid expression <I>e</I> in Gallina is associated with a specification,
itself a valid expression, called its <I><FONT COLOR=maroon>type</FONT></I> &#X3C4;(<I>E</I>). We write
<I>e</I>:&#X3C4;(<I>E</I>) for the judgment that <I>e</I> is of type <I>E</I>. 
You may request <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  to return to you the type of a valid expression by using
the command <CODE>Check</CODE>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check O.</TT><BR>
<TT><I>0</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
</DIV><P>Thus we know that the identifier <CODE>O</CODE> (the name `O', not to be
confused with the numeral `0' which is not a proper identifier!) is
known in the current context, and that its type is the specification 
<CODE>nat</CODE>. This specification is itself classified as a mathematical
collection, as we may readily check:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check nat.</TT><BR>
<TT><I>nat</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
</DIV><P>The specification <CODE>Set</CODE> is an abstract type, one of the basic
sorts of the Gallina language, whereas the notions <I>nat</I> and <I>O</I> are
notions which are defined in the arithmetic prelude,
automatically loaded when running the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system.</P><P>We start by introducing a so-called section name. The role of sections
is to structure the modelisation by limiting the scope of parameters,
hypotheses and definitions. It will also give a convenient way to
reset part of the development.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section Declaration.</TT><BR>
</DIV><P>

With what we already know, we may now enter in the system a declaration,
corresponding to the informal mathematics <I><FONT COLOR=maroon>let n be a natural
number</FONT></I>. </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Variable n : nat.</TT><BR>
<TT><I>n is assumed</I></TT><BR>
</DIV><P>If we want to translate a more precise statement, such as
<I><FONT COLOR=maroon>let n be a positive natural number</FONT></I>,
we have to add another declaration, which will declare explicitly the
hypothesis <CODE>Pos_n</CODE>, with specification the proper logical
proposition:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis Pos_n : (gt n 0).</TT><BR>
<TT><I>Pos_n is assumed</I></TT><BR>
</DIV><P>Indeed we may check that the relation <CODE>gt</CODE> is known with the right type
in the current context:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check gt.</TT><BR>
<TT><I>gt</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
</DIV><P>which tells us that <CODE>gt</CODE> is a function expecting two arguments of
type <CODE>nat</CODE> in order to build a logical proposition.
What happens here is similar to what we are used to in a functional
programming language: we may compose the (specification) type <CODE>nat</CODE>
with the (abstract) type <CODE>Prop</CODE> of logical propositions through the
arrow function constructor, in order to get a functional type
<CODE>nat-&gt;Prop</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check (nat -</TT><TT>&gt;</TT><TT> Prop).</TT><BR>
<TT><I>nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>     : Type</I></TT><BR>
</DIV><P>

which may be composed again with <CODE>nat</CODE> in order to obtain the
type <CODE>nat-&gt;nat-&gt;Prop</CODE> of binary relations over natural numbers.
Actually <CODE>nat-&gt;nat-&gt;Prop</CODE> is an abbreviation for 
<CODE>nat-&gt;(nat-&gt;Prop)</CODE>. </P><P>Functional notions may be composed in the usual way. An expression <I>f</I>
of type <I>A</I>&#X2192; <I>B</I> may be applied to an expression <I>e</I> of type <I>A</I> in order
to form the expression (<I>f</I> <I>e</I>) of type <I>B</I>. Here we get that
the expression <CODE>(gt n)</CODE> is well-formed of type <CODE>nat-&gt;Prop</CODE>,
and thus that the expression <CODE>(gt n O)</CODE>, which abbreviates
<CODE>((gt n) O)</CODE>, is a well-formed proposition.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check gt n O.</TT><BR>
<TT><I>n </I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>     : Prop</I></TT><BR>
</DIV><!--TOC subsection Definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc4">1.1.2</A>  Definitions</H3><!--SEC END --><P>The initial prelude contains a few arithmetic definitions:
<CODE>nat</CODE> is defined as a mathematical collection (type <CODE>Set</CODE>), constants
<CODE>O</CODE>, <CODE>S</CODE>, <CODE>plus</CODE>, are defined as objects of types
respectively <CODE>nat</CODE>, <CODE>nat-&gt;nat</CODE>, and <CODE>nat-&gt;nat-&gt;nat</CODE>.
You may introduce new definitions, which link a name to a well-typed value.
For instance, we may introduce the constant <CODE>one</CODE> as being defined
to be equal to the successor of zero:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition one := (S O).</TT><BR>
<TT><I>one is defined</I></TT><BR>
</DIV><P>

We may optionally indicate the required type:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition two : nat := S one.</TT><BR>
<TT><I>two is defined</I></TT><BR>
</DIV><P>Actually <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  allows several possible syntaxes:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition three : nat := S two.</TT><BR>
<TT><I>three is defined</I></TT><BR>
</DIV><P>Here is a way to define the doubling function, which expects an
argument <CODE>m</CODE> of type <CODE>nat</CODE> in order to build its result as
<CODE>(plus m m)</CODE>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition double (m:nat) := plus m m.</TT><BR>
<TT><I>double is defined</I></TT><BR>
</DIV><P>

This definition introduces the constant <TT>double</TT> defined as the
expression <TT>fun m:nat =&gt; plus m m</TT>.
The abstraction introduced by <TT>fun</TT> is explained as follows. The expression
<CODE>fun x:A =&gt; e</CODE> is well formed of type <CODE>A-&gt;B</CODE> in a context
whenever the expression <CODE>e</CODE> is well-formed of type <CODE>B</CODE> in 
the given context to which we add the declaration that <CODE>x</CODE>
is of type <CODE>A</CODE>. Here <CODE>x</CODE> is a bound, or dummy variable in
the expression <CODE>fun x:A =&gt; e</CODE>. For instance we could as well have
defined <CODE>double</CODE> as <CODE>fun n:nat =&gt; (plus n n)</CODE>.</P><P>Bound (local) variables and free (global) variables may be mixed.
For instance, we may define the function which adds the constant <CODE>n</CODE>
to its argument as

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition add_n (m:nat) := plus m n.</TT><BR>
<TT><I>add_n is defined</I></TT><BR>
</DIV><P>

However, note that here we may not rename the formal argument <I>m</I> into <I>n</I>
without capturing the free occurrence of <I>n</I>, and thus changing the meaning
of the defined notion.</P><P>Binding operations are well known for instance in logic, where they
are called quantifiers. Thus we may universally quantify a
proposition such as <I>m</I>&gt;0 in order to get a universal proposition
&#X2200; <I>m</I>· <I>m</I>&gt;0. Indeed this operator is available in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, with
the following syntax: <CODE>forall m:nat, gt m O</CODE>. Similarly to the
case of the functional abstraction binding, we are obliged to declare
explicitly the type of the quantified variable. We check:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check (forall m:nat, gt m 0).</TT><BR>
<TT><I>forall m : nat, m </I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>     : Prop</I></TT><BR>
</DIV><P>

We may clean-up the development by removing the contents of the
current section:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Reset Declaration.</TT><BR>
</DIV><!--TOC section Introduction to the proof engine: Minimal Logic-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc5">1.2</A>  Introduction to the proof engine: Minimal Logic</H2><!--SEC END --><P>In the following, we are going to consider various propositions, built
from atomic propositions <I>A</I>, <I>B</I>, <I>C</I>. This may be done easily, by
introducing these atoms as global variables declared of type <CODE>Prop</CODE>.
It is easy to declare several names with the same specification:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section Minimal_Logic.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables A B C : Prop.</TT><BR>
<TT><I>A is assumed</I></TT><BR>
<TT><I>B is assumed</I></TT><BR>
<TT><I>C is assumed</I></TT><BR>
</DIV><P>We shall consider simple implications, such as <I>A</I>&#X2192; <I>B</I>, read as 
&#X201C;<I>A</I> implies <I>B</I>&#X201D;. Remark that we overload the arrow symbol, which
has been used above as the functionality type constructor, and which
may be used as well as propositional connective:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check (A -</TT><TT>&gt;</TT><TT> B).</TT><BR>
<TT><I>A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>     : Prop</I></TT><BR>
</DIV><P>Let us now embark on a simple proof. We want to prove the easy tautology
((<I>A</I>&#X2192; (<I>B</I>&#X2192; <I>C</I>))&#X2192; (<I>A</I>&#X2192; <I>B</I>)&#X2192; (<I>A</I>&#X2192; <I>C</I>). 
We enter the proof engine by the command
<CODE>Goal</CODE>, followed by the conjecture we want to verify:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal (A -</TT><TT>&gt;</TT><TT> B -</TT><TT>&gt;</TT><TT> C) -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
</DIV><P>The system displays the current goal below a double line, local hypotheses
(there are none initially) being displayed above the line. We call 
the combination of local hypotheses with a goal a <I><FONT COLOR=maroon>judgment</FONT></I>.
We are now in an inner 
loop of the system, in proof mode. 
New commands are available in this
mode, such as <I><FONT COLOR=maroon>tactics</FONT></I>, which are proof combining primitives.
A tactic operates on the current goal by attempting to construct a proof
of the corresponding judgment, possibly from proofs of some
hypothetical judgments, which are then added to the current
list of conjectured judgments.
For instance, the <CODE>intro</CODE> tactic is applicable to any judgment
whose goal is an implication, by moving the proposition to the left
of the application to the list of local hypotheses:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
</DIV><P>Several introductions may be done in one step:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros H' HA.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H' : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
</DIV><P>We notice that <I>C</I>, the current goal, may be obtained from hypothesis
<CODE>H</CODE>, provided the truth of <I>A</I> and <I>B</I> are established.
The tactic <CODE>apply</CODE> implements this piece of reasoning:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H' : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B</I></TT><BR>
</DIV><P>We are now in the situation where we have two judgments as conjectures
that remain to be proved. Only the first is listed in full, for the
others the system displays only the corresponding subgoal, without its
local hypotheses list. Remark that <CODE>apply</CODE> has kept the local
hypotheses of its father judgment, which are still available for
the judgments it generated.</P><P>In order to solve the current goal, we just have to notice that it is
exactly available as hypothesis <I>HA</I>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> exact HA.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H' : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
</DIV><P>Now <I>H</I>' applies:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply H'.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H' : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
</DIV><P>And we may now conclude the proof as before, with <CODE>exact HA.</CODE>
Actually, we may not bother with the name <CODE>HA</CODE>, and just state that
the current goal is solvable from the current local assumptions:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>The proof is now finished. We may either discard it, by using the
command <CODE>Abort</CODE> which returns to the standard <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  toplevel loop
without further ado, or else save it as a lemma in the current context,
under name say <CODE>trivial_lemma</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Save trivial_lemma.</TT><BR>
<TT><I>intro H.</I></TT><BR>
<TT><I>intros H' HA.</I></TT><BR>
<TT><I>apply H.</I></TT><BR>
<TT><I> exact HA.</I></TT><BR>
<TT><I>apply H'.</I></TT><BR>
<TT><I>  assumption.</I></TT><BR>
<TT><I>trivial_lemma is defined</I></TT><BR>
</DIV><P>As a comment, the system shows the proof script listing all tactic
commands used in the proof. </P><P>Let us redo the same proof with a few variations. First of all we may name
the initial goal as a conjectured lemma:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma distr_impl : (A -</TT><TT>&gt;</TT><TT> B -</TT><TT>&gt;</TT><TT> C) -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
</DIV><P>Next, we may omit the names of local assumptions created by the introduction
tactics, they can be automatically created by the proof engine as new
non-clashing names.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H0 : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
</DIV><P>The <CODE>intros</CODE> tactic, with no arguments, effects as many individual
applications of <CODE>intro</CODE> as is legal.</P><P>Then, we may compose several tactics together in sequence, or in parallel,
through <I><FONT COLOR=maroon>tacticals</FONT></I>, that is tactic combinators. The main constructions
are the following:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<I>T</I><SUB>1</SUB> ; <I>T</I><SUB>2</SUB> (read <I>T</I><SUB>1</SUB> then <I>T</I><SUB>2</SUB>) applies tactic <I>T</I><SUB>1</SUB> to the current
goal, and then tactic <I>T</I><SUB>2</SUB> to all the subgoals generated by <I>T</I><SUB>1</SUB>.
</LI><LI CLASS="li-itemize"><I>T</I>; [<I>T</I><SUB>1</SUB> | <I>T</I><SUB>2</SUB> | ... | <I>T</I><SUB><I>n</I></SUB>] applies tactic <I>T</I> to the current
goal, and then tactic <I>T</I><SUB>1</SUB> to the first newly generated subgoal, 
..., <I>T</I><SUB><I>n</I></SUB> to the nth.
</LI></UL><P>We may thus complete the proof of <CODE>distr_impl</CODE> with one composite tactic:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply H; [ assumption | apply H0; assumption ].</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Let us now save lemma <CODE>distr_impl</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Save.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>apply H; [ assumption | apply H0; assumption ].</I></TT><BR>
<TT><I>distr_impl is defined</I></TT><BR>
</DIV><P>Here <CODE>Save</CODE> needs no argument, since we gave the name <CODE>distr_impl</CODE> 
in advance;
it is however possible to override the given name by giving a different 
argument to command <CODE>Save</CODE>.</P><P>Actually, such an easy combination of tactics <CODE>intro</CODE>, <CODE>apply</CODE>
and <CODE>assumption</CODE> may be found completely automatically by an automatic
tactic, called <CODE>auto</CODE>, without user guidance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma distr_imp : (A -</TT><TT>&gt;</TT><TT> B -</TT><TT>&gt;</TT><TT> C) -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>This time, we do not save the proof, we just discard it with the <CODE>Abort</CODE> 
command:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Abort.</TT><BR>
<TT><I>Current goal aborted</I></TT><BR>
</DIV><P>At any point during a proof, we may use <CODE>Abort</CODE> to exit the proof mode
and go back to Coq's main loop. We may also use <CODE>Restart</CODE> to restart
from scratch the proof of the same lemma. We may also use <CODE>Undo</CODE> to
backtrack one step, and more generally <CODE>Undo n</CODE> to
backtrack n steps.</P><P>We end this section by showing a useful command, <CODE>Inspect n.</CODE>,
which inspects the global <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  environment, showing the last <CODE>n</CODE> declared
notions: 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inspect 3.</TT><BR>
<TT><I>*** [C : Prop]</I></TT><BR>
<TT><I>trivial_lemma : (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>distr_impl : (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
</DIV><P>The declarations, whether global parameters or axioms, are shown preceded by 
<CODE>***</CODE>; definitions and lemmas are stated with their specification, but
their value (or proof-term) is omitted.</P><!--TOC section Propositional Calculus-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc6">1.3</A>  Propositional Calculus</H2><!--SEC END --><!--TOC subsection Conjunction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc7">1.3.1</A>  Conjunction</H3><!--SEC END --><P>We have seen how <CODE>intro</CODE> and <CODE>apply</CODE> tactics could be combined
in order to prove implicational statements. More generally, <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  favors a style
of reasoning, called <I><FONT COLOR=maroon>Natural Deduction</FONT></I>, which decomposes reasoning into 
so called <I><FONT COLOR=maroon>introduction rules</FONT></I>, which tell how to prove a goal whose main 
operator is a given propositional connective, and <I><FONT COLOR=maroon>elimination rules</FONT></I>,
which tell how to use an hypothesis whose main operator is the propositional 
connective. Let us show how to use these ideas for the propositional connectives
<CODE>/\</CODE> and <CODE>\/</CODE>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma and_commutative : A /</TT><TT>\</TT><TT> B -</TT><TT>&gt;</TT><TT> B /</TT><TT>\</TT><TT> A.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
</DIV><P>We make use of the conjunctive hypothesis <CODE>H</CODE> with the <CODE>elim</CODE> tactic,
which breaks it into its components:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> elim H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
</DIV><P>We now use the conjunction introduction tactic <CODE>split</CODE>, which splits the 
conjunctive goal into the two subgoals:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> split.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : A</I></TT><BR>
<TT><I>  H1 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> A</I></TT><BR>
</DIV><P>and the proof is now trivial. Indeed, the whole proof is obtainable as follows:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro H; elim H; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro H; elim H; auto.</I></TT><BR>
<TT><I>and_commutative is defined</I></TT><BR>
</DIV><P>The tactic <CODE>auto</CODE> succeeded here because it knows as a hint the 
conjunction introduction operator <CODE>conj</CODE>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check conj.</TT><BR>
<TT><I>conj</I></TT><BR>
<TT><I>     : forall A B : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
</DIV><P>Actually, the tactic <CODE>Split</CODE> is just an abbreviation for <CODE>apply conj.</CODE></P><P>What we have just seen is that the <CODE>auto</CODE> tactic is more powerful than
just a simple application of local hypotheses; it tries to apply as well 
lemmas which have been specified as hints. A 
<CODE>Hint Resolve</CODE> command registers a
lemma as a hint to be used from now on by the <CODE>auto</CODE> tactic, whose power 
may thus be incrementally augmented.</P><!--TOC subsection Disjunction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc8">1.3.2</A>  Disjunction</H3><!--SEC END --><P>In a similar fashion, let us consider disjunction:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma or_commutative : A </TT><TT>\</TT><TT>/ B -</TT><TT>&gt;</TT><TT> B </TT><TT>\</TT><TT>/ A.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro H; elim H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
</DIV><P>Let us prove the first subgoal in detail. We use <CODE>intro</CODE> in order to
be left to prove <CODE>B\/A</CODE> from <CODE>A</CODE>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro HA.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
</DIV><P>Here the hypothesis <CODE>H</CODE> is not needed anymore. We could choose to
actually erase it with the tactic <CODE>clear</CODE>; in this simple proof it
does not really matter, but in bigger proof developments it is useful to
clear away unnecessary hypotheses which may clutter your screen.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> clear H.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
</DIV><P>The disjunction connective has two introduction rules, since <CODE>P\/Q</CODE>
may be obtained from <CODE>P</CODE> or from <CODE>Q</CODE>; the two corresponding
proof constructors are called respectively <CODE>or_introl</CODE> and
<CODE>or_intror</CODE>; they are applied to the current goal by tactics
<CODE>left</CODE> and <CODE>right</CODE> respectively. For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> right.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  HA : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
</DIV><P>

The tactic <CODE>trivial</CODE> works like <CODE>auto</CODE> with the hints
database, but it only tries those tactics that can solve the goal in one
step. </P><P>As before, all these tedious elementary steps may be performed automatically,
as shown for the second symmetric case:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>However, <CODE>auto</CODE> alone does not succeed in proving the full lemma, because
it does not try any elimination step.
It is a bit disappointing that <CODE>auto</CODE> is not able to prove automatically 
such a simple tautology. The reason is that we want to keep
<CODE>auto</CODE> efficient, so that it is always effective to use. </P><!--TOC subsection Tauto-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc9">1.3.3</A>  Tauto</H3><!--SEC END --><P>A complete tactic for propositional
tautologies is indeed available in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  as the <CODE>tauto</CODE> tactic. 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> tauto.</I></TT><BR>
<TT><I>or_commutative is defined</I></TT><BR>
</DIV><P>It is possible to inspect the actual proof tree constructed by <CODE>tauto</CODE>,
using a standard command of the system, which prints the value of any notion 
currently defined in the context:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Print or_commutative.</TT><BR>
<TT><I>or_commutative = </I></TT><BR>
<TT><I>fun H : A </I></TT><TT><I>\</I></TT><TT><I>/ B =</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>or_ind (fun H0 : A =</I></TT><TT><I>&gt;</I></TT><TT><I> or_intror B H0) (fun H0 : B =</I></TT><TT><I>&gt;</I></TT><TT><I> or_introl A H0) H</I></TT><BR>
<TT><I>     : A </I></TT><TT><I>\</I></TT><TT><I>/ B -</I></TT><TT><I>&gt;</I></TT><TT><I> B </I></TT><TT><I>\</I></TT><TT><I>/ A</I></TT><BR>
</DIV><P>It is not easy to understand the notation for proof terms without a few
explanations. The <TT>fun</TT> prefix, such as <CODE>fun H:A\/B =&gt;</CODE>, 
corresponds
to <CODE>intro H</CODE>, whereas a subterm such as 
<CODE>(or_intror</CODE> <CODE>B H0)</CODE>
corresponds to the sequence <CODE>apply or_intror; exact H0</CODE>. 
The generic combinator <CODE>or_intror</CODE> needs to be instantiated by
the two properties <CODE>B</CODE> and <CODE>A</CODE>. Because <CODE>A</CODE> can be
deduced from the type of <CODE>H0</CODE>, only <CODE>B</CODE> is printed.
The two instantiations are effected automatically by the tactic
<CODE>apply</CODE> when pattern-matching a goal. The specialist will of course
recognize our proof term as a &#X3BB;-term, used as notation for the
natural deduction proof term through the Curry-Howard isomorphism. The
naive user of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  may safely ignore these formal details.</P><P>Let us exercise the <CODE>tauto</CODE> tactic on a more complex example:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma distr_and : A -</TT><TT>&gt;</TT><TT> B /</TT><TT>\</TT><TT> C -</TT><TT>&gt;</TT><TT> (A -</TT><TT>&gt;</TT><TT> B) /</TT><TT>\</TT><TT> (A -</TT><TT>&gt;</TT><TT> C).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) /</I></TT><TT><I>\</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> tauto.</I></TT><BR>
<TT><I>distr_and is defined</I></TT><BR>
</DIV><!--TOC subsection Classical reasoning-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc10">1.3.4</A>  Classical reasoning</H3><!--SEC END --><P><CODE>tauto</CODE> always comes back with an answer. Here is an example where it 
fails:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Peirce : ((A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A) -</TT><TT>&gt;</TT><TT> A.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   ((A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A) -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> try tauto.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   ((A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A) -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
</DIV><P>Note the use of the <CODE>Try</CODE> tactical, which does nothing if its tactic
argument fails.</P><P>This may come as a surprise to someone familiar with classical reasoning. 
Peirce's lemma is true in Boolean logic, i.e. it evaluates to <CODE>true</CODE> for 
every truth-assignment to <CODE>A</CODE> and <CODE>B</CODE>. Indeed the double negation
of Peirce's law may be proved in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  using <CODE>tauto</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Abort.</TT><BR>
<TT><I>Current goal aborted</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma NNPeirce : </TT><TT>~</TT><TT> </TT><TT>~</TT><TT> (((A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A) -</TT><TT>&gt;</TT><TT> A).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   </I></TT><TT><I>~</I></TT><TT><I> </I></TT><TT><I>~</I></TT><TT><I> (((A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A) -</I></TT><TT><I>&gt;</I></TT><TT><I> A)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> tauto.</I></TT><BR>
<TT><I>NNPeirce is defined</I></TT><BR>
</DIV><P>In classical logic, the double negation of a proposition is equivalent to this 
proposition, but in the constructive logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  this is not so. If you 
want to use classical logic in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, you have to import explicitly the
<CODE>Classical</CODE> module, which will declare the axiom <CODE>classic</CODE>
of excluded middle, and classical tautologies such as de Morgan's laws.
The <CODE>Require</CODE> command is used to import a module from <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s library:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Classical.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check NNPP.</TT><BR>
<TT><I>NNPP</I></TT><BR>
<TT><I>     : forall p : Prop, </I></TT><TT><I>~</I></TT><TT><I> </I></TT><TT><I>~</I></TT><TT><I> p -</I></TT><TT><I>&gt;</I></TT><TT><I> p</I></TT><BR>
</DIV><P>and it is now easy (although admittedly not the most direct way) to prove
a classical law such as Peirce's:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Peirce : ((A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A) -</TT><TT>&gt;</TT><TT> A.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   ((A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A) -</I></TT><TT><I>&gt;</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply NNPP; tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>apply NNPP;  tauto.</I></TT><BR>
<TT><I>Peirce is defined</I></TT><BR>
</DIV><P>Here is one more example of propositional reasoning, in the shape of
a Scottish puzzle. A private club has the following rules:
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Every non-scottish member wears red socks
</LI><LI CLASS="li-enumerate">Every member wears a kilt or doesn't wear red socks
</LI><LI CLASS="li-enumerate">The married members don't go out on Sunday
</LI><LI CLASS="li-enumerate">A member goes out on Sunday if and only if he is Scottish
</LI><LI CLASS="li-enumerate">Every member who wears a kilt is Scottish and married
</LI><LI CLASS="li-enumerate">Every scottish member wears a kilt
</LI></OL><P>
Now, we show that these rules are so strict that no one can be accepted.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section club.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables Scottish RedSocks WearKilt Married GoOutSunday : Prop.</TT><BR>
<TT><I>Scottish is assumed</I></TT><BR>
<TT><I>RedSocks is assumed</I></TT><BR>
<TT><I>WearKilt is assumed</I></TT><BR>
<TT><I>Married is assumed</I></TT><BR>
<TT><I>GoOutSunday is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule1 : </TT><TT>~</TT><TT> Scottish -</TT><TT>&gt;</TT><TT> RedSocks.</TT><BR>
<TT><I>rule1 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule2 : WearKilt </TT><TT>\</TT><TT>/ </TT><TT>~</TT><TT> RedSocks.</TT><BR>
<TT><I>rule2 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule3 : Married -</TT><TT>&gt;</TT><TT> </TT><TT>~</TT><TT> GoOutSunday.</TT><BR>
<TT><I>rule3 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule4 : GoOutSunday </TT><TT>&lt;</TT><TT>-</TT><TT>&gt;</TT><TT> Scottish.</TT><BR>
<TT><I>rule4 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule5 : WearKilt -</TT><TT>&gt;</TT><TT> Scottish /</TT><TT>\</TT><TT> Married.</TT><BR>
<TT><I>rule5 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis rule6 : Scottish -</TT><TT>&gt;</TT><TT> WearKilt.</TT><BR>
<TT><I>rule6 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma NoMember : False.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  Scottish : Prop</I></TT><BR>
<TT><I>  RedSocks : Prop</I></TT><BR>
<TT><I>  WearKilt : Prop</I></TT><BR>
<TT><I>  Married : Prop</I></TT><BR>
<TT><I>  GoOutSunday : Prop</I></TT><BR>
<TT><I>  rule1 : </I></TT><TT><I>~</I></TT><TT><I> Scottish -</I></TT><TT><I>&gt;</I></TT><TT><I> RedSocks</I></TT><BR>
<TT><I>  rule2 : WearKilt </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> RedSocks</I></TT><BR>
<TT><I>  rule3 : Married -</I></TT><TT><I>&gt;</I></TT><TT><I> </I></TT><TT><I>~</I></TT><TT><I> GoOutSunday</I></TT><BR>
<TT><I>  rule4 : GoOutSunday </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> Scottish</I></TT><BR>
<TT><I>  rule5 : WearKilt -</I></TT><TT><I>&gt;</I></TT><TT><I> Scottish /</I></TT><TT><I>\</I></TT><TT><I> Married</I></TT><BR>
<TT><I>  rule6 : Scottish -</I></TT><TT><I>&gt;</I></TT><TT><I> WearKilt</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   False</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> tauto.</I></TT><BR>
<TT><I>NoMember is defined</I></TT><BR>
</DIV><P>

At that point <CODE>NoMember</CODE> is a proof of the absurdity depending on
hypotheses.
We may end the section, in that case, the variables and hypotheses
will be discharged, and the type of <CODE>NoMember</CODE> will be
generalised.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End club.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check NoMember.</TT><BR>
<TT><I>NoMember</I></TT><BR>
<TT><I>     : forall Scottish RedSocks WearKilt Married GoOutSunday : Prop,</I></TT><BR>
<TT><I>       (</I></TT><TT><I>~</I></TT><TT><I> Scottish -</I></TT><TT><I>&gt;</I></TT><TT><I> RedSocks) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       WearKilt </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> RedSocks -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (Married -</I></TT><TT><I>&gt;</I></TT><TT><I> </I></TT><TT><I>~</I></TT><TT><I> GoOutSunday) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (GoOutSunday </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> Scottish) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (WearKilt -</I></TT><TT><I>&gt;</I></TT><TT><I> Scottish /</I></TT><TT><I>\</I></TT><TT><I> Married) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (Scottish -</I></TT><TT><I>&gt;</I></TT><TT><I> WearKilt) -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
</DIV><!--TOC section Predicate Calculus-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc11">1.4</A>  Predicate Calculus</H2><!--SEC END --><P>Let us now move into predicate logic, and first of all into first-order
predicate calculus. The essence of predicate calculus is that to try to prove 
theorems in the most abstract possible way, without using the definitions of 
the mathematical notions, but by formal manipulations of uninterpreted 
function and predicate symbols. </P><!--TOC subsection Sections and signatures-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc12">1.4.1</A>  Sections and signatures</H3><!--SEC END --><P>Usually one works in some domain of discourse, over which range the individual 
variables and function symbols. In <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  we speak in a language with a rich 
variety of types, so me may mix several domains of discourse, in our 
multi-sorted language. For the moment, we just do a few exercises, over a 
domain of discourse <CODE>D</CODE> axiomatised as a <CODE>Set</CODE>, and we consider two 
predicate symbols <CODE>P</CODE> and <CODE>R</CODE> over <CODE>D</CODE>, of arities 
respectively 1 and 2. Such abstract entities may be entered in the context
as global variables. But we must be careful about the pollution of our
global environment by such declarations. For instance, we have already 
polluted our <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  session by declaring the variables
<CODE>n</CODE>, <CODE>Pos_n</CODE>, <CODE>A</CODE>, <CODE>B</CODE>, and <CODE>C</CODE>. If we want to revert to the clean state of
our initial session, we may use the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  <CODE>Reset</CODE> command, which returns
to the state just prior the given global notion as we did before to
remove a section, or we may return to the initial state using :

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Reset Initial.</TT><BR>
</DIV><P>We shall now declare a new <CODE>Section</CODE>, which will allow us to define
notions local to a well-delimited scope. We start by assuming a domain of
discourse <CODE>D</CODE>, and a binary relation <CODE>R</CODE> over <CODE>D</CODE>: 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section Predicate_calculus.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable D : Set.</TT><BR>
<TT><I>D is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable R : D -</TT><TT>&gt;</TT><TT> D -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<TT><I>R is assumed</I></TT><BR>
</DIV><P>As a simple example of predicate calculus reasoning, let us assume
that relation <CODE>R</CODE> is symmetric and transitive, and let us show that
<CODE>R</CODE> is reflexive in any point <CODE>x</CODE> which has an <CODE>R</CODE> successor.
Since we do not want to make the assumptions about <CODE>R</CODE> global axioms of 
a theory, but rather local hypotheses to a theorem, we open a specific
section to this effect.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section R_sym_trans.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis R_symmetric : forall x y:D, R x y -</TT><TT>&gt;</TT><TT> R y x.</TT><BR>
<TT><I>R_symmetric is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis R_transitive : forall x y z:D, R x y -</TT><TT>&gt;</TT><TT> R y z -</TT><TT>&gt;</TT><TT> R x z.</TT><BR>
<TT><I>R_transitive is assumed</I></TT><BR>
</DIV><P>Remark the syntax <CODE>forall x:D,</CODE> which stands for universal quantification
&#X2200; <I>x</I> : <I>D</I>.</P><!--TOC subsection Existential quantification-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc13">1.4.2</A>  Existential quantification</H3><!--SEC END --><P>We now state our lemma, and enter proof mode.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma refl_if : forall x:D, (exists y, R x y) -</TT><TT>&gt;</TT><TT> R x x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x : D, (exists y : D, R x y) -</I></TT><TT><I>&gt;</I></TT><TT><I> R x x</I></TT><BR>
</DIV><P>Remark that the hypotheses which are local to the currently opened sections
are listed as local hypotheses to the current goals.
The rationale is that these hypotheses are going to be discharged, as we
shall see, when we shall close the corresponding sections.</P><P>Note the functional syntax for existential quantification. The existential
quantifier is built from the operator <CODE>ex</CODE>, which expects a 
predicate as argument:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check ex.</TT><BR>
<TT><I>ex</I></TT><BR>
<TT><I>     : forall A : Type, (A -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop) -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
</DIV><P>

and the notation <CODE>(exists x:D, P x)</CODE> is just concrete syntax for 
<CODE>(ex D (fun x:D =&gt; P x))</CODE>. 
Existential quantification is handled in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  in a similar
fashion to the connectives <CODE>/\</CODE> and <CODE>\/</CODE> : it is introduced by
the proof combinator <CODE>ex_intro</CODE>, which is invoked by the specific 
tactic <CODE>Exists</CODE>, and its elimination provides a witness <CODE>a:D</CODE> to
<CODE>P</CODE>, together with an assumption <CODE>h:(P a)</CODE> that indeed <CODE>a</CODE>
verifies <CODE>P</CODE>. Let us see how this works on this simple example.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros x x_Rlinked.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  x : D</I></TT><BR>
<TT><I>  x_Rlinked : exists y : D, R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   R x x</I></TT><BR>
</DIV><P>Remark that <CODE>intros</CODE> treats universal quantification in the same way
as the premises of implications. Renaming of bound variables occurs
when it is needed; for instance, had we started with <CODE>intro y</CODE>,
we would have obtained the goal:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro y.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  y : D</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (exists y0 : D, R y y0) -</I></TT><TT><I>&gt;</I></TT><TT><I> R y y</I></TT><BR>
</DIV><P>Let us now use the existential hypothesis <CODE>x_Rlinked</CODE> to 
exhibit an R-successor y of x. This is done in two steps, first with
<CODE>elim</CODE>, then with <CODE>intros</CODE></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> elim x_Rlinked.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  x : D</I></TT><BR>
<TT><I>  x_Rlinked : exists y : D, R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x0 : D, R x x0 -</I></TT><TT><I>&gt;</I></TT><TT><I> R x x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros y Rxy.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  x : D</I></TT><BR>
<TT><I>  x_Rlinked : exists y : D, R x y</I></TT><BR>
<TT><I>  y : D</I></TT><BR>
<TT><I>  Rxy : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   R x x</I></TT><BR>
</DIV><P>Now we want to use <CODE>R_transitive</CODE>. The <CODE>apply</CODE> tactic will know
how to match <CODE>x</CODE> with <CODE>x</CODE>, and <CODE>z</CODE> with <CODE>x</CODE>, but needs
help on how to instantiate <CODE>y</CODE>, which appear in the hypotheses of
<CODE>R_transitive</CODE>, but not in its conclusion. We give the proper hint
to <CODE>apply</CODE> in a <CODE>with</CODE> clause, as follows:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply R_transitive with y.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  x : D</I></TT><BR>
<TT><I>  x_Rlinked : exists y : D, R x y</I></TT><BR>
<TT><I>  y : D</I></TT><BR>
<TT><I>  Rxy : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   R x y</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> R y x</I></TT><BR>
</DIV><P>The rest of the proof is routine:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R_symmetric : forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x</I></TT><BR>
<TT><I>  R_transitive : forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z</I></TT><BR>
<TT><I>  x : D</I></TT><BR>
<TT><I>  x_Rlinked : exists y : D, R x y</I></TT><BR>
<TT><I>  y : D</I></TT><BR>
<TT><I>  Rxy : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   R y x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply R_symmetric; assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P>Let us now close the current section.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End R_sym_trans.</TT><BR>
</DIV><P>Here <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s printout is a warning that all local hypotheses have been 
discharged in the statement of <CODE>refl_if</CODE>, which now becomes a general
theorem in the first-order language declared in section 
<CODE>Predicate_calculus</CODE>. In this particular example, the use of section
<CODE>R_sym_trans</CODE> has not been really significant, since we could have
instead stated theorem <CODE>refl_if</CODE> in its general form, and done 
basically the same proof, obtaining <CODE>R_symmetric</CODE> and
<CODE>R_transitive</CODE> as local hypotheses by initial <CODE>intros</CODE> rather
than as global hypotheses in the context. But if we had pursued the
theory by proving more theorems about relation <CODE>R</CODE>,
we would have obtained all general statements at the closing of the section,
with minimal dependencies on the hypotheses of symmetry and transitivity.</P><!--TOC subsection Paradoxes of classical predicate calculus-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc14">1.4.3</A>  Paradoxes of classical predicate calculus</H3><!--SEC END --><P>Let us illustrate this feature by pursuing our <CODE>Predicate_calculus</CODE>
section with an enrichment of our language: we declare a unary predicate
<CODE>P</CODE> and a constant <CODE>d</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P :  D -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<TT><I>P is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable d : D.</TT><BR>
<TT><I>d is assumed</I></TT><BR>
</DIV><P>We shall now prove a well-known fact from first-order logic: a universal 
predicate is non-empty, or in other terms existential quantification 
follows from universal quantification.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma weird : (forall x:D, P x) -</TT><TT>&gt;</TT><TT>  exists a, P a.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (forall x : D, P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists a : D, P a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  intro UnivP.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  UnivP : forall x : D, P x</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   exists a : D, P a</I></TT><BR>
</DIV><P>First of all, notice the pair of parentheses around
<CODE>forall x:D, P x</CODE> in
the statement of lemma <CODE>weird</CODE>.
If we had omitted them, <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s parser would have interpreted the
statement as a truly trivial fact, since we would 
postulate an <CODE>x</CODE> verifying <CODE>(P x)</CODE>. Here the situation is indeed
more problematic. If we have some element in <CODE>Set</CODE> <CODE>D</CODE>, we may
apply <CODE>UnivP</CODE> to it and conclude, otherwise we are stuck. Indeed
such an element <CODE>d</CODE> exists, but this is just by virtue of our
new signature. This points out a subtle difference between standard
predicate calculus and <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. In standard first-order logic,
the equivalent of lemma <CODE>weird</CODE> always holds, 
because such a rule is wired in the inference rules for quantifiers, the
semantic justification being that the interpretation domain is assumed to
be non-empty. Whereas in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, where types are not assumed to be 
systematically inhabited, lemma <CODE>weird</CODE> only holds in signatures
which allow the explicit construction of an element in the domain of
the predicate. </P><P>Let us conclude the proof, in order to show the use of the <CODE>Exists</CODE>
tactic:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> exists d; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro UnivP.</I></TT><BR>
<TT><I>exists d; trivial.</I></TT><BR>
<TT><I>weird is defined</I></TT><BR>
</DIV><P>Another fact which illustrates the sometimes disconcerting rules of
classical 
predicate calculus is Smullyan's drinkers' paradox: &#X201C;In any non-empty
bar, there is a person such that if she drinks, then everyone drinks&#X201D;.
We modelize the bar by Set <CODE>D</CODE>, drinking by predicate <CODE>P</CODE>.
We shall need classical reasoning. Instead of loading the <CODE>Classical</CODE>
module as we did above, we just state the law of excluded middle as a
local hypothesis schema at this point:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis EM : forall A:Prop, A </TT><TT>\</TT><TT>/ </TT><TT>~</TT><TT> A.</TT><BR>
<TT><I>EM is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma drinker :  exists x:D, P x -</TT><TT>&gt;</TT><TT> forall x:D, P x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>

The proof goes by cases on whether or not
there is someone who does not drink. Such reasoning by cases proceeds
by invoking the excluded middle principle, via <CODE>elim</CODE> of the
proper instance of <CODE>EM</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> elim (EM (exists x, </TT><TT>~</TT><TT> P x)).</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>We first look at the first case. Let Tom be the non-drinker:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro Non_drinker; elim Non_drinker; intros Tom Tom_does_not_drink.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  Non_drinker : exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x</I></TT><BR>
<TT><I>  Tom : D</I></TT><BR>
<TT><I>  Tom_does_not_drink : </I></TT><TT><I>~</I></TT><TT><I> P Tom</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>We conclude in that case by considering Tom, since his drinking leads to
a contradiction:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> exists Tom; intro Tom_drinks.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  Non_drinker : exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x</I></TT><BR>
<TT><I>  Tom : D</I></TT><BR>
<TT><I>  Tom_does_not_drink : </I></TT><TT><I>~</I></TT><TT><I> P Tom</I></TT><BR>
<TT><I>  Tom_drinks : P Tom</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x : D, P x</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>There are several ways in which we may eliminate a contradictory case;
a simple one is to use the <CODE>absurd</CODE> tactic as follows:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> absurd (P Tom); trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>We now proceed with the second case, in which actually any person will do;
such a John Doe is given by the non-emptiness witness <CODE>d</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro No_nondrinker; exists d; intro d_drinks.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  No_nondrinker : </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x)</I></TT><BR>
<TT><I>  d_drinks : P d</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x : D, P x</I></TT><BR>
</DIV><P>Now we consider any Dick in the bar, and reason by cases according to its
drinking or not:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro Dick; elim (EM (P Dick)); trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  No_nondrinker : </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x)</I></TT><BR>
<TT><I>  d_drinks : P d</I></TT><BR>
<TT><I>  Dick : D</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   </I></TT><TT><I>~</I></TT><TT><I> P Dick -</I></TT><TT><I>&gt;</I></TT><TT><I> P Dick</I></TT><BR>
</DIV><P>The only non-trivial case is again treated by contradiction:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro Dick_does_not_drink; absurd (exists x, </TT><TT>~</TT><TT> P x); trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  D : Set</I></TT><BR>
<TT><I>  R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  d : D</I></TT><BR>
<TT><I>  EM : forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  No_nondrinker : </I></TT><TT><I>~</I></TT><TT><I> (exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x)</I></TT><BR>
<TT><I>  d_drinks : P d</I></TT><BR>
<TT><I>  Dick : D</I></TT><BR>
<TT><I>  Dick_does_not_drink : </I></TT><TT><I>~</I></TT><TT><I> P Dick</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   exists x : D, </I></TT><TT><I>~</I></TT><TT><I> P x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exists Dick; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>elim (EM (exists x : _, </I></TT><TT><I>~</I></TT><TT><I> P x)).</I></TT><BR>
<TT><I> intro Non_drinker; elim Non_drinker; intros Tom Tom_does_not_drink.</I></TT><BR>
<TT><I>   exists Tom; intro Tom_drinks.</I></TT><BR>
<TT><I>    absurd (P Tom); trivial.</I></TT><BR>
<TT><I>intro No_nondrinker; exists d; intro d_drinks.</I></TT><BR>
<TT><I>  intro Dick; elim (EM (P Dick)); trivial.</I></TT><BR>
<TT><I>  intro Dick_does_not_drink;  absurd (exists x : _, </I></TT><TT><I>~</I></TT><TT><I> P x); trivial.</I></TT><BR>
<TT><I>  exists Dick; trivial.</I></TT><BR>
<TT><I>drinker is defined</I></TT><BR>
</DIV><P>Now, let us close the main section and look at the complete statements
we proved:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End Predicate_calculus.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check refl_if.</TT><BR>
<TT><I>refl_if</I></TT><BR>
<TT><I>     : forall (D : Set) (R : D -</I></TT><TT><I>&gt;</I></TT><TT><I> D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>       (forall x y : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y x) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (forall x y z : D, R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> R y z -</I></TT><TT><I>&gt;</I></TT><TT><I> R x z) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       forall x : D, (exists y : D, R x y) -</I></TT><TT><I>&gt;</I></TT><TT><I> R x x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check weird.</TT><BR>
<TT><I>weird</I></TT><BR>
<TT><I>     : forall (D : Set) (P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>       D -</I></TT><TT><I>&gt;</I></TT><TT><I> (forall x : D, P x) -</I></TT><TT><I>&gt;</I></TT><TT><I> exists a : D, P a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check drinker.</TT><BR>
<TT><I>drinker</I></TT><BR>
<TT><I>     : forall (D : Set) (P : D -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>       D -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (forall A : Prop, A </I></TT><TT><I>\</I></TT><TT><I>/ </I></TT><TT><I>~</I></TT><TT><I> A) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       exists x : D, P x -</I></TT><TT><I>&gt;</I></TT><TT><I> forall x0 : D, P x0</I></TT><BR>
</DIV><P>Remark how the three theorems are completely generic in the most general 
fashion;
the domain <CODE>D</CODE> is discharged in all of them, <CODE>R</CODE> is discharged in
<CODE>refl_if</CODE> only, <CODE>P</CODE> is discharged only in <CODE>weird</CODE> and
<CODE>drinker</CODE>, along with the hypothesis that <CODE>D</CODE> is inhabited. 
Finally, the excluded middle hypothesis is discharged only in 
<CODE>drinker</CODE>.</P><P>Note that the name <CODE>d</CODE> has vanished as well from
the statements of <CODE>weird</CODE> and <CODE>drinker</CODE>, 
since <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s pretty-printer replaces
systematically a quantification such as <CODE>forall d:D, E</CODE>, where <CODE>d</CODE>
does not occur in <CODE>E</CODE>, by the functional notation <CODE>D-&gt;E</CODE>. 
Similarly the name <CODE>EM</CODE> does not appear in <CODE>drinker</CODE>. </P><P>Actually, universal quantification, implication, 
as well as function formation, are
all special cases of one general construct of type theory called
<I><FONT COLOR=maroon>dependent product</FONT></I>. This is the mathematical construction 
corresponding to an indexed family of functions. A function 
<I>f</I>&#X2208; &#X3A0; <I>x</I>:<I>D</I>· <I>Cx</I> maps an element <I>x</I> of its domain <I>D</I> to its
(indexed) codomain <I>Cx</I>. Thus a proof of &#X2200; <I>x</I>:<I>D</I>· <I>Px</I> is
a function mapping an element <I>x</I> of <I>D</I> to a proof of proposition <I>Px</I>.</P><!--TOC subsection Flexible use of local assumptions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc15">1.4.4</A>  Flexible use of local assumptions</H3><!--SEC END --><P>Very often during the course of a proof we want to retrieve a local
assumption and reintroduce it explicitly in the goal, for instance
in order to get a more general induction hypothesis. The tactic
<CODE>generalize</CODE> is what is needed here:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section Predicate_Calculus.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables P Q : nat -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<TT><I>P is assumed</I></TT><BR>
<TT><I>Q is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable R :  nat -</TT><TT>&gt;</TT><TT> nat -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<TT><I>R is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma PQR :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall x y:nat, (R x x -</TT><TT>&gt;</TT><TT> P x -</TT><TT>&gt;</TT><TT> Q x) -</TT><TT>&gt;</TT><TT> P x -</TT><TT>&gt;</TT><TT> R x y -</TT><TT>&gt;</TT><TT> Q x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y : nat, (R x x -</I></TT><TT><I>&gt;</I></TT><TT><I> P x -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x) -</I></TT><TT><I>&gt;</I></TT><TT><I> P x -</I></TT><TT><I>&gt;</I></TT><TT><I> R x y -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : R x x -</I></TT><TT><I>&gt;</I></TT><TT><I> P x -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x</I></TT><BR>
<TT><I>  H0 : P x</I></TT><BR>
<TT><I>  H1 : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   Q x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> generalize H0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : R x x -</I></TT><TT><I>&gt;</I></TT><TT><I> P x -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x</I></TT><BR>
<TT><I>  H0 : P x</I></TT><BR>
<TT><I>  H1 : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   P x -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x</I></TT><BR>
</DIV><P>Sometimes it may be convenient to use a lemma, although we do not have
a direct way to appeal to such an already proven fact. The tactic <CODE>cut</CODE>
permits to use the lemma at this point, keeping the corresponding proof
obligation as a new subgoal:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> cut (R x x); trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : R x x -</I></TT><TT><I>&gt;</I></TT><TT><I> P x -</I></TT><TT><I>&gt;</I></TT><TT><I> Q x</I></TT><BR>
<TT><I>  H0 : P x</I></TT><BR>
<TT><I>  H1 : R x y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   R x x</I></TT><BR>
</DIV><P>

We clean the goal by doing an <CODE>Abort</CODE> command.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Abort.</TT><BR>
</DIV><!--TOC subsection Equality-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc16">1.4.5</A>  Equality</H3><!--SEC END --><P>The basic equality provided in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  is Leibniz equality, noted infix like
<CODE>x=y</CODE>, when <CODE>x</CODE> and <CODE>y</CODE> are two expressions of
type the same Set. The replacement of <CODE>x</CODE> by <CODE>y</CODE> in any
term is effected by a variety of tactics, such as <CODE>rewrite</CODE>
and <CODE>replace</CODE>. </P><P>Let us give a few examples of equality replacement. Let us assume that
some arithmetic function <CODE>f</CODE> is null in zero:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Variable f : nat -</TT><TT>&gt;</TT><TT> nat.</TT><BR>
<TT><I>f is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis foo : f 0 = 0.</TT><BR>
<TT><I>foo is assumed</I></TT><BR>
</DIV><P>We want to prove the following conditional equality:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma L1 : forall k:nat, k = 0 -</TT><TT>&gt;</TT><TT> f k = k.</TT><BR>
</DIV><P>As usual, we first get rid of local assumptions with <CODE>intro</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros k E.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  k : nat</I></TT><BR>
<TT><I>  E : k = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f k = k</I></TT><BR>
</DIV><P>Let us now use equation <CODE>E</CODE> as a left-to-right rewriting:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> rewrite E.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  k : nat</I></TT><BR>
<TT><I>  E : k = 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f 0 = 0</I></TT><BR>
</DIV><P>

This replaced both occurrences of <CODE>k</CODE> by <CODE>O</CODE>. </P><P>Now <CODE>apply foo</CODE> will finish the proof:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply foo.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros k E.</I></TT><BR>
<TT><I>rewrite E in |- *.</I></TT><BR>
<TT><I>apply foo.</I></TT><BR>
<TT><I>L1 is defined</I></TT><BR>
</DIV><P>When one wants to rewrite an equality in a right to left fashion, we should
use <CODE>rewrite &lt;- E</CODE> rather than <CODE>rewrite E</CODE> or the equivalent
<CODE>rewrite -&gt; E</CODE>. 
Let us now illustrate the tactic <CODE>replace</CODE>.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis f10 : f 1 = f 0.</TT><BR>
<TT><I>f10 is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma L2 : f (f 1) = 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f (f 1) = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> replace (f 1) with 0.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f 0 = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> 0 = f 1</I></TT><BR>
</DIV><P>

What happened here is that the replacement left the first subgoal to be
proved, but another proof obligation was generated by the <CODE>replace</CODE>
tactic, as the second subgoal. The first subgoal is solved immediately
by applying lemma <CODE>foo</CODE>; the second one transitivity and then 
symmetry of equality, for instance with tactics <CODE>transitivity</CODE> and 
<CODE>symmetry</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply foo.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = f 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> transitivity (f 0); symmetry; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>

In case the equality <I>t</I>=<I>u</I> generated by <CODE>replace</CODE> <I>u</I> <CODE>with</CODE>
<I>t</I> is an assumption
(possibly modulo symmetry), it will be automatically proved and the
corresponding goal will not appear. For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f (f 1) = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> replace (f 0) with 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   f (f 1) = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> rewrite f10; rewrite foo; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> replace (f 0) with 0.</I></TT><BR>
<TT><I>rewrite f10 in |- *; rewrite foo in |- *; trivial.</I></TT><BR>
<TT><I>L2 is defined</I></TT><BR>
</DIV><!--TOC section Using definitions-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc17">1.5</A>  Using definitions</H2><!--SEC END --><P>The development of mathematics does not simply proceed by logical 
argumentation from first principles: definitions are used in an essential way.
A formal development proceeds by a dual process of abstraction, where one
proves abstract statements in predicate calculus, and use of definitions, 
which in the contrary one instantiates general statements with particular 
notions in order to use the structure of mathematical values for the proof of
more specialised properties.</P><!--TOC subsection Unfolding definitions-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc18">1.5.1</A>  Unfolding definitions</H3><!--SEC END --><P>Assume that we want to develop the theory of sets represented as characteristic
predicates over some universe <CODE>U</CODE>. For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Variable U : Type.</TT><BR>
<TT><I>U is assumed</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition set := U -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<TT><I>set is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition element (x:U) (S:set) := S x.</TT><BR>
<TT><I>element is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition subset (A B:set) := forall x:U, element x A -</TT><TT>&gt;</TT><TT> element x B.</TT><BR>
<TT><I>subset is defined</I></TT><BR>
</DIV><P>Now, assume that we have loaded a module of general properties about
relations over some abstract type <CODE>T</CODE>, such as transitivity:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition transitive (T:Type) (R:T -</TT><TT>&gt;</TT><TT> T -</TT><TT>&gt;</TT><TT> Prop) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall x y z:T, R x y -</TT><TT>&gt;</TT><TT> R y z -</TT><TT>&gt;</TT><TT> R x z.</TT><BR>
<TT><I>transitive is defined</I></TT><BR>
</DIV><P>Now, assume that we want to prove that <CODE>subset</CODE> is a <CODE>transitive</CODE>
relation. 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma subset_transitive : transitive set subset.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   transitive set subset</I></TT><BR>
</DIV><P>In order to make any progress, one needs to use the definition of
<CODE>transitive</CODE>. The <CODE>unfold</CODE> tactic, which replaces all
occurrences of a defined notion by its definition in the current goal,
may be used here.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> unfold transitive.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : set, subset x y -</I></TT><TT><I>&gt;</I></TT><TT><I> subset y z -</I></TT><TT><I>&gt;</I></TT><TT><I> subset x z</I></TT><BR>
</DIV><P>Now, we must unfold <CODE>subset</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> unfold subset.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : set,</I></TT><BR>
<TT><I>   (forall x0 : U, element x0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 y) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>   (forall x0 : U, element x0 y -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 z) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>   forall x0 : U, element x0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 z</I></TT><BR>
</DIV><P>

Now, unfolding <CODE>element</CODE> would be a mistake, because indeed a simple proof
can be found by <CODE>auto</CODE>, keeping <CODE>element</CODE> an abstract predicate:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Many variations on <CODE>unfold</CODE> are provided in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. For instance,
we may selectively unfold one designated occurrence:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Undo 2.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : set, subset x y -</I></TT><TT><I>&gt;</I></TT><TT><I> subset y z -</I></TT><TT><I>&gt;</I></TT><TT><I> subset x z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> unfold subset at 2.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : set,</I></TT><BR>
<TT><I>   subset x y -</I></TT><TT><I>&gt;</I></TT><TT><I> (forall x0 : U, element x0 y -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 z) -</I></TT><TT><I>&gt;</I></TT><TT><I> subset x z</I></TT><BR>
</DIV><P>One may also unfold a definition in a given local hypothesis, using the
<CODE>in</CODE> notation:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  x : set</I></TT><BR>
<TT><I>  y : set</I></TT><BR>
<TT><I>  z : set</I></TT><BR>
<TT><I>  H : subset x y</I></TT><BR>
<TT><I>  H0 : forall x : U, element x y -</I></TT><TT><I>&gt;</I></TT><TT><I> element x z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   subset x z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> unfold subset in H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  x : set</I></TT><BR>
<TT><I>  y : set</I></TT><BR>
<TT><I>  z : set</I></TT><BR>
<TT><I>  H : forall x0 : U, element x0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 y</I></TT><BR>
<TT><I>  H0 : forall x : U, element x y -</I></TT><TT><I>&gt;</I></TT><TT><I> element x z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   subset x z</I></TT><BR>
</DIV><P>Finally, the tactic <CODE>red</CODE> does only unfolding of the head occurrence
of the current goal:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> red.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  x : set</I></TT><BR>
<TT><I>  y : set</I></TT><BR>
<TT><I>  z : set</I></TT><BR>
<TT><I>  H : forall x0 : U, element x0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 y</I></TT><BR>
<TT><I>  H0 : forall x : U, element x y -</I></TT><TT><I>&gt;</I></TT><TT><I> element x z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x0 : U, element x0 x -</I></TT><TT><I>&gt;</I></TT><TT><I> element x0 z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>unfold transitive in |- *.</I></TT><BR>
<TT><I>unfold subset at 2 in |- *.</I></TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>unfold subset in H.</I></TT><BR>
<TT><I>red in |- *.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>subset_transitive is defined</I></TT><BR>
</DIV><!--TOC subsection Principle of proof irrelevance-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc19">1.5.2</A>  Principle of proof irrelevance</H3><!--SEC END --><P>Even though in principle the proof term associated with a verified lemma
corresponds to a defined value of the corresponding specification, such
definitions cannot be unfolded in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>: a lemma is considered an <I><FONT COLOR=maroon>opaque</FONT></I>
definition. This conforms to the mathematical tradition of <I><FONT COLOR=maroon>proof
irrelevance</FONT></I>: the proof of a logical proposition does not matter, and the
mathematical justification of a logical development relies only on
<I><FONT COLOR=maroon>provability</FONT></I> of the lemmas used in the formal proof. </P><P>Conversely, ordinary mathematical definitions can be unfolded at will, they
are <I><FONT COLOR=maroon>transparent</FONT></I>. 
</P><!--TOC chapter Induction-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc20">Chapter 2</A>  Induction</H1><!--SEC END --><!--TOC section Data Types as Inductively Defined Mathematical Collections-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc21">2.1</A>  Data Types as Inductively Defined Mathematical Collections</H2><!--SEC END --><P>All the notions which were studied until now pertain to traditional
mathematical logic. Specifications of objects were abstract properties
used in reasoning more or less constructively; we are now entering
the realm of inductive types, which specify the existence of concrete
mathematical constructions.</P><!--TOC subsection Booleans-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc22">2.1.1</A>  Booleans</H3><!--SEC END --><P>Let us start with the collection of booleans, as they are specified
in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s <CODE>Prelude</CODE> module: 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive bool :  Set := true | false.</TT><BR>
<TT><I>bool is defined</I></TT><BR>
<TT><I>bool_rect is defined</I></TT><BR>
<TT><I>bool_ind is defined</I></TT><BR>
<TT><I>bool_rec is defined</I></TT><BR>
</DIV><P>Such a declaration defines several objects at once. First, a new
<CODE>Set</CODE> is declared, with name <CODE>bool</CODE>. Then the <I><FONT COLOR=maroon>constructors</FONT></I>
of this <CODE>Set</CODE> are declared, called <CODE>true</CODE> and <CODE>false</CODE>.
Those are analogous to introduction rules of the new Set <CODE>bool</CODE>.
Finally, a specific elimination rule for <CODE>bool</CODE> is now available, which
permits to reason by cases on <CODE>bool</CODE> values. Three instances are
indeed defined as new combinators in the global context: <CODE>bool_ind</CODE>,
a proof combinator corresponding to reasoning by cases,
<CODE>bool_rec</CODE>, an if-then-else programming construct,
and <CODE>bool_rect</CODE>, a similar combinator at the level of types.
Indeed:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check bool_ind.</TT><BR>
<TT><I>bool_ind</I></TT><BR>
<TT><I>     : forall P : bool -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop, P true -</I></TT><TT><I>&gt;</I></TT><TT><I> P false -</I></TT><TT><I>&gt;</I></TT><TT><I> forall b : bool, P b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check bool_rec.</TT><BR>
<TT><I>bool_rec</I></TT><BR>
<TT><I>     : forall P : bool -</I></TT><TT><I>&gt;</I></TT><TT><I> Set, P true -</I></TT><TT><I>&gt;</I></TT><TT><I> P false -</I></TT><TT><I>&gt;</I></TT><TT><I> forall b : bool, P b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check bool_rect.</TT><BR>
<TT><I>bool_rect</I></TT><BR>
<TT><I>     : forall P : bool -</I></TT><TT><I>&gt;</I></TT><TT><I> Type, P true -</I></TT><TT><I>&gt;</I></TT><TT><I> P false -</I></TT><TT><I>&gt;</I></TT><TT><I> forall b : bool, P b</I></TT><BR>
</DIV><P>Let us for instance prove that every Boolean is true or false.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma duality : forall b:bool, b = true </TT><TT>\</TT><TT>/ b = false.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall b : bool, b = true </I></TT><TT><I>\</I></TT><TT><I>/ b = false</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro b.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  b : bool</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   b = true </I></TT><TT><I>\</I></TT><TT><I>/ b = false</I></TT><BR>
</DIV><P>We use the knowledge that <CODE>b</CODE> is a <CODE>bool</CODE> by calling tactic
<CODE>elim</CODE>, which is this case will appeal to combinator <CODE>bool_ind</CODE>
in order to split the proof according to the two cases:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> elim b.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  b : bool</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   true = true </I></TT><TT><I>\</I></TT><TT><I>/ true = false</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> false = true </I></TT><TT><I>\</I></TT><TT><I>/ false = false</I></TT><BR>
</DIV><P>It is easy to conclude in each case:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> left; trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  b : bool</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   false = true </I></TT><TT><I>\</I></TT><TT><I>/ false = false</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> right; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Indeed, the whole proof can be done with the combination of the
<CODE>simple induction</CODE> tactic, which combines <CODE>intro</CODE> and <CODE>elim</CODE>,
with good old <CODE>auto</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  Q : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  R : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  f : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>  foo : f 0 = 0</I></TT><BR>
<TT><I>  f10 : f 1 = f 0</I></TT><BR>
<TT><I>  U : Type</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall b : bool, b = true </I></TT><TT><I>\</I></TT><TT><I>/ b = false</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> simple induction b; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>simple induction b; auto.</I></TT><BR>
<TT><I>duality is defined</I></TT><BR>
</DIV><!--TOC subsection Natural numbers-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc23">2.1.2</A>  Natural numbers</H3><!--SEC END --><P>Similarly to Booleans, natural numbers are defined in the <CODE>Prelude</CODE>
module with constructors <CODE>S</CODE> and <CODE>O</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive nat : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | O : nat</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S : nat -</TT><TT>&gt;</TT><TT> nat.</TT><BR>
<TT><I>nat is defined</I></TT><BR>
<TT><I>nat_rect is defined</I></TT><BR>
<TT><I>nat_ind is defined</I></TT><BR>
<TT><I>nat_rec is defined</I></TT><BR>
</DIV><P>The elimination principles which are automatically generated are Peano's
induction principle, and a recursion operator:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check nat_ind.</TT><BR>
<TT><I>nat_ind</I></TT><BR>
<TT><I>     : forall P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop,</I></TT><BR>
<TT><I>       P O -</I></TT><TT><I>&gt;</I></TT><TT><I> (forall n : nat, P n -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S n)) -</I></TT><TT><I>&gt;</I></TT><TT><I> forall n : nat, P n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check nat_rec.</TT><BR>
<TT><I>nat_rec</I></TT><BR>
<TT><I>     : forall P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Set,</I></TT><BR>
<TT><I>       P O -</I></TT><TT><I>&gt;</I></TT><TT><I> (forall n : nat, P n -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S n)) -</I></TT><TT><I>&gt;</I></TT><TT><I> forall n : nat, P n</I></TT><BR>
</DIV><P>Let us start by showing how to program the standard primitive recursion
operator <CODE>prim_rec</CODE> from the more general <CODE>nat_rec</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition prim_rec := nat_rec (fun i:nat =</TT><TT>&gt;</TT><TT> nat).</TT><BR>
<TT><I>prim_rec is defined</I></TT><BR>
</DIV><P>That is, instead of computing for natural <CODE>i</CODE> an element of the indexed
<CODE>Set</CODE> <CODE>(P i)</CODE>, <CODE>prim_rec</CODE> computes uniformly an element of 
<CODE>nat</CODE>. Let us check the type of <CODE>prim_rec</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check prim_rec.</TT><BR>
<TT><I>prim_rec</I></TT><BR>
<TT><I>     : (fun _ : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> nat) O -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (forall n : nat, (fun _ : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> nat) n -</I></TT><TT><I>&gt;</I></TT><TT><I> (fun _ : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> nat) (S n)) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       forall n : nat, (fun _ : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> nat) n</I></TT><BR>
</DIV><P>Oops! Instead of the expected type <CODE>nat-&gt;(nat-&gt;nat-&gt;nat)-&gt;nat-&gt;nat</CODE> we
get an apparently more complicated expression. Indeed the type of
<CODE>prim_rec</CODE> is equivalent by rule &#X3B2; to its expected type; this may
be checked in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  by command <CODE>Eval Cbv Beta</CODE>, which &#X3B2;-reduces
an expression to its <I><FONT COLOR=maroon>normal form</FONT></I>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Eval cbv beta in</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   ((fun _:nat =</TT><TT>&gt;</TT><TT> nat) O -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall y:nat, (fun _:nat =</TT><TT>&gt;</TT><TT> nat) y -</TT><TT>&gt;</TT><TT> (fun _:nat =</TT><TT>&gt;</TT><TT> nat) (S y)) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall n:nat, (fun _:nat =</TT><TT>&gt;</TT><TT> nat) n).</TT><BR>
<TT><I>     = nat -</I></TT><TT><I>&gt;</I></TT><TT><I> (nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat) -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>     : Set</I></TT><BR>
</DIV><P>Let us now show how to program addition with primitive recursion:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition addition (n m:nat) := prim_rec m (fun p rec:nat =</TT><TT>&gt;</TT><TT> S rec) n.</TT><BR>
<TT><I>addition is defined</I></TT><BR>
</DIV><P>That is, we specify that <CODE>(addition n m)</CODE> computes by cases on <CODE>n</CODE>
according to its main constructor; when <CODE>n = O</CODE>, we get <CODE>m</CODE>;
when <CODE>n = S p</CODE>, we get <CODE>(S rec)</CODE>, where <CODE>rec</CODE> is the result
of the recursive computation <CODE>(addition p m)</CODE>. Let us verify it by
asking <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to compute for us say 2+3:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in (addition (S (S O)) (S (S (S O)))).</TT><BR>
<TT><I>     = S (S (S (S (S O))))</I></TT><BR>
<TT><I>     : (fun _ : nat =</I></TT><TT><I>&gt;</I></TT><TT><I> nat) (S (S O))</I></TT><BR>
</DIV><P>Actually, we do not have to do all explicitly. <SPAN STYLE="font-variant:small-caps">Coq</SPAN> provides a
special syntax <TT>Fixpoint/match</TT> for generic primitive recursion,
and we could thus have defined directly addition as:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint plus (n m:nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | O =</TT><TT>&gt;</TT><TT> m</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> S (plus p m)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<TT><I>plus is recursively defined</I></TT><BR>
</DIV><P>For the rest of the session, we shall clean up what we did so far with 
types <CODE>bool</CODE> and <CODE>nat</CODE>, in order to use the initial definitions
given in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s <CODE>Prelude</CODE> module, and not to get confusing error
messages due to our redefinitions. We thus revert to the state before
our definition of <CODE>bool</CODE> with the <CODE>Reset</CODE> command:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Reset bool.</TT><BR>
</DIV><!--TOC subsection Simple proofs by induction-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc24">2.1.3</A>  Simple proofs by induction</H3><!--SEC END --><P>Let us now show how to do proofs by structural induction. We start with easy
properties of the <CODE>plus</CODE> function we just defined. Let us first
show that <I>n</I>=<I>n</I>+0.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma plus_n_O : forall n:nat, n = n + 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, n = n + 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro n; elim n.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0 + 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> forall n0 : nat, n0 = n0 + 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> S n0 = S n0 + 0</I></TT><BR>
</DIV><P>What happened was that <CODE>elim n</CODE>, in order to construct a <CODE>Prop</CODE>
(the initial goal) from a <CODE>nat</CODE> (i.e. <CODE>n</CODE>), appealed to the
corresponding induction principle <CODE>nat_ind</CODE> which we saw was indeed
exactly Peano's induction scheme. Pattern-matching instantiated the 
corresponding predicate <CODE>P</CODE> to <CODE>fun n:nat =&gt; n = n </CODE> 0+, and we get
as subgoals the corresponding instantiations of the base case <CODE>(P O)</CODE> ,
and of the inductive step <CODE>forall y:nat, P y -&gt; P (S y)</CODE>.
In each case we get an instance of function <CODE>plus</CODE> in which its second
argument starts with a constructor, and is thus amenable to simplification
by primitive recursion. The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tactic <CODE>simpl</CODE> can be used for
this purpose:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> simpl.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> forall n0 : nat, n0 = n0 + 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> S n0 = S n0 + 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n0 : nat, n0 = n0 + 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> S n0 = S n0 + 0</I></TT><BR>
</DIV><P>We proceed in the same way for the base step:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> simpl; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro n; elim n.</I></TT><BR>
<TT><I> simpl in |- *.</I></TT><BR>
<TT><I>   auto.</I></TT><BR>
<TT><I>simpl in |- *; auto.</I></TT><BR>
<TT><I>plus_n_O is defined</I></TT><BR>
</DIV><P>Here <CODE>auto</CODE> succeeded, because it used as a hint lemma <CODE>eq_S</CODE>,
which say that successor preserves equality:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check eq_S.</TT><BR>
<TT><I>eq_S</I></TT><BR>
<TT><I>     : forall x y : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> S x = S y</I></TT><BR>
</DIV><P>Actually, let us see how to declare our lemma <CODE>plus_n_O</CODE> as a hint
to be used by <CODE>auto</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve plus_n_O .</TT><BR>
</DIV><P>We now proceed to the similar property concerning the other constructor
<CODE>S</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma plus_n_S : forall n m:nat, S (n + m) = n + S m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, S (n + m) = n + S m</I></TT><BR>
</DIV><P>We now go faster, remembering that tactic <CODE>simple induction</CODE> does the
necessary <CODE>intros</CODE> before applying <CODE>elim</CODE>. Factoring simplification
and automation in both cases thanks to tactic composition, we prove this
lemma in one line:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> simple induction n; simpl; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>simple induction n; simpl in |- *; auto.</I></TT><BR>
<TT><I>plus_n_S is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve plus_n_S .</TT><BR>
</DIV><P>Let us end this exercise with the commutativity of <CODE>plus</CODE>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma plus_com : forall n m:nat, n + m = m + n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, n + m = m + n</I></TT><BR>
</DIV><P>Here we have a choice on doing an induction on <CODE>n</CODE> or on <CODE>m</CODE>, the
situation being symmetric. For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> simple induction m; simpl; auto.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n0 : nat, n + n0 = n0 + n -</I></TT><TT><I>&gt;</I></TT><TT><I> n + S n0 = S (n0 + n)</I></TT><BR>
</DIV><P>Here <CODE>auto</CODE> succeeded on the base case, thanks to our hint
<CODE>plus_n_O</CODE>, but the induction step requires rewriting, which
<CODE>auto</CODE> does not handle:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros m' E; rewrite </TT><TT>&lt;</TT><TT>- E; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>simple induction m; simpl in |- *; auto.</I></TT><BR>
<TT><I>intros m' E; rewrite </I></TT><TT><I>&lt;</I></TT><TT><I>- E in |- *; auto.</I></TT><BR>
<TT><I>plus_com is defined</I></TT><BR>
</DIV><!--TOC subsection Discriminate-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc25">2.1.4</A>  Discriminate</H3><!--SEC END --><P>It is also possible to define new propositions by primitive recursion.
Let us for instance define the predicate which discriminates between
the constructors <CODE>O</CODE> and <CODE>S</CODE>: it computes to <CODE>False</CODE> 
when its argument is <CODE>O</CODE>, and to <CODE>True</CODE> when its argument is 
of the form <CODE>(S n)</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition Is_S (n:nat) := match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                            | O =</TT><TT>&gt;</TT><TT> False</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                            | S p =</TT><TT>&gt;</TT><TT> True</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                            end.</TT><BR>
<TT><I>Is_S is defined</I></TT><BR>
</DIV><P>Now we may use the computational power of <CODE>Is_S</CODE> in order to prove
trivially that <CODE>(Is_S (S n))</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma S_Is_S : forall n:nat, Is_S (S n).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, Is_S (S n)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> simpl; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>simpl in |- *; trivial.</I></TT><BR>
<TT><I>S_Is_S is defined</I></TT><BR>
</DIV><P>But we may also use it to transform a <CODE>False</CODE> goal into 
<CODE>(Is_S O)</CODE>. Let us show a particularly important use of this feature;
we want to prove that <CODE>O</CODE> and <CODE>S</CODE> construct different values, one
of Peano's axioms:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma no_confusion : forall n:nat, 0 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> S n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, 0 </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> S n</I></TT><BR>
</DIV><P>First of all, we replace negation by its definition, by reducing the
goal with tactic <CODE>red</CODE>; then we get contradiction by successive
<CODE>intros</CODE>:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> red; intros n H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : 0 = S n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   False</I></TT><BR>
</DIV><P>Now we use our trick:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> change (Is_S 0).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : 0 = S n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   Is_S 0</I></TT><BR>
</DIV><P>Now we use equality in order to get a subgoal which computes out to 
<CODE>True</CODE>, which finishes the proof:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> rewrite H; trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : 0 = S n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   Is_S (S n)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> simpl; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Actually, a specific tactic <CODE>discriminate</CODE> is provided
to produce mechanically such proofs, without the need for the user to define
explicitly the relevant discrimination predicates:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, 0 </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> S n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro n; discriminate.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro n;  discriminate.</I></TT><BR>
<TT><I>no_confusion is defined</I></TT><BR>
</DIV><!--TOC section Logic programming-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">2.2</A>  Logic programming</H2><!--SEC END --><P>In the same way as we defined standard data-types above, we
may define inductive families, and for instance inductive predicates.
Here is the definition of predicate &#X2264; over type <CODE>nat</CODE>, as
given in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s <CODE>Prelude</CODE> module:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive le (n:nat) : nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | le_n : le n n</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | le_S : forall m:nat, le n m -</TT><TT>&gt;</TT><TT> le n (S m).</TT><BR>
</DIV><P>This definition introduces a new predicate <CODE>le:nat-&gt;nat-&gt;Prop</CODE>,
and the two constructors <CODE>le_n</CODE> and <CODE>le_S</CODE>, which are the
defining clauses of <CODE>le</CODE>. That is, we get not only the &#X201C;axioms&#X201D;
<CODE>le_n</CODE> and <CODE>le_S</CODE>, but also the converse property, that 
<CODE>(le n m)</CODE> if and only if this statement can be obtained as a
consequence of these defining clauses; that is, <CODE>le</CODE> is the
minimal predicate verifying clauses <CODE>le_n</CODE> and <CODE>le_S</CODE>. This is
insured, as in the case of inductive data types, by an elimination principle,
which here amounts to an induction principle <CODE>le_ind</CODE>, stating this 
minimality property:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check le.</TT><BR>
<TT><I>le</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check le_ind.</TT><BR>
<TT><I>le_ind</I></TT><BR>
<TT><I>     : forall (n : nat) (P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>       P n -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       (forall m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> P m -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S m)) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>       forall n0 : nat, le n n0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P n0</I></TT><BR>
</DIV><P>Let us show how proofs may be conducted with this principle.
First we show that <I>n</I>&#X2264; <I>m</I> &#X21D2; <I>n</I>+1&#X2264; <I>m</I>+1:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma le_n_S : forall n m:nat, le n m -</TT><TT>&gt;</TT><TT> le (S n) (S m).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n m n_le_m.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  n_le_m : le n m</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   le (S n) (S m)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> elim n_le_m.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  n_le_m : le n m</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   le (S n) (S n)</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> forall m0 : nat, le n m0 -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m0) -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S (S m0))</I></TT><BR>
</DIV><P>What happens here is similar to the behaviour of <CODE>elim</CODE> on natural
numbers: it appeals to the relevant induction principle, here <CODE>le_ind</CODE>,
which generates the two subgoals, which may then be solved easily
with the help of the defining clauses of <CODE>le</CODE>.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> apply le_n; trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  n_le_m : le n m</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall m0 : nat, le n m0 -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m0) -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S (S m0))</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros; apply le_S; trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>Now we know that it is a good idea to give the defining clauses as hints,
so that the proof may proceed with a simple combination of 
<CODE>induction</CODE> and <CODE>auto</CODE>.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Restart.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve le_n le_S .</TT><BR>
</DIV><P>We have a slight problem however. We want to say &#X201C;Do an induction on
hypothesis <CODE>(le n m)</CODE>&#X201D;, but we have no explicit name for it. What we
do in this case is to say &#X201C;Do an induction on the first unnamed hypothesis&#X201D;,
as follows.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> simple induction 1; auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>simple induction 1; auto.</I></TT><BR>
<TT><I>le_n_S is defined</I></TT><BR>
</DIV><P>Here is a more tricky problem. Assume we want to show that
<I>n</I>&#X2264; 0 &#X21D2; <I>n</I>=0. This reasoning ought to follow simply from the
fact that only the first defining clause of <CODE>le</CODE> applies.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma tricky : forall n:nat, le n 0 -</TT><TT>&gt;</TT><TT> n = 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, le n 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
</DIV><P>However, here trying something like <CODE>induction 1</CODE> would lead
nowhere (try it and see what happens). 
An induction on <CODE>n</CODE> would not be convenient either.
What we must do here is analyse the definition of <CODE>le</CODE> in order
to match hypothesis <CODE>(le n O)</CODE> with the defining clauses, to find
that only <CODE>le_n</CODE> applies, whence the result. 
This analysis may be performed by the &#X201C;inversion&#X201D; tactic
<CODE>inversion_clear</CODE> as follows:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros n H; inversion_clear H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 = 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> trivial.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros n H; inversion_clear H.</I></TT><BR>
<TT><I>trivial.</I></TT><BR>
<TT><I>tricky is defined</I></TT><BR>
</DIV><!--TOC chapter Modules-->
<H1 CLASS="chapter"><!--SEC ANCHOR --><A NAME="htoc27">Chapter 3</A>  Modules</H1><!--SEC END --><!--TOC section Opening library modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc28">3.1</A>  Opening library modules</H2><!--SEC END --><P>When you start <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  without further requirements in the command line,
you get a bare system with few libraries loaded. As we saw, a standard
prelude module provides the standard logic connectives, and a few
arithmetic notions. If you want to load and open other modules from
the library, you have to use the <CODE>Require</CODE> command, as we saw for
classical logic above. For instance, if you want more arithmetic
constructions, you should request:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Arith.</TT><BR>
</DIV><P>Such a command looks for a (compiled) module file <CODE>Arith.vo</CODE> in
the libraries registered by <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Libraries inherit the structure of
the file system of the operating system and are registered with the
command <CODE>Add LoadPath</CODE>. Physical directories are mapped to
logical directories. Especially the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  is
pre-registered as a library of name <CODE>Coq</CODE>. Modules have absolute
unique names denoting their place in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  libraries. An absolute
name is a sequence of single identifiers separated by dots. E.g. the
module <CODE>Arith</CODE> has full name <CODE>Coq.Arith.Arith</CODE> and because
it resides in eponym subdirectory <CODE>Arith</CODE> of the standard
library, it can be as well required by the command</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Coq.Arith.Arith.</TT><BR>
</DIV><P>This may be useful to avoid ambiguities if somewhere, in another branch
of the libraries known by Coq, another module is also called
<CODE>Arith</CODE>. Notice that by default, when a library is registered,
all its contents, and all the contents of its subdirectories recursively are
visible and accessible by a short (relative) name as <CODE>Arith</CODE>.
Notice also that modules or definitions not explicitly registered in
a library are put in a default library called <CODE>Top</CODE>.</P><P>The loading of a compiled file is quick, because the corresponding
development is not type-checked again. </P><!--TOC section Creating your own modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc29">3.2</A>  Creating your own modules</H2><!--SEC END --><P>You may create your own modules, by writing <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  commands in a file,
say <CODE>my_module.v</CODE>. Such a module may be simply loaded in the current
context, with command <CODE>Load my_module</CODE>. It may also be compiled,
in &#X201C;batch&#X201D; mode, using the UNIX command
<CODE>coqc</CODE>. Compiling the module <CODE>my_module.v</CODE> creates a 
file <CODE>my_module.vo</CODE> that can be reloaded with command
<CODE>Require Import my_module</CODE>. </P><P>If a required module depends on other modules then the latters are
automatically required beforehand. However their contents is not
automatically visible. If you want a module <CODE>M</CODE> required in a
module <CODE>N</CODE> to be automatically visible when <CODE>N</CODE> is required,
you should use <CODE>Require Export M</CODE> in your module <CODE>N</CODE>.</P><!--TOC section Managing the context-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">3.3</A>  Managing the context</H2><!--SEC END --><P>It is often difficult to remember the names of all lemmas and
definitions available in the current context, especially if large
libraries have been loaded. A convenient <CODE>SearchAbout</CODE> command
is available to lookup all known facts 
concerning a given predicate. For instance, if you want to know all the
known lemmas about the less or equal relation, just ask:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> SearchAbout le.</TT><BR>
<TT><I>tricky: forall n : nat, le n 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> n = 0</I></TT><BR>
<TT><I>Top.le_n_S: forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m)</I></TT><BR>
<TT><I>le_ind:</I></TT><BR>
<TT><I>  forall (n : nat) (P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop),</I></TT><BR>
<TT><I>  P n -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>  (forall m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> P m -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S m)) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>  forall n0 : nat, le n n0 -</I></TT><TT><I>&gt;</I></TT><TT><I> P n0</I></TT><BR>
<TT><I>le_n: forall n : nat, le n n</I></TT><BR>
<TT><I>le_S: forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le n (S m)</I></TT><BR>
</DIV><P>

Another command <CODE>Search</CODE> displays only lemmas where the searched
predicate appears at the head position in the conclusion.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Search le.</TT><BR>
<TT><I>Top.le_n_S: forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le (S n) (S m)</I></TT><BR>
<TT><I>le_n: forall n : nat, le n n</I></TT><BR>
<TT><I>le_S: forall n m : nat, le n m -</I></TT><TT><I>&gt;</I></TT><TT><I> le n (S m)</I></TT><BR>
</DIV><P>A new and more convenient search tool is <FONT COLOR=purple>SearchPattern</FONT>
developed by Yves Bertot. It allows to find the theorems with a
conclusion matching a given pattern, where <CODE>\_</CODE> can be used in
place of an arbitrary term. We remark in this example, that <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
provides usual infix notations for arithmetic operators.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> SearchPattern (_ + _ = _).</TT><BR>
<TT><I>le_plus_minus_r: forall n m : nat, n </I></TT><TT><I>&lt;</I></TT><TT><I>= m -</I></TT><TT><I>&gt;</I></TT><TT><I> n + (m - n) = m</I></TT><BR>
<TT><I>mult_acc_aux: forall n m p : nat, m + n * p = mult_acc m p n</I></TT><BR>
<TT><I>plus_O_n: forall n : nat, 0 + n = n</I></TT><BR>
<TT><I>plus_Sn_m: forall n m : nat, S n + m = S (n + m)</I></TT><BR>
<TT><I>mult_n_Sm: forall n m : nat, n * m + n = n * S m</I></TT><BR>
<TT><I>plus_0_l: forall n : nat, 0 + n = n</I></TT><BR>
<TT><I>plus_0_r: forall n : nat, n + 0 = n</I></TT><BR>
<TT><I>plus_comm: forall n m : nat, n + m = m + n</I></TT><BR>
<TT><I>plus_Snm_nSm: forall n m : nat, S n + m = n + S m</I></TT><BR>
<TT><I>plus_assoc: forall n m p : nat, n + (m + p) = n + m + p</I></TT><BR>
<TT><I>plus_permute: forall n m p : nat, n + (m + p) = m + (n + p)</I></TT><BR>
<TT><I>plus_assoc_reverse: forall n m p : nat, n + m + p = n + (m + p)</I></TT><BR>
<TT><I>plus_permute_2_in_4: forall n m p q : nat, n + m + (p + q) = n + p + (m + q)</I></TT><BR>
<TT><I>plus_tail_plus: forall n m : nat, n + m = tail_plus n m</I></TT><BR>
<TT><I>plus_com: forall n m : nat, n + m = m + n</I></TT><BR>
</DIV><!--TOC section Now you are on your own-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc31">3.4</A>  Now you are on your own</H2><!--SEC END --><P>This tutorial is necessarily incomplete. If you wish to pursue serious
proving in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, you should now get your hands on <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s Reference Manual,
which contains a complete description of all the tactics we saw, 
plus many more.
You also should look in the library of developed theories which is distributed
with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, in order to acquaint yourself with various proof techniques.</P><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
