<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>
<TITLE>Coq Version 8.0 for the Clueless 
 (176
 Hints)

</TITLE>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<STYLE type="text/css">
.li-itemize{margin:1ex 0ex;}
.li-enumerate{margin:1ex 0ex;}
.dd-description{margin:0ex 0ex 1ex 4ex;}
.dt-description{margin:0ex;}
.toc{list-style:none;}
.thefootnotes{text-align:left;margin:0ex;}
.dt-thefootnotes{margin:0em;}
.dd-thefootnotes{margin:0em 0em 0em 2em;}
.footnoterule{margin:1em auto 1em 0px;width:50%;}
.caption{padding-left:2ex; padding-right:2ex; margin-left:auto; margin-right:auto}
.title{margin:auto;text-align:center}
.center{text-align:center;margin-left:auto;margin-right:auto;}
.flushleft{text-align:left;margin-left:0ex;margin-right:auto;}
.flushright{text-align:right;margin-left:auto;margin-right:0ex;}
DIV TABLE{margin-left:inherit;margin-right:inherit;}
PRE{text-align:left;margin-left:0ex;margin-right:auto;}
BLOCKQUOTE{margin-left:4ex;margin-right:4ex;text-align:left;}
TD P{margin:0px;}
.boxed{border:1px solid black}
.textboxed{border:1px solid black}
.vbar{border:none;width:2px;background-color:black;}
.hbar{border:none;height:2px;width:100%;background-color:black;}
.hfill{border:none;height:1px;width:200%;background-color:black;}
.vdisplay{border-collapse:separate;border-spacing:2px;width:auto; empty-cells:show; border:2px solid red;}
.vdcell{white-space:nowrap;padding:0px;width:auto; border:2px solid green;}
.display{border-collapse:separate;border-spacing:2px;width:auto; border:none;}
.dcell{white-space:nowrap;padding:0px;width:auto; border:none;}
.dcenter{margin:0ex auto;}
.vdcenter{border:solid #FF8000 2px; margin:0ex auto;}
.minipage{text-align:left; margin-left:0em; margin-right:auto;}
.marginpar{border:solid thin black; width:20%; text-align:left;}
.marginparleft{float:left; margin-left:0ex; margin-right:1ex;}
.marginparright{float:right; margin-left:1ex; margin-right:0ex;}
.theorem{text-align:left;margin:1ex auto 1ex 0ex;}
.part{margin:auto;text-align:center}
</STYLE>
</HEAD>
<BODY >
<!--HEVEA command line is: /usr/bin/hevea -fix FAQ.v.tex -->
<!--CUT DEF section 1 --><TABLE CLASS="title"><TR><TD><H1 CLASS="titlemain">Coq Version 8.0 for the Clueless<BR>
 <FONT SIZE=4>(</FONT><A HREF="#lastquestion"><FONT SIZE=4>176</FONT></A><FONT SIZE=4>
 Hints)
</FONT></H1><H3 CLASS="titlerest">Pierre Castéran   Hugo Herbelin   Florent Kirchner   Benjamin Monate   Julien Narboux</H3></TD></TR>
</TABLE><BLOCKQUOTE CLASS="abstract"><B>Abstract: </B>
This note intends to provide an easy way to get acquainted with the
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> theorem prover. It tries to formulate appropriate answers
to some of the questions any newcomers will face, and to give
pointers to other references when possible.
</BLOCKQUOTE><!--TOC section Contents-->
<H2 CLASS="section"><!--SEC ANCHOR -->Contents</H2><!--SEC END --><UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc1">1  Introduction</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc2">2  Presentation</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc3">1  What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc4">2  Did you really need to name it like that?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc5">3  Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc6">4  What are the other theorem provers?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc7">5  What do I have to trust when I see a proof checked by Coq?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc8">6  Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc9">7  How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc10">8  How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc11">9  What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc12">10  What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc13">11  What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc14">12  What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc15">13  What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc16">3  Documentation</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc17">14  Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc18">15  Where can I find this FAQ on the web?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc19">16  How can I submit suggestions / improvements / additions for this FAQ?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc20">17  Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc21">18  Where can I find an archive of the list?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc22">19  How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc23">20  Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc24">21  Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc25">22  How can I report a bug?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc26">4  Installation</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc27">23  What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc28">24  Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc29">25  On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc30">5  The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc31">5.1  General</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc32">26  What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc33">27  Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc34">28  Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc35">29  How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc36">5.2  Axioms</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc37">30  What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc38">31  What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc39">32  What is Streicher's axiom <I>K</I></A>
</LI><LI CLASS="li-toc"><A HREF="#htoc40">33  What is proof-irrelevance</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc41">34  What about functional extensionality?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc42">35  Is <TT>Prop</TT> impredicative?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc43">36  Is <TT>Set</TT> impredicative?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc44">37  Is <TT>Type</TT> impredicative?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc45">38  I have two proofs of the same proposition. Can I prove they are equal?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc46">39  I have two proofs of an equality statement. Can I prove they are 
equal?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc47">40  Can I prove that the second components of equal dependent
pairs are equal?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc48">5.3  Impredicativity</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc49">41  Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc50">42  What is a &#X201C;large inductive definition&#X201D;?</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc51">6  Talkin' with the Rooster</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc52">6.1  My goal is ..., how can I prove it?</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc53">43  My goal is a conjunction, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc54">44  My goal contains a conjunction as an hypothesis, how can I use it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc55">45  My goal is a disjunction, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc56">46  My goal is an universally quantified statement, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc57">47  My goal is an existential, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc58">48  My goal is solvable by some lemma, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc59">49  My goal contains False as an hypothesis, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc60">50  My goal is an equality of two convertible terms, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc61">51  My goal is a <TT>let x := a in ...</TT>, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc62">52  My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc63">53  My goal contains some existential hypotheses, how can I use it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc64">54  My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc65">55  My goal is an equality, how can I swap the left and right hand terms?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc66">56  My hypothesis is an equality, how can I swap the left and right hand terms?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc67">57  My goal is an equality, how can I prove it by transitivity?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc68">58  My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc69">59  My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc70">60  My goal is one of the hypotheses, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc71">61  My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc72">62  What can be the difference between applying one hypothesis or another in the context of the last question?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc73">63  My goal is a propositional tautology, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc74">64  My goal is a first order formula, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc75">65  My goal is solvable by a sequence of rewrites, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc76">66  My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc77">67  My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc78">68  My goal is an equality on some field (e.g. real numbers), how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc79">69  My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc80">70  My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc81">6.2  Tactics usage</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc82">71  I want to state a fact that I will use later as an hypothesis, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc83">72  I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc84">73  What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc85">74  How can I know what a tactic does?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc86">75  Why <TT>auto</TT> does not work? How can I fix it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc87">76  What is <TT>eauto</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc88">77  How can I speed up <TT>auto</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc89">78  What is the equivalent of <TT>tauto</TT> for classical logic?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc90">79  I want to replace some term with another in the goal, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc91">80  I want to replace some term with another in an hypothesis, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc92">81  I want to replace some symbol with its definition, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc93">82  How can I reduce some term?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc94">83  How can I declare a shortcut for some term?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc95">84  How can I perform case analysis?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc96">85  Why should I name my intros?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc97">86  How can I automatize the naming?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc98">87  I want to automatize the use of some tactic, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc99">88  I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc100">89  How can I do the opposite of the <TT>intro</TT> tactic?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc101">90  One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc102">91  What can I do if I get &#X201C;<TT>generated subgoal term has metavariables in it </TT>&#X201D;?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc103">92  How can I instantiate some metavariable?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc104">93  What is the use of the <TT>pattern</TT> tactic?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc105">94  What is the difference between assert, cut and generalize?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc106">95  What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc107">96  How can I explicit some implicit argument ?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc108">6.3  Proof management</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc109">97  How can I change the order of the subgoals?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc110">98  How can I change the order of the hypothesis?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc111">99  How can I change the name of an hypothesis?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc112">100  How can I delete some hypothesis?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc113">101  How can use a proof which is not finished?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc114">102  How can I state a conjecture?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc115">103  What is the difference between a lemma, a fact and a theorem?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc116">104  How can I organize my proofs?</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc117">7  Inductive and Co-inductive types</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc118">7.1  General</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc119">105  How can I prove that two constructors are different?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc120">106  During an inductive proof, how to get rid of impossible cases of an inductive definition?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc121">107  How can I prove that 2 terms in an inductive set are equal? Or different?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc122">108  Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc123">109  Why is dependent elimination in Prop not
available by default?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc124">110  Argh! I cannot write expressions like &#X201C; <TT>if n &lt;= p then p else n</TT> &#X201D;, as in any programming language</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc125">111  I wrote my own decision procedure for &#X2264;, which
is much faster than yours, but proving such theorems as
<TT>max_equiv</TT> seems to be quite difficult</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc126">7.2  Recursion</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc127">112  Why can't I define a non terminating program?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc128">113  Why only structurally well-founded loops are allowed?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc129">114  How to define loops based on non structurally smaller
recursive calls?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc130">115  What is behind the accessibility and well-foundedness proofs?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc131">116  How to perform simultaneous double induction?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc132">117  How to define a function by simultaneous double recursion?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc133">118  How to perform nested and double induction?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc134">119  How to define a function by nested recursion?</A>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc135">7.3  Co-inductive types</A>
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc136">120  I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</A>
</LI></UL>
</LI></UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc137">8  Syntax and notations</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc138">121  I do not want to type &#X201C;forall&#X201D; because it is too long, what can I do?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc139">122  How can I define a notation for square?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc140">123  Why &#X201C;no associativity&#X201D; and &#X201C;left associativity&#X201D; at the same level does not work?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc141">124  How can I know the associativity associated with a level?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc142">9  Modules</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc143">10  <SPAN STYLE="font-variant:small-caps">Ltac</SPAN></A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc144">125  What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc145">126  Why do I always get the same error message?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc146">127  Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc147">128  What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc148">129  What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc149">130  What is the semantics for &#X201C;match goal&#X201D;?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc150">131  Why can't I use a &#X201C;match goal&#X201D; returning a tactic in a non
tail-recursive position?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc151">132  How can I generate a new name?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc152">133  How can I define static and dynamic code?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc153">11  Tactics written in Ocaml</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc154">134  Can you show me an example of a tactic written in OCaml?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc155">12  Case studies</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc156">135  How can I define vectors or lists of size n?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc157">136  How to prove that 2 sets are different?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc158">137  Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc159">138  How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc160">139  How to exploit equalities on sets</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc161">140  I have a problem of dependent elimination on
proofs, how to solve it?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc162">141  And what if I want to prove the following?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc163">13  Publishing tools</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc164">142  How can I generate some latex from my development?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc165">143  How can I generate some HTML from my development?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc166">144  How can I generate some dependency graph from my development?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc167">145  How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc168">146  How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc169">147  Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc170">148  How can I read my proof in natural language?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc171">14  <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN></A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc172">149  What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc173">150  How to enable Emacs keybindings?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc174">151  How to enable antialiased fonts?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc175">152  How to use those Forall and Exists pretty symbols?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc176">153  How to define an input method for non ASCII symbols?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc177">154  How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc178">155  How to customize the shortcuts for menus?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc179">156  What encoding should I use? What is this \x{iiii} in my file?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc180">15  Extraction</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc181">157  What is program extraction?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc182">158  Which language can I extract to?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc183">159  How can I extract an incomplete proof?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc184">16  Glossary</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc185">160  Can you explain me what an evaluable constant is?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc186">161  What is a goal?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc187">162  What is a meta variable?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc188">163  What is Gallina?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc189">164  What is The Vernacular?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc190">165  What is a dependent type?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc191">166  What is a proof by reflection?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc192">167  What is intuitionistic logic?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc193">168  What is proof-irrelevance?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc194">169  What is the difference between opaque and transparent?</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc195">17  Troubleshooting</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc196">170  What can I do when <TT>Qed.</TT> is slow?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc197">171  Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc198">172  What can I do if I get &#X201C;No more subgoals but non-instantiated existential variables&#X201D;?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc199">173  What can I do if I get &#X201C;Cannot solve a second-order unification problem&#X201D;?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc200">174  Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</A>
</LI><LI CLASS="li-toc"><A HREF="#htoc201">175  I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
to the original term. Sometimes it even says the copied term is not
well-typed.</A>
</LI></UL>
</UL>
</LI><LI CLASS="li-toc"><A HREF="#htoc202">18  Conclusion and Farewell.</A>
<UL CLASS="toc">
<UL CLASS="toc"><LI CLASS="li-toc">
<A HREF="#htoc203">176  What if my question isn't answered here?</A>
</LI></UL>
</UL>
</LI></UL><!--TOC section Introduction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc1">1</A>  Introduction</H2><!--SEC END --><P>
This FAQ is the sum of the questions that came to mind as we developed
proofs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Since we are singularly short-minded, we wrote the
answers we found on bits of papers to have them at hand whenever the
situation occurs again. This is pretty much the result of that: a
collection of tips one can refer to when proofs become intricate. Yes,
this means we won't take the blame for the shortcomings of this
FAQ. But if you want to contribute and send in your own question and
answers, feel free to write to us&#X2026;</P><!--TOC section Presentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc2">2</A>  Presentation</H2><!--SEC END --><!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc3">1</A>  What is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P><A NAME="whatiscoq"></A> 
The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tool is a formal proof management system: a proof done with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> is mechanically checked by the machine. 
In particular, <SPAN STYLE="font-variant:small-caps">Coq</SPAN> allows:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
the definition of mathematical objects and programming objects,
</LI><LI CLASS="li-itemize">to state mathematical theorems and software specifications,
</LI><LI CLASS="li-itemize">to interactively develop formal proofs of these theorems,
</LI><LI CLASS="li-itemize">to check these proofs by a small certification &#X201C;kernel&#X201D;.
</LI></UL><P>
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on a logical framework called &#X201C;Calculus of Inductive
Constructions&#X201D; extended by a modular development system for theories.</P><!--TOC subsubsection Did you really need to name it like that?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc4">2</A>  Did you really need to name it like that?</H4><!--SEC END --><P>
Some French computer scientists have a tradition of naming their
software as animal species: Caml, Elan, Foc or Phox are examples
of this tacit convention. In French, &#X201C;coq&#X201D; means rooster, and it
sounds like the initials of the Calculus of Constructions CoC on which
it is based.</P><!--TOC subsubsection Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc5">3</A>  Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> a theorem prover?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with decision and semi-decision procedures (
propositional calculus, Presburger's arithmetic, ring and field
simplification, resolution, ...) but the main style for proving
theorems is interactively by using LCF-style tactics.</P><!--TOC subsubsection What are the other theorem provers?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc6">4</A>  What are the other theorem provers?</H4><!--SEC END --><P> 
Many other theorem provers are available for use nowadays. 
Isabelle, HOL, HOL Light, Lego, Nuprl, PVS are examples of provers that are fairly similar
to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> by the way they interact with the user. Other relatives of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> are ACL2, Agda/Alfa, Twelf, Kiv, Mizar, NqThm, 
Omega&#X2026;
</P><!--TOC subsubsection What do I have to trust when I see a proof checked by Coq?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc7">5</A>  What do I have to trust when I see a proof checked by Coq?</H4><!--SEC END --><P>You have to trust:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>The theory behind Coq</B></DT><DD CLASS="dd-description"> The theory of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> version 8.0 is
generally admitted to be consistent wrt Zermelo-Fraenkel set theory +
inaccessible cardinals. Proofs of consistency of subsystems of the
theory of Coq can be found in the literature.
</DD><DT CLASS="dt-description"><B>The Coq kernel implementation</B></DT><DD CLASS="dd-description"> You have to trust that the
implementation of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> kernel mirrors the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The
kernel is intentionally small to limit the risk of conceptual or
accidental implementation bugs.
</DD><DT CLASS="dt-description"><B>The Objective Caml compiler</B></DT><DD CLASS="dd-description"> The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> kernel is written using the
Objective Caml language but it uses only the most standard features
(no object, no label ...), so that it is highly unprobable that an
Objective Caml bug breaks the consistency of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> without breaking all
other kinds of features of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> or of other software compiled with
Objective Caml.
</DD><DT CLASS="dt-description"><B>Your hardware</B></DT><DD CLASS="dd-description"> In theory, if your hardware does not work
properly, it can accidentally be the case that False becomes
provable. But it is more likely the case that the whole <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system
will be unusable. You can check your proof using different computers
if you feel the need to.
</DD><DT CLASS="dt-description"><B>Your axioms</B></DT><DD CLASS="dd-description"> Your axioms must be consistent with the theory
behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
</DD></DL><!--TOC subsubsection Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc8">6</A>  Where can I find information about the theory behind <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><DL CLASS="description"><DT CLASS="dt-description">
<B>The Calculus of Inductive Constructions</B></DT><DD CLASS="dd-description"> The
<A HREF="http://coq.inria.fr/doc/Reference-Manual006.html">corresponding</A>
chapter and the chapter on
<A HREF="http://coq.inria.fr/doc/Reference-Manual007.html">modules</A> in
the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> Reference Manual.
</DD><DT CLASS="dt-description"><B>Type theory</B></DT><DD CLASS="dd-description"> A book [<A HREF="#ProofsTypes"><CITE>11</CITE></A>] or some lecture
notes [<A HREF="#Types:Dowek"><CITE>8</CITE></A>].
</DD><DT CLASS="dt-description"><B>Inductive types</B></DT><DD CLASS="dd-description">
Christine Paulin-Mohring's habilitation thesis [<A HREF="#Pau96b"><CITE>19</CITE></A>].
</DD><DT CLASS="dt-description"><B>Co-Inductive types</B></DT><DD CLASS="dd-description">
Eduardo Giménez' thesis [<A HREF="#EGThese"><CITE>9</CITE></A>].
</DD><DT CLASS="dt-description"><B>Miscellaneous</B></DT><DD CLASS="dd-description"> A
<A HREF="http://coq.inria.fr/doc/biblio.html">bibliography</A> about Coq
</DD></DL><!--TOC subsubsection How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc9">7</A>  How can I use <SPAN STYLE="font-variant:small-caps">Coq</SPAN> to prove programs?</H4><!--SEC END --><P>You can either extract a program from a proof by using the extraction
mechanism or use dedicated tools, such as
<A HREF="http://why.lri.fr"><SPAN STYLE="font-variant:small-caps">Why</SPAN></A>,
<A HREF="http://krakatoa.lri.fr"><SPAN STYLE="font-variant:small-caps">Krakatoa</SPAN></A>,
<A HREF="http://why.lri.fr/caduceus/index.en.html"><SPAN STYLE="font-variant:small-caps">Caduceus</SPAN></A>, to prove
annotated programs written in other languages.</P><!--TOC subsubsection How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc10">8</A>  How old is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>The first implementation is from 1985 (it was named <FONT COLOR=purple>CoC</FONT> which is
the acronym of the name of the logic it implemented: the Calculus of
Constructions). The first official release of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (version 4.10)
was distributed in 1989.</P><!--TOC subsubsection What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc11">9</A>  What are the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-related tools?</H4><!--SEC END --><P>There are graphical user interfaces:
</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Coqide</B></DT><DD CLASS="dd-description"> A GTK based GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
</DD><DT CLASS="dt-description"><B>Pcoq</B></DT><DD CLASS="dd-description"> A GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> with proof by pointing and pretty printing.
</DD><DT CLASS="dt-description"><B>coqwc</B></DT><DD CLASS="dd-description"> A tool similar to <TT>wc</TT> to count lines in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files.
</DD><DT CLASS="dt-description"><B>Proof General</B></DT><DD CLASS="dd-description"> A emacs mode for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and many other proof assistants.
</DD></DL><P>There are documentation and browsing tools:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Helm/Mowgli</B></DT><DD CLASS="dd-description"> A rendering, searching and publishing tool.
</DD><DT CLASS="dt-description"><B>coq-tex</B></DT><DD CLASS="dd-description"> A tool to insert <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples within .tex files. 
</DD><DT CLASS="dt-description"><B>coqdoc</B></DT><DD CLASS="dd-description"> A documentation tool for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
</DD></DL><P>There are front-ends for specific languages:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>Why</B></DT><DD CLASS="dd-description"> A back-end generator of verification conditions.
</DD><DT CLASS="dt-description"><B>Krakatoa</B></DT><DD CLASS="dd-description"> A Java code certification tool that uses both <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">Why</SPAN> to verify the soundness of implementations with regards to the specifications.
</DD><DT CLASS="dt-description"><B>Caduceus</B></DT><DD CLASS="dd-description"> A C code certification tool that uses both <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">Why</SPAN>.
</DD><DT CLASS="dt-description"><B>Zenon</B></DT><DD CLASS="dd-description"> A first-order theorem prover.
</DD><DT CLASS="dt-description"><B>Focal</B></DT><DD CLASS="dd-description"> The <A HREF="http://focal.inria.fr">Focal</A> project aims at building an environment to develop certified computer algebra libraries. 
</DD></DL><!--TOC subsubsection What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc12">10</A>  What are the high-level tactics of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Decision of quantifier-free Presburger's Arithmetic
</LI><LI CLASS="li-itemize">Simplification of expressions on rings and fields
</LI><LI CLASS="li-itemize">Decision of closed systems of equations
</LI><LI CLASS="li-itemize">Semi-decision of first-order logic
</LI><LI CLASS="li-itemize">Prolog-style proof search, possibly involving equalities
</LI></UL><!--TOC subsubsection What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc13">11</A>  What are the main libraries available for <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H4><!--SEC END --><UL CLASS="itemize"><LI CLASS="li-itemize">
Basic Peano's arithmetic, binary integer numbers, rational numbers,
</LI><LI CLASS="li-itemize">Real analysis,
</LI><LI CLASS="li-itemize">Libraries for lists, boolean, maps, floating-point numbers,
</LI><LI CLASS="li-itemize">Libraries for relations, sets and constructive algebra,
</LI><LI CLASS="li-itemize">Geometry
</LI></UL><!--TOC subsubsection What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc14">12</A>  What are the mathematical applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> is used for formalizing mathematical theories, for teaching,
and for proving properties of algorithms or programs libraries.</P><P>The largest mathematical formalization has been done at the University
of Nijmegen (see the
<A HREF="http://c-corn.cs.ru.nl">Constructive Coq
Repository at Nijmegen</A>).</P><P>A symbolic step has also been obtained by formalizing in full a proof
of the Four Color Theorem.</P><!--TOC subsubsection What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc15">13</A>  What are the industrial applications for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> is used e.g. to prove properties of the JavaCard system
(especially by Schlumberger and Trusted Logic). It has
also been used to formalize the semantics of the Lucid-Synchrone
data-flow synchronous calculus used by Esterel-Technologies.</P><!--TOC section Documentation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc16">3</A>  Documentation</H2><!--SEC END --><!--TOC subsubsection Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc17">14</A>  Where can I find documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P> 
All the documentation about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, from the reference manual [<A HREF="#Coq:manual"><CITE>17</CITE></A>] to
friendly tutorials [<A HREF="#Coq:Tutorial"><CITE>15</CITE></A>] and documentation of the standard library, is available 
<A HREF="http://coq.inria.fr/doc-eng.html">online</A>.
All these documents are viewable either in browsable HTML, or as
downloadable postscripts.</P><!--TOC subsubsection Where can I find this FAQ on the web?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc18">15</A>  Where can I find this FAQ on the web?</H4><!--SEC END --><P>This FAQ is available online at <A HREF="http://coq.inria.fr/doc/faq.html"><TT>http://coq.inria.fr/doc/faq.html</TT></A>.</P><!--TOC subsubsection How can I submit suggestions / improvements / additions for this FAQ?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc19">16</A>  How can I submit suggestions / improvements / additions for this FAQ?</H4><!--SEC END --><P>This FAQ is unfinished (in the sense that there are some obvious
sections that are missing). Please send contributions to <TT>Florent.Kirchner at lix.polytechnique.fr</TT> and <TT>Julien.Narboux at inria.fr</TT>.</P><!--TOC subsubsection Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc20">17</A>  Is there any mailing list about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P> 
The main <SPAN STYLE="font-variant:small-caps">Coq</SPAN> mailing list is <TT>coq-club@pauillac.inria.fr</TT>, which
broadcasts questions and suggestions about the implementation, the
logical formalism or proof developments. See
<A HREF="http://coq.inria.fr/mailman/listinfo/coq-club"><TT>http://pauillac.inria.fr/mailman/listinfo/coq-club</TT></A> for
subscription. For bugs reports see question <A HREF="#coqbug">22</A>.</P><!--TOC subsubsection Where can I find an archive of the list?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc21">18</A>  Where can I find an archive of the list?</H4><!--SEC END --><P>
The archives of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> mailing list are available at
<A HREF="http://pauillac.inria.fr/pipermail/coq-club"><TT>http://coq.inria.fr/pipermail/coq-club</TT></A>.</P><!--TOC subsubsection How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc22">19</A>  How can I be kept informed of new releases of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>New versions of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> are announced on the coq-club mailing list. If you only want to receive information about new releases, you can subscribe to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> on <A HREF="http://freshmeat.net/projects/coq/"><TT>http://freshmeat.net/projects/coq/</TT></A>.</P><!--TOC subsubsection Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc23">20</A>  Is there any book about <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>The first book on <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, Yves Bertot and Pierre Castéran's Coq'Art has been published by Springer-Verlag in 2004:
</P><BLOCKQUOTE CLASS="quote">
&#X201C;This book provides a pragmatic introduction to the development of
proofs and certified programs using <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. With its large collection of
examples and exercises it is an invaluable tool for researchers,
students, and engineers interested in formal methods and the
development of zero-default software.&#X201D;
</BLOCKQUOTE><!--TOC subsubsection Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc24">21</A>  Where can I find some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> examples?</H4><!--SEC END --><P>There are examples in the manual [<A HREF="#Coq:manual"><CITE>17</CITE></A>] and in the
Coq'Art [<A HREF="#Coq:coqart"><CITE>2</CITE></A>] exercises <A HREF="http://www.labri.fr/Perso/~casteran/CoqArt/index.html"><TT>http://www.labri.fr/Perso/~casteran/CoqArt/index.html</TT></A>.
You can also find large developments using
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> in the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> user contributions:
<A HREF="http://coq.inria.fr/contrib-eng.html"><TT>http://coq.inria.fr/contrib-eng.html</TT></A>.</P><!--TOC subsubsection How can I report a bug?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc25">22</A>  How can I report a bug?</H4><!--SEC END --><P><A NAME="coqbug"></A></P><P>You can use the web interface accessible at <A HREF="http://coq.inria.fr"><TT>http://coq.inria.fr</TT></A>, link &#X201C;contacts&#X201D;.</P><!--TOC section Installation-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc26">4</A>  Installation</H2><!--SEC END --><!--TOC subsubsection What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc27">23</A>  What is the license of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> is distributed under the GNU Lesser General License
(LGPL).</P><!--TOC subsubsection Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc28">24</A>  Where can I find the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>
The sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can be found online in the tar.gz'ed packages
(<A HREF="http://coq.inria.fr"><TT>http://coq.inria.fr</TT></A>, link
&#X201C;download&#X201D;). Development sources can be accessed at
<A HREF="http://coq.gforge.inria.fr/"><TT>http://coq.gforge.inria.fr/</TT></A></P><!--TOC subsubsection On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc29">25</A>  On which platform is <SPAN STYLE="font-variant:small-caps">Coq</SPAN> available?</H4><!--SEC END --><P>
Compiled binaries are available for Linux, MacOS X, and Windows. The
sources can be easily compiled on all platforms supporting Objective
Caml.</P><!--TOC section The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc30">5</A>  The logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN></H2><!--SEC END --><!--TOC subsection General-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc31">5.1</A>  General</H3><!--SEC END --><!--TOC subsubsection What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc32">26</A>  What is the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> is based on an axiom-free type theory called
the Calculus of Inductive Constructions (see Coquand [<A HREF="#CoHu86"><CITE>6</CITE></A>],
Luo [<A HREF="#Luo90"><CITE>16</CITE></A>]
and Coquand&#X2013;Paulin-Mohring [<A HREF="#CoPa89"><CITE>7</CITE></A>]). It includes higher-order
functions and predicates, inductive and co-inductive datatypes and
predicates, and a stratified hierarchy of sets.</P><!--TOC subsubsection Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc33">27</A>  Is <SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic intuitionistic or classical?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN>'s logic is modular. The core logic is intuitionistic
(i.e. excluded-middle <I>A</I>&#X2228;¬ <I>A</I> is not granted by default). It can
be extended to classical logic on demand by requiring an
optional module stating <I>A</I>&#X2228;¬ <I>A</I>.</P><!--TOC subsubsection Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc34">28</A>  Can I define non-terminating programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>All programs in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> are terminating. Especially, loops
must come with an evidence of their termination. </P><P>Non-terminating programs can be simulated by passing around a
bound on how long the program is allowed to run before dying.</P><!--TOC subsubsection How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc35">29</A>  How is equational reasoning working in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with an internal notion of computation called
<EM>conversion</EM> (e.g. (<I>x</I>+1)+<I>y</I> is internally equivalent to
(<I>x</I>+<I>y</I>)+1; similarly applying argument <I>a</I> to a function mapping <I>x</I>
to some expression <I>t</I> converts to the expression <I>t</I> where <I>x</I> is
replaced by <I>a</I>). This notion of conversion (which is decidable
because <SPAN STYLE="font-variant:small-caps">Coq</SPAN> programs are terminating) covers a certain part of
equational reasoning but is limited to sequential evaluation of
expressions of (not necessarily closed) programs. Besides conversion,
equations have to be treated by hand or using specialised tactics.</P><!--TOC subsection Axioms-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc36">5.2</A>  Axioms</H3><!--SEC END --><!--TOC subsubsection What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc37">30</A>  What axioms can be safely added to <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>There are a few typical useful axioms that are independent from the
Calculus of Inductive Constructions and that can be safely added to
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. These axioms are stated in the directory <TT>Logic</TT> of the
standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The most interesting ones are</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Excluded-middle: &#X2200; <I>A</I>:<I>Prop</I>, <I>A</I> &#X2228; ¬ <I>A</I>
</LI><LI CLASS="li-itemize">Proof-irrelevance: &#X2200; <I>A</I>:<I>Prop</I> &#X2200; <I>p</I><SUB>1</SUB> <I>p</I><SUB>2</SUB>:<I>A</I>, <I>p</I><SUB>1</SUB>=<I>p</I><SUB>2</SUB>
</LI><LI CLASS="li-itemize">Unicity of equality proofs (or equivalently Streicher's axiom <I>K</I>):
&#X2200; <I>A</I> &#X2200; <I>x</I> <I>y</I>:<I>A</I> &#X2200; <I>p</I><SUB>1</SUB> <I>p</I><SUB>2</SUB>:<I>x</I>=<I>y</I>, <I>p</I><SUB>1</SUB>=<I>p</I><SUB>2</SUB>
</LI><LI CLASS="li-itemize">The axiom of unique choice: &#X2200; <I>x</I> &#X2203;! <I>y</I> <I>R</I>(<I>x</I>,<I>y</I>) &#X2192; &#X2203; <I>f</I> &#X2200; <I>x</I> <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
</LI><LI CLASS="li-itemize">The functional axiom of choice: &#X2200; <I>x</I> &#X2203; <I>y</I> <I>R</I>(<I>x</I>,<I>y</I>) &#X2192; &#X2203; <I>f</I> &#X2200; <I>x</I> <I>R</I>(<I>x</I>,<I>f</I>(<I>x</I>))
</LI><LI CLASS="li-itemize">Extensionality of predicates: &#X2200; <I>P</I> <I>Q</I>:<I>A</I>&#X2192; <I>Prop</I>, (&#X2200; <I>x</I>, <I>P</I>(<I>x</I>) &#X2194; <I>Q</I>(<I>x</I>)) &#X2192; <I>P</I>=<I>Q</I>
</LI><LI CLASS="li-itemize">Extensionality of functions: &#X2200; <I>f</I> <I>g</I>:<I>A</I>&#X2192; <I>B</I>, (&#X2200; <I>x</I>, <I>f</I>(<I>x</I>)=<I>g</I>(<I>x</I>)) &#X2192; <I>f</I>=<I>g</I>
</LI></UL><P>Here is a summary of the relative strength of these axioms, most
proofs can be found in directory <TT>Logic</TT> of the standard library.
The justification of their validity relies on the interpretability in
set theory.</P><P><IMG SRC="axioms.png">
</P><!--TOC subsubsection What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc38">31</A>  What standard axioms are inconsistent with <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>The axiom of unique choice together with classical logic
(e.g. excluded-middle) are inconsistent in the variant of the Calculus
of Inductive Constructions where <TT>Set</TT> is impredicative.</P><P>As a consequence, the functional form of the axiom of choice and
excluded-middle, or any form of the axiom of choice together with
predicate extensionality are inconsistent in the <TT>Set</TT>-impredicative
version of the Calculus of Inductive Constructions.</P><P>The main purpose of the <TT>Set</TT>-predicative restriction of the Calculus
of Inductive Constructions is precisely to accommodate these axioms
which are quite standard in mathematical usage.</P><P>The <TT><I>Set</I></TT>-predicative system is commonly considered consistent by
interpreting it in a standard set-theoretic boolean model, even with
classical logic, axiom of choice and predicate extensionality added.</P><!--TOC subsubsection What is Streicher's axiom <I>K</I>-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc39">32</A>  What is Streicher's axiom <I>K</I></H4><!--SEC END --><P>
<A NAME="Streicher"></A></P><P>Streicher's axiom <I>K</I> [<A HREF="#HofStr98"><CITE>13</CITE></A>] is an axiom that asserts
dependent elimination of reflexive equality proofs.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom Streicher_K :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (A:Type) (x:A) (P: x=x -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     P (refl_equal x) -</TT><TT>&gt;</TT><TT> forall p: x=x, P p.</TT><BR>
</DIV><P>In the general case, axiom <I>K</I> is an independent statement of the
Calculus of Inductive Constructions. However, it is true on decidable
domains (see file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html"><TT>Eqdep_dec</TT><TT>.v</TT></A>). It is also
trivially a consequence of proof-irrelevance (see
<A HREF="#proof-irrelevance">33</A>) hence of classical logic.</P><P>Axiom <I>K</I> is equivalent to <EM>Uniqueness of Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>13</CITE></A>]</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom UIP : forall (A:Set) (x y:A) (p1 p2: x=y), p1 = p2.</TT><BR>
</DIV><P>Axiom <I>K</I> is also equivalent to <EM>Uniqueness of Reflexive Identity Proofs</EM> [<A HREF="#HofStr98"><CITE>13</CITE></A>]</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom UIP_refl : forall (A:Set) (x:A) (p: x=x), p = refl_equal x.</TT><BR>
</DIV><P>Axiom <I>K</I> is also equivalent to </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   eq_rec_eq :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall (A:Set) (x:A) (P: A-</TT><TT>&gt;</TT><TT>Set) (p:P x) (h: x=x),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       p = eq_rect x P p x h.</TT><BR>
</DIV><P>It is also equivalent to the injectivity of dependent equality (dependent equality is itself equivalent to equality of dependent pairs).</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive eq_dep (U:Set) (P:U -</TT><TT>&gt;</TT><TT> Set) (p:U) (x:P p) :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> forall q:U, P q -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     eq_dep_intro : eq_dep U P p x p x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Axiom</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   eq_dep_eq :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall (U:Set) (u:U) (P:U -</TT><TT>&gt;</TT><TT> Set) (p1 p2:P u),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       eq_dep U P u p1 u p2 -</TT><TT>&gt;</TT><TT> p1 = p2.</TT><BR>
</DIV><!--TOC subsubsection What is proof-irrelevance-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc40">33</A>  What is proof-irrelevance</H4><!--SEC END --><P>
<A NAME="proof-irrelevance"></A></P><P>A specificity of the Calculus of Inductive Constructions is to permit
statements about proofs. This leads to the question of comparing two
proofs of the same proposition. Identifying all proofs of the same
proposition is called <EM>proof-irrelevance</EM>:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">&#X2200; <I>A</I>:<TT><I>Prop</I></TT>, &#X2200; <I>p</I> <I>q</I>:<I>A</I>, <I>p</I>=<I>q</I>
</TD></TR>
</TABLE><P>Proof-irrelevance (in <TT>Prop</TT>) can be assumed without contradiction in
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. It expresses that only provability matters, whatever the exact
form of the proof is. This is in harmony with the common purely
logical interpretation of <TT>Prop</TT>. Contrastingly, proof-irrelevance is
inconsistent in <TT>Set</TT> since there are types in <TT>Set</TT>, such as the
type of booleans, that are provably more than 2 elements.</P><P>Proof-irrelevance (in <TT>Prop</TT>) is a consequence of classical logic
(see proofs in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Classical.html"><TT>Classical</TT><TT>.v</TT></A> and
<A HREF="http://coq.inria.fr/library/Coq.Logic.Berardi.html"><TT>Berardi</TT><TT>.v</TT></A>). Proof-irrelevance is also a
consequence of propositional extensionality (i.e. <TT>(A </TT><TT>&lt;-&gt;</TT><TT> B)
</TT><TT>-&gt;</TT><TT> A=B</TT>, see the proof in file
<A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalFacts.html"><TT>ClassicalFacts</TT><TT>.v</TT></A>).</P><P>Proof-irrelevance directly implies Streicher's axiom <I>K</I>.</P><!--TOC subsubsection What about functional extensionality?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc41">34</A>  What about functional extensionality?</H4><!--SEC END --><P>Extensionality of functions is admittedly consistent with the
Set-predicative Calculus of Inductive Constructions.</P><P>Let <TT>A</TT>, <TT>B</TT> be types. To deal with extensionality on 
<CODE>A-&gt;B</CODE> without relying on a general extensionality axiom, 
a possible approach is to define one's own extensional equality on
<CODE>A-&gt;B</CODE>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition ext_eq (f g: A-</TT><TT>&gt;</TT><TT>B) := forall x:A, f x = g x.</TT><BR>
</DIV><P>and to reason on <CODE>A-&gt;B</CODE> as a setoid (see the Chapter on
Setoids in the Reference Manual).</P><!--TOC subsubsection Is <TT>Prop</TT> impredicative?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc42">35</A>  Is <TT>Prop</TT> impredicative?</H4><!--SEC END --><P>Yes, the sort <TT>Prop</TT> of propositions is <EM>impredicative</EM>. Otherwise said, a statement of the form &#X2200;
<I>A</I>:<I>Prop</I>, <I>P</I>(<I>A</I>) can be instantiated by itself: if &#X2200; <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)
is provable, then <I>P</I>(&#X2200; <I>A</I>:<TT><I>Prop</I></TT>, <I>P</I>(<I>A</I>)) is.</P><!--TOC subsubsection Is <TT>Set</TT> impredicative?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc43">36</A>  Is <TT>Set</TT> impredicative?</H4><!--SEC END --><P>No, the sort <TT>Set</TT> lying at the bottom of the hierarchy of
computational types is <EM>predicative</EM> in the basic <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system.
This means that a family of types in <TT>Set</TT>, e.g. &#X2200; <I>A</I>:<TT><I>Set</I></TT>, <I>A</I>
&#X2192; <I>A</I>, is not a type in <TT>Set</TT> and it cannot be applied on
itself.</P><P>However, the sort <TT>Set</TT> was impredicative in the original versions of
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>. For backward compatibility, or for experiments by
knowledgeable users, the logic of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> can be set impredicative for
<TT>Set</TT> by calling <SPAN STYLE="font-variant:small-caps">Coq</SPAN> with the option <TT>-impredicative-set</TT>.</P><P><TT>Set</TT> has been made predicative from version 8.0 of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. The main
reason is to interact smoothly with a classical mathematical world
where both excluded-middle and the axiom of description are valid (see
file <A HREF="http://coq.inria.fr/library/Coq.Logic.ClassicalDescription.html"><TT>ClassicalDescription</TT><TT>.v</TT></A> for a
proof that excluded-middle and description implies the double negation
of excluded-middle in <TT>Set</TT> and file <TT>Hurkens_Set.v</TT> from the
user contribution <TT>Rocq/PARADOXES</TT> for a proof that
impredicativity of <TT>Set</TT> implies the simple negation of
excluded-middle in <TT>Set</TT>).</P><!--TOC subsubsection Is <TT>Type</TT> impredicative?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc44">37</A>  Is <TT>Type</TT> impredicative?</H4><!--SEC END --><P>No, <TT>Type</TT> is stratified. This is hidden for the
user, but <SPAN STYLE="font-variant:small-caps">Coq</SPAN> internally maintains a set of constraints ensuring
stratification.</P><P>If <TT>Type</TT> were impredicative then it would be possible to encode
Girard's systems <I>U</I>&#X2212; and <I>U</I> in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and it is known from Girard,
Coquand, Hurkens and Miquel that systems <I>U</I>&#X2212; and <I>U</I> are inconsistent
[Girard 1972, Coquand 1991, Hurkens 1993, Miquel 2001]. This encoding
can be found in file <TT>Logic/Hurkens.v</TT> of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library.</P><P>For instance, when the user see <TT>&#X2200;</TT><TT> X:Type, X-&gt;X : Type</TT>, each
occurrence of <TT>Type</TT> is implicitly bound to a different level, say
&#X3B1; and &#X3B2; and the actual statement is <TT>forall X:Type(</TT><TT>&#X3B1;</TT><TT>), X-&gt;X : Type(</TT><TT>&#X3B2;</TT><TT>)</TT> with the constraint
&#X3B1;&lt;&#X3B2;.</P><P>When a statement violates a constraint, the message <TT>Universe
inconsistency</TT> appears. Example: <TT>fun (x:Type) (y:</TT><TT>&#X2200;</TT><TT> X:Type, X
</TT><TT>-&gt;</TT><TT> X) =&gt; y x x</TT>.</P><!--TOC subsubsection I have two proofs of the same proposition. Can I prove they are equal?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc45">38</A>  I have two proofs of the same proposition. Can I prove they are equal?</H4><!--SEC END --><P>In the base <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system, the answer is generally no. However, if
classical logic is set, the answer is yes for propositions in <TT>Prop</TT>.
The answer is also yes if proof irrelevance holds (see question
<A HREF="#proof-irrelevance">33</A>).</P><P>There are also &#X201C;simple enough&#X201D; propositions for which you can prove
the equality without requiring any extra axioms. This is typically
the case for propositions defined deterministically as a first-order
inductive predicate on decidable sets. See for instance in question
<A HREF="#le-uniqueness">138</A> an axiom-free proof of the unicity of the proofs of
the proposition <TT>le m n</TT> (less or equal on <TT>nat</TT>).</P><!--TOC subsubsection I have two proofs of an equality statement. Can I prove they are 
equal?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc46">39</A>  I have two proofs of an equality statement. Can I prove they are 
equal?</H4><!--SEC END --><P>Yes, if equality is decidable on the domain considered (which
is the case for <TT>nat</TT>, <TT>bool</TT>, etc): see <SPAN STYLE="font-variant:small-caps">Coq</SPAN> file
<CODE>Eqdep_dec.v</CODE>). No otherwise, unless
assuming Streicher's axiom <I>K</I> (see [<A HREF="#HofStr98"><CITE>13</CITE></A>]) or a more general
assumption such as proof-irrelevance (see <A HREF="#proof-irrelevance">33</A>) or
classical logic.</P><P>All of these statements can be found in file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html"><TT>Eqdep</TT><TT>.v</TT></A>.</P><!--TOC subsubsection Can I prove that the second components of equal dependent
pairs are equal?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc47">40</A>  Can I prove that the second components of equal dependent
pairs are equal?</H4><!--SEC END --><P>The answer is the same as for proofs of equality
statements. It is provable if equality on the domain of the first
component is decidable (look at <CODE>inj_right_pair</CODE> from file
<A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep_dec.html"><TT>Eqdep_dec</TT><TT>.v</TT></A>), but not provable in the general
case. However, it is consistent (with the Calculus of Constructions)
to assume it is true. The file <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html"><TT>Eqdep</TT><TT>.v</TT></A> actually
provides an axiom (equivalent to Streicher's axiom <I>K</I>) which entails
the result (look at <CODE>inj_pair2</CODE> in <A HREF="http://coq.inria.fr/library/Coq.Logic.Eqdep.html"><TT>Eqdep</TT><TT>.v</TT></A>).</P><!--TOC subsection Impredicativity-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc48">5.3</A>  Impredicativity</H3><!--SEC END --><!--TOC subsubsection Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc49">41</A>  Why <TT>injection</TT> does not work on impredicative <TT>Set</TT>?</H4><!--SEC END --><P>E.g. in this case (this occurs only in the <TT>Set</TT>-impredicative
variant of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>):</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive I : Type :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intro : forall k:Set, k -</TT><TT>&gt;</TT><TT> I.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma eq_jdef : </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall x y:nat, intro _ x = intro _ y -</TT><TT>&gt;</TT><TT> x = y.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    intros x y H; injection H.</TT><BR>
</DIV><P>Injectivity of constructors is restricted to predicative types. If
injectivity on large inductive types were not restricted, we would be
allowed to derive an inconsistency (e.g. following the lines of
Burali-Forti paradox). The question remains open whether injectivity
is consistent on some large inductive types not expressive enough to
encode known paradoxes (such as type I above).</P><!--TOC subsubsection What is a &#X201C;large inductive definition&#X201D;?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc50">42</A>  What is a &#X201C;large inductive definition&#X201D;?</H4><!--SEC END --><P>An inductive definition in <TT>Prop</TT> or <TT>Set</TT> is called large
if its constructors embed sets or propositions. As an example, here is
a large inductive type:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sigST (P:Set -</TT><TT>&gt;</TT><TT> Set) : Type :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   existST : forall X:Set, P X -</TT><TT>&gt;</TT><TT> sigST P.</TT><BR>
</DIV><P>In the <TT>Set</TT> impredicative variant of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, large inductive
definitions in <TT>Set</TT> have restricted elimination schemes to
prevent inconsistencies. Especially, projecting the set or the
proposition content of a large inductive definition is forbidden. If
it were allowed, it would be possible to encode e.g. Burali-Forti
paradox [<A HREF="#Gir70"><CITE>10</CITE></A><CITE>, </CITE><A HREF="#Coq85"><CITE>5</CITE></A>].</P><!--TOC section Talkin' with the Rooster-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc51">6</A>  Talkin' with the Rooster</H2><!--SEC END --><!--TOC subsection My goal is ..., how can I prove it?-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc52">6.1</A>  My goal is ..., how can I prove it?</H3><!--SEC END --><!--TOC subsubsection My goal is a conjunction, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc53">43</A>  My goal is a conjunction, how can I prove it?</H4><!--SEC END --><P>Use some theorem or assumption or use the <TT>split</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B:Prop, A-</TT><TT>&gt;</TT><TT>B-</TT><TT>&gt;</TT><TT> A/</TT><TT>\</TT><TT>B.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> split.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I> assumption.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal contains a conjunction as an hypothesis, how can I use it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc54">44</A>  My goal contains a conjunction as an hypothesis, how can I use it?</H4><!--SEC END --><P>If you want to decompose your hypothesis into other hypothesis you can use the <TT>decompose</TT> tactic:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B:Prop, A/</TT><TT>\</TT><TT>B-</TT><TT>&gt;</TT><TT> B.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, A /</I></TT><TT><I>\</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> decompose [and] H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : A</I></TT><BR>
<TT><I>  H1 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>decompose [and] H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm0 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is a disjunction, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc55">45</A>  My goal is a disjunction, how can I prove it?</H4><!--SEC END --><P>You can prove the left part or the right part of the disjunction using
<TT>left</TT> or <TT>right</TT> tactics. If you want to do a classical
reasoning step, use the <TT>classic</TT> axiom to prove the right part with the assumption
that the left part of the disjunction is false.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B:Prop, A-</TT><TT>&gt;</TT><TT> A</TT><TT>\</TT><TT>/B.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> left.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>left.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1 is defined</I></TT><BR>
</DIV><P>An example using classical reasoning:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Classical.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac classical_right := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> match goal with </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> | _:_ |-?X1 </TT><TT>\</TT><TT>/ _ =</TT><TT>&gt;</TT><TT> (elim (classic X1);intro;[left;trivial|right])</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> end.</TT><BR>
<TT><I>classical_right is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac classical_left := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> match goal with </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> | _:_ |- _ </TT><TT>\</TT><TT>/?X1 =</TT><TT>&gt;</TT><TT> (elim (classic X1);intro;[right;trivial|left])</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> end.</TT><BR>
<TT><I>classical_left is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B:Prop, (</TT><TT>~</TT><TT>A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> A</TT><TT>\</TT><TT>/B.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, (</I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A </I></TT><TT><I>\</I></TT><TT><I>/ B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> classical_right.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : </I></TT><TT><I>~</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : </I></TT><TT><I>~</I></TT><TT><I> A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>classical_right.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm2 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an universally quantified statement, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc56">46</A>  My goal is an universally quantified statement, how can I prove it?</H4><!--SEC END --><P>Use some theorem or assumption or introduce the quantified variable in
the context using the <TT>intro</TT> tactic. If there are several
variables you can use the <TT>intros</TT> tactic. A good habit is to
provide names for these variables: <SPAN STYLE="font-variant:small-caps">Coq</SPAN> will do it anyway, but such
automatic naming decreases legibility and robustness.</P><!--TOC subsubsection My goal is an existential, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc57">47</A>  My goal is an existential, how can I prove it?</H4><!--SEC END --><P>Use some theorem or assumption or exhibit the witness using the <TT>exists</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal exists x:nat, forall y, x+y=y.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   exists x : nat, forall y : nat, x + y = y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exists 0.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall y : nat, 0 + y = y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 + y = y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>exists 0.</I></TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm3 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is solvable by some lemma, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc58">48</A>  My goal is solvable by some lemma, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>apply</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma mylemma : forall x, x+0 = x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x : nat, x + 0 = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>mylemma is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal 3+0 = 3.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   3 + 0 = 3</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply mylemma.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>apply mylemma.</I></TT><BR>
<TT><I>Unnamed_thm is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal contains False as an hypothesis, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc59">49</A>  My goal contains False as an hypothesis, how can I prove it?</H4><!--SEC END --><P>You can use the <TT>contradiction</TT> or <TT>intuition</TT> tactics.</P><!--TOC subsubsection My goal is an equality of two convertible terms, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc60">50</A>  My goal is an equality of two convertible terms, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>reflexivity</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x, 0+x = x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x : nat, 0 + x = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   0 + x = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> reflexivity.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>reflexivity.</I></TT><BR>
<TT><I>Unnamed_thm0 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is a <TT>let x := a in ...</TT>, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc61">51</A>  My goal is a <TT>let x := a in ...</TT>, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>intro</TT> tactic.</P><!--TOC subsubsection My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc62">52</A>  My goal is a <TT>let (a, ..., b) := c in</TT>, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>destruct</TT> c as (a,...,b) tactic.</P><!--TOC subsubsection My goal contains some existential hypotheses, how can I use it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc63">53</A>  My goal contains some existential hypotheses, how can I use it?</H4><!--SEC END --><P>You can use the tactic <TT>elim</TT> with you hypotheses as an argument.</P><!--TOC subsubsection My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc64">54</A>  My goal contains some existential hypotheses, how can I use it and decompose my knowledge about this new thing into different hypotheses?</H4><!--SEC END --><PRE CLASS="verbatim">Ltac DecompEx H P := elim H;intro P;intro TO;decompose [and] TO;clear TO;clear H.
</PRE><!--TOC subsubsection My goal is an equality, how can I swap the left and right hand terms?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc65">55</A>  My goal is an equality, how can I swap the left and right hand terms?</H4><!--SEC END --><P>Just use the <TT>symmetry</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y : nat, x=y -</TT><TT>&gt;</TT><TT> y=x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> y = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> symmetry.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = y</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry  in |- *.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm1 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My hypothesis is an equality, how can I swap the left and right hand terms?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc66">56</A>  My hypothesis is an equality, how can I swap the left and right hand terms?</H4><!--SEC END --><P>Just use the <TT>symmetryin</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y : nat, x=y -</TT><TT>&gt;</TT><TT> y=x.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> y = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> symmetry in H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  H : y = x</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = x</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>symmetry  in H.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm2 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an equality, how can I prove it by transitivity?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc67">57</A>  My goal is an equality, how can I prove it by transitivity?</H4><!--SEC END --><P>Just use the <TT>transitivity</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y z : nat, x=y -</TT><TT>&gt;</TT><TT> y=z -</TT><TT>&gt;</TT><TT> x=z.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> y = z -</I></TT><TT><I>&gt;</I></TT><TT><I> x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> transitivity y.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = y</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> y = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity y.</I></TT><BR>
<TT><I> assumption.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm3 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc68">58</A>  My goal would be solvable using <TT>apply;assumption</TT> if it would not create meta-variables, how can I prove it?</H4><!--SEC END --><P>You can use <TT>eapply yourtheorem;eauto</TT> but it won't work in all cases ! (for example if more than one hypothesis match one of the subgoals generated by <TT>eapply</TT>) so you should rather use <TT>try solve [eapply yourtheorem;eauto]</TT>, otherwise some metavariables may be incorrectly instantiated.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma trans : forall x y z : nat, x=y -</TT><TT>&gt;</TT><TT> y=z -</TT><TT>&gt;</TT><TT> x=z.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> y = z -</I></TT><TT><I>&gt;</I></TT><TT><I> x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> transitivity y;assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>transitivity y; assumption.</I></TT><BR>
<TT><I>trans is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y z : nat, x=y -</TT><TT>&gt;</TT><TT> y=z -</TT><TT>&gt;</TT><TT> x=z.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> y = z -</I></TT><TT><I>&gt;</I></TT><TT><I> x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eapply trans;eauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> eapply trans;  eauto.</I></TT><BR>
<TT><I>Unnamed_thm4 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y z t : nat, x=y -</TT><TT>&gt;</TT><TT> x=t -</TT><TT>&gt;</TT><TT> y=z -</TT><TT>&gt;</TT><TT> x=z.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z t : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> x = t -</I></TT><TT><I>&gt;</I></TT><TT><I> y = z -</I></TT><TT><I>&gt;</I></TT><TT><I> x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eapply trans;eauto.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   t = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Undo.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eapply trans.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = ?47</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> ?47 = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> eapply trans.</I></TT><BR>
<TT><I> </I></TT><BR>
<TT><I>   apply H.</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  auto.</I></TT><BR>
<TT><I>Unnamed_thm5 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y z t : nat, x=y -</TT><TT>&gt;</TT><TT> x=t -</TT><TT>&gt;</TT><TT> y=z -</TT><TT>&gt;</TT><TT> x=z.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall x y z t : nat, x = y -</I></TT><TT><I>&gt;</I></TT><TT><I> x = t -</I></TT><TT><I>&gt;</I></TT><TT><I> y = z -</I></TT><TT><I>&gt;</I></TT><TT><I> x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eapply trans;eauto.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   t = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Undo.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> try solve [eapply trans;eauto].</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> eapply trans.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x = ?54</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> ?54 = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : nat</I></TT><BR>
<TT><I>  y : nat</I></TT><BR>
<TT><I>  z : nat</I></TT><BR>
<TT><I>  t : nat</I></TT><BR>
<TT><I>  H : x = y</I></TT><BR>
<TT><I>  H0 : x = t</I></TT><BR>
<TT><I>  H1 : y = z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   y = z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>try (solve [  eapply trans;  eauto ]).</I></TT><BR>
<TT><I> eapply trans.</I></TT><BR>
<TT><I> </I></TT><BR>
<TT><I>   apply H.</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  auto.</I></TT><BR>
<TT><I>Unnamed_thm6 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
</DIV><!--TOC subsubsection My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc69">59</A>  My goal is solvable by some lemma within a set of lemmas and I don't want to remember which one, how can I prove it?</H4><!--SEC END --><P>You can use a what is called a hints' base.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import ZArith.</TT><BR>
<TT><I>Coq </I></TT><TT><I>&lt;</I></TT><TT><I> </I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Ring.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Local Scope Z_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma toto1 : 1+1 = 2.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   1 + 1 = 2</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> ring.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> ring.</I></TT><BR>
<TT><I>toto1 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma toto2 : 2+2 = 4.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   2 + 2 = 4</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> ring.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> ring.</I></TT><BR>
<TT><I>toto2 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma toto3 : 2+1 = 3.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   2 + 1 = 3</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> ring.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> ring.</I></TT><BR>
<TT><I>toto3 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Resolve toto1 toto2 toto3 : mybase.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal 2+(1+1)=4. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   2 + (1 + 1) = 4</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto with mybase.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>auto with mybase.</I></TT><BR>
<TT><I>Unnamed_thm7 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is one of the hypotheses, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc70">60</A>  My goal is one of the hypotheses, how can I prove it?</H4><!--SEC END --><P>Use the <TT>assumption</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal 1=1 -</TT><TT>&gt;</TT><TT> 1=1.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   1 = 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> 1 = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 1 = 1</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   1 = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>assumption.</I></TT><BR>
<TT><I>Unnamed_thm8 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc71">61</A>  My goal appears twice in the hypotheses and I want to choose which one is used, how can I do it?</H4><!--SEC END --><P>Use the <TT>exact</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal 1=1 -</TT><TT>&gt;</TT><TT> 1=1 -</TT><TT>&gt;</TT><TT> 1=1.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   1 = 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> 1 = 1 -</I></TT><TT><I>&gt;</I></TT><TT><I> 1 = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  H : 1 = 1</I></TT><BR>
<TT><I>  H0 : 1 = 1</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   1 = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> exact H0.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>exact H0.</I></TT><BR>
<TT><I>Unnamed_thm9 is defined</I></TT><BR>
</DIV><!--TOC subsubsection What can be the difference between applying one hypothesis or another in the context of the last question?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc72">62</A>  What can be the difference between applying one hypothesis or another in the context of the last question?</H4><!--SEC END --><P>From a proof point of view it is equivalent but if you want to extract
a program from your proof, the two hypotheses can lead to different
programs.</P><!--TOC subsubsection My goal is a propositional tautology, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc73">63</A>  My goal is a propositional tautology, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>tauto</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B:Prop, A-</TT><TT>&gt;</TT><TT> (A</TT><TT>\</TT><TT>/B) /</TT><TT>\</TT><TT> A.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> (A </I></TT><TT><I>\</I></TT><TT><I>/ B) /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A </I></TT><TT><I>\</I></TT><TT><I>/ B) /</I></TT><TT><I>\</I></TT><TT><I> A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> tauto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> tauto.</I></TT><BR>
<TT><I>Unnamed_thm10 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is a first order formula, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc74">64</A>  My goal is a first order formula, how can I prove it?</H4><!--SEC END --><P>Just use the semi-decision tactic: <TT>firstorder</TT>.</P><!--TOC subsubsection My goal is solvable by a sequence of rewrites, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc75">65</A>  My goal is solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>congruence</TT> tactic.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a b c d e, a=d -</TT><TT>&gt;</TT><TT> b=e -</TT><TT>&gt;</TT><TT> c+b=d -</TT><TT>&gt;</TT><TT> c+e=a.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b c d e : Z, a = d -</I></TT><TT><I>&gt;</I></TT><TT><I> b = e -</I></TT><TT><I>&gt;</I></TT><TT><I> c + b = d -</I></TT><TT><I>&gt;</I></TT><TT><I> c + e = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : Z</I></TT><BR>
<TT><I>  b : Z</I></TT><BR>
<TT><I>  c : Z</I></TT><BR>
<TT><I>  d : Z</I></TT><BR>
<TT><I>  e : Z</I></TT><BR>
<TT><I>  H : a = d</I></TT><BR>
<TT><I>  H0 : b = e</I></TT><BR>
<TT><I>  H1 : c + b = d</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   c + e = a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> congruence.</I></TT><BR>
<TT><I>Unnamed_thm11 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is a disequality solvable by a sequence of rewrites, how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc76">66</A>  My goal is a disequality solvable by a sequence of rewrites, how can I prove it?</H4><!--SEC END --><P>Just use the <TT>congruence</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a b c d, a</TT><TT>&lt;</TT><TT>&gt;</TT><TT>d -</TT><TT>&gt;</TT><TT> b=a -</TT><TT>&gt;</TT><TT> d=c+b -</TT><TT>&gt;</TT><TT> b</TT><TT>&lt;</TT><TT>&gt;</TT><TT>c+b.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b c d : Z, a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> d -</I></TT><TT><I>&gt;</I></TT><TT><I> b = a -</I></TT><TT><I>&gt;</I></TT><TT><I> d = c + b -</I></TT><TT><I>&gt;</I></TT><TT><I> b </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> c + b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : Z</I></TT><BR>
<TT><I>  b : Z</I></TT><BR>
<TT><I>  c : Z</I></TT><BR>
<TT><I>  d : Z</I></TT><BR>
<TT><I>  H : a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> d</I></TT><BR>
<TT><I>  H0 : b = a</I></TT><BR>
<TT><I>  H1 : d = c + b</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   b </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> c + b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> congruence.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> congruence.</I></TT><BR>
<TT><I>Unnamed_thm12 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an equality on some ring (e.g. natural numbers), how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc77">67</A>  My goal is an equality on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END --><P>Just use the <TT>ring</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import ZArith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Ring.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Local Scope Z_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a b : Z, (a+b)*(a+b) = a*a + 2*a*b + b*b. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b : Z, (a + b) * (a + b) = a * a + 2 * a * b + b * b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : Z</I></TT><BR>
<TT><I>  b : Z</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (a + b) * (a + b) = a * a + 2 * a * b + b * b</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> ring.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> ring.</I></TT><BR>
<TT><I>Unnamed_thm13 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an equality on some field (e.g. real numbers), how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc78">68</A>  My goal is an equality on some field (e.g. real numbers), how can I prove it?</H4><!--SEC END --><P>Just use the <TT>field</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Ring.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Local Scope R_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a b : R, b*a</TT><TT>&lt;</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> (a/b) * (b/a) = 1. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b : R, b * a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> a / b * (b / a) = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : R</I></TT><BR>
<TT><I>  b : R</I></TT><BR>
<TT><I>  H : b * a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   a / b * (b / a) = 1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> field.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : R</I></TT><BR>
<TT><I>  b : R</I></TT><BR>
<TT><I>  H : b * a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   a </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0 /</I></TT><TT><I>\</I></TT><TT><I> b </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Toplevel input, characters 0-10</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I> assumption.</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I> </I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><BR>
<TT><I>User error: No such assumption</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> field.</I></TT><BR>
<TT><I>&lt;</I></TT><TT><I>Your Tactic Text here</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>User error: Attempt to save an incomplete proof</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc79">69</A>  My goal is an inequality on integers in Presburger's arithmetic (an expression build from +,-,constants and variables), how can I prove it?</H4><!--SEC END --><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import ZArith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Omega.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Local Scope Z_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a : Z, a</TT><TT>&gt;</TT><TT>0 -</TT><TT>&gt;</TT><TT> a+a </TT><TT>&gt;</TT><TT> a. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a : Z, a </I></TT><TT><I>&gt;</I></TT><TT><I> 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> a + a </I></TT><TT><I>&gt;</I></TT><TT><I> a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  a : Z</I></TT><BR>
<TT><I>  H : a </I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   a + a </I></TT><TT><I>&gt;</I></TT><TT><I> a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> omega.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I> omega.</I></TT><BR>
<TT><I>Unnamed_thm15 is defined</I></TT><BR>
</DIV><!--TOC subsubsection My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc80">70</A>  My goal is an equation solvable using equational hypothesis on some ring (e.g. natural numbers), how can I prove it?</H4><!--SEC END --><P>You need the <TT>gb</TT> tactic (see Loïc Pottier's homepage).</P><!--TOC subsection Tactics usage-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc81">6.2</A>  Tactics usage</H3><!--SEC END --><!--TOC subsubsection I want to state a fact that I will use later as an hypothesis, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc82">71</A>  I want to state a fact that I will use later as an hypothesis, how can I do it?</H4><!--SEC END --><P>If you want to use forward reasoning (first proving the fact and then
using it) you just need to use the <TT>assert</TT> tactic. If you want to use
backward reasoning (proving your goal using an assumption and then
proving the assumption) use the <TT>cut</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B C D : Prop, (A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> (B-</TT><TT>&gt;</TT><TT>C) -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> C. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, Prop -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> (B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assert (A-</TT><TT>&gt;</TT><TT>C).</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro;apply H0;apply H;assumption.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  H2 : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply H2.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  H2 : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>assert (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C).</I></TT><BR>
<TT><I> intro; apply H0; apply H; assumption.</I></TT><BR>
<TT><I>apply H2.</I></TT><BR>
<TT><I>  assumption.</I></TT><BR>
<TT><I>Unnamed_thm16 is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B C D : Prop, (A -</TT><TT>&gt;</TT><TT> B) -</TT><TT>&gt;</TT><TT> (B-</TT><TT>&gt;</TT><TT>C) -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> C. </TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, Prop -</I></TT><TT><I>&gt;</I></TT><TT><I> (A -</I></TT><TT><I>&gt;</I></TT><TT><I> B) -</I></TT><TT><I>&gt;</I></TT><TT><I> (B -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> cut (A-</TT><TT>&gt;</TT><TT>C).</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C) -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  H2 : A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply H2;assumption.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  D : Prop</I></TT><BR>
<TT><I>  H : A -</I></TT><TT><I>&gt;</I></TT><TT><I> B</I></TT><BR>
<TT><I>  H0 : B -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro;apply H0;apply H;assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>cut (A -</I></TT><TT><I>&gt;</I></TT><TT><I> C).</I></TT><BR>
<TT><I> intro.</I></TT><BR>
<TT><I>   apply H2; assumption.</I></TT><BR>
<TT><I>intro; apply H0; apply H; assumption.</I></TT><BR>
<TT><I>Unnamed_thm17 is defined</I></TT><BR>
</DIV><!--TOC subsubsection I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc83">72</A>  I want to state a fact that I will use later as an hypothesis and prove it later, how can I do it?</H4><!--SEC END --><P>You can use <TT>cut</TT> followed by <TT>intro</TT> or you can use the following <SPAN STYLE="font-variant:small-caps">Ltac</SPAN> command:
</P><PRE CLASS="verbatim">Ltac assert_later t := cut t;[intro|idtac]. 
</PRE><!--TOC subsubsection What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc84">73</A>  What is the difference between <TT>Qed</TT> and <TT>Defined</TT>?</H4><!--SEC END --><P>These two commands perform type checking, but when <TT>Defined</TT> is used the new definition is set as transparent, otherwise it is defined as opaque (see <A HREF="#opaque">169</A>).</P><!--TOC subsubsection How can I know what a tactic does?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc85">74</A>  How can I know what a tactic does?</H4><!--SEC END --><P>You can use the <TT>info</TT> command.</P><!--TOC subsubsection Why <TT>auto</TT> does not work? How can I fix it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc86">75</A>  Why <TT>auto</TT> does not work? How can I fix it?</H4><!--SEC END --><P>You can increase the depth of the proof search or add some lemmas in the base of hints.
Perhaps you may need to use <TT>eauto</TT>.</P><!--TOC subsubsection What is <TT>eauto</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc87">76</A>  What is <TT>eauto</TT>?</H4><!--SEC END --><P>This is the same tactic as <TT>auto</TT>, but it relies on <TT>eapply</TT> instead of <TT>apply</TT>.</P><!--TOC subsubsection How can I speed up <TT>auto</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc88">77</A>  How can I speed up <TT>auto</TT>?</H4><!--SEC END --><P>You can use <TT>info </TT><TT>auto</TT>to replace <TT>auto</TT> by the tactics it generates.
You can split your hint bases into smaller ones.</P><!--TOC subsubsection What is the equivalent of <TT>tauto</TT> for classical logic?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc89">78</A>  What is the equivalent of <TT>tauto</TT> for classical logic?</H4><!--SEC END --><P>Currently there are no equivalent tactic for classical logic. You can use Gödel's &#X201C;not not&#X201D; translation.</P><!--TOC subsubsection I want to replace some term with another in the goal, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc90">79</A>  I want to replace some term with another in the goal, how can I do it?</H4><!--SEC END --><P>If one of your hypothesis (say <TT>H</TT>) states that the terms are equal you can use the <TT>rewrite</TT> tactic. Otherwise you can use the <TT>replace</TT> <TT>with</TT> tactic. </P><!--TOC subsubsection I want to replace some term with another in an hypothesis, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc91">80</A>  I want to replace some term with another in an hypothesis, how can I do it?</H4><!--SEC END --><P>You can use the <TT>rewrite</TT> <TT>in</TT> tactic.</P><!--TOC subsubsection I want to replace some symbol with its definition, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc92">81</A>  I want to replace some symbol with its definition, how can I do it?</H4><!--SEC END --><P>You can use the <TT>unfold</TT> tactic.</P><!--TOC subsubsection How can I reduce some term?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc93">82</A>  How can I reduce some term?</H4><!--SEC END --><P>You can use the <TT>simpl</TT> tactic.</P><!--TOC subsubsection How can I declare a shortcut for some term?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc94">83</A>  How can I declare a shortcut for some term?</H4><!--SEC END --><P>You can use the <TT>set</TT> or <TT>pose</TT> tactics.</P><!--TOC subsubsection How can I perform case analysis?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc95">84</A>  How can I perform case analysis?</H4><!--SEC END --><P>You can use the <TT>case</TT> or <TT>destruct</TT> tactics.</P><!--TOC subsubsection Why should I name my intros?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc96">85</A>  Why should I name my intros?</H4><!--SEC END --><P>When you use the <TT>intro</TT> tactic you don't have to give a name to your
hypothesis. If you do so the name will be generated by <SPAN STYLE="font-variant:small-caps">Coq</SPAN> but your
scripts may be less robust. If you add some hypothesis to your theorem
(or change their order), you will have to change your proof to adapt
to the new names.</P><!--TOC subsubsection How can I automatize the naming?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc97">86</A>  How can I automatize the naming?</H4><!--SEC END --><P>You can use the <TT>Show Intro.</TT> or <TT>Show Intros.</TT> commands to generate the names and use your editor to generate a fully named <TT>intro</TT> tactic. 
This can be automatized within <TT>xemacs</TT>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B C : Prop, A -</TT><TT>&gt;</TT><TT> B -</TT><TT>&gt;</TT><TT> C -</TT><TT>&gt;</TT><TT> A/</TT><TT>\</TT><TT>B/</TT><TT>\</TT><TT>C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> C -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Show Intros.</TT><BR>
<TT><I>A B C H H0 H1</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> (*</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> A B C H H0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> H1</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros A B C H H0 H1.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  H1 : C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> repeat split;assumption.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros A B C H H0 H1.</I></TT><BR>
<TT><I>repeat split; assumption.</I></TT><BR>
<TT><I>Unnamed_thm18 is defined</I></TT><BR>
</DIV><!--TOC subsubsection I want to automatize the use of some tactic, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc98">87</A>  I want to automatize the use of some tactic, how can I do it?</H4><!--SEC END --><P>You need to use the <TT>proof with T</TT> command and add &#X2026; at the
end of your sentences.</P><P>For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B C : Prop, A -</TT><TT>&gt;</TT><TT> B/</TT><TT>\</TT><TT>C -</TT><TT>&gt;</TT><TT> A/</TT><TT>\</TT><TT>B/</TT><TT>\</TT><TT>C.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B C : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof with assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  C : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B /</I></TT><TT><I>\</I></TT><TT><I> C</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B /</I></TT><TT><I>\</I></TT><TT><I> C</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> split...</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>split...</I></TT><BR>
<TT><I>Unnamed_thm19 is defined</I></TT><BR>
</DIV><!--TOC subsubsection I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc99">88</A>  I want to execute the <TT>p</TT>roof with tactic only if it solves the goal, how can I do it?</H4><!--SEC END --><P>You need to use the <TT>try</TT> and <TT>solve</TT> tactics. For instance:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import ZArith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Ring.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Local Scope Z_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall a b c : Z, a+b=b+a.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall a b : Z, Z -</I></TT><TT><I>&gt;</I></TT><TT><I> a + b = b + a</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof with try solve [ring].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros...</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros...</I></TT><BR>
<TT><I>Unnamed_thm20 is defined</I></TT><BR>
</DIV><!--TOC subsubsection How can I do the opposite of the <TT>intro</TT> tactic?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc100">89</A>  How can I do the opposite of the <TT>intro</TT> tactic?</H4><!--SEC END --><P>You can use the <TT>generalize</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall A B : Prop, A-</TT><TT>&gt;</TT><TT>B-</TT><TT>&gt;</TT><TT> A/</TT><TT>\</TT><TT>B.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall A B : Prop, A -</I></TT><TT><I>&gt;</I></TT><TT><I> B -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> generalize H.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A -</I></TT><TT><I>&gt;</I></TT><TT><I> A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  A : Prop</I></TT><BR>
<TT><I>  B : Prop</I></TT><BR>
<TT><I>  H : A</I></TT><BR>
<TT><I>  H0 : B</I></TT><BR>
<TT><I>  H1 : A</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   A /</I></TT><TT><I>\</I></TT><TT><I> B</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros.</I></TT><BR>
<TT><I>generalize H.</I></TT><BR>
<TT><I>intro.</I></TT><BR>
<TT><I>auto.</I></TT><BR>
<TT><I>Unnamed_thm21 is defined</I></TT><BR>
</DIV><!--TOC subsubsection One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc101">90</A>  One of the hypothesis is an equality between a variable and some term, I want to get rid of this variable, how can I do it?</H4><!--SEC END --><P>You can use the <TT>subst</TT> tactic. This will rewrite the equality everywhere and clear the assumption.</P><!--TOC subsubsection What can I do if I get &#X201C;<TT>generated subgoal term has metavariables in it </TT>&#X201D;?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc102">91</A>  What can I do if I get &#X201C;<TT>generated subgoal term has metavariables in it </TT>&#X201D;?</H4><!--SEC END --><P>You should use the <TT>eapply</TT> tactic, this will generate some goals containing metavariables. </P><!--TOC subsubsection How can I instantiate some metavariable?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc103">92</A>  How can I instantiate some metavariable?</H4><!--SEC END --><P>Just use the <TT>instantiate</TT> tactic.</P><!--TOC subsubsection What is the use of the <TT>pattern</TT> tactic?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc104">93</A>  What is the use of the <TT>pattern</TT> tactic?</H4><!--SEC END --><P>The <TT>pattern</TT> tactic transforms the current goal, performing
beta-expansion on all the applications featuring this tactic's
argument. For instance, if the current goal includes a subterm <TT>phi(t)</TT>, then <TT>pattern t</TT> transforms the subterm into <TT>(fun
x:A =&gt; phi(x)) t</TT>. This can be useful when <TT>apply</TT> fails on matching,
to abstract the appropriate terms.</P><!--TOC subsubsection What is the difference between assert, cut and generalize?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc105">94</A>  What is the difference between assert, cut and generalize?</H4><!--SEC END --><P>PS: Notice for people that are interested in proof rendering that <TT>assert</TT>and <TT>pose</TT> (and <TT>cut</TT>) are not rendered the same as <TT>generalize</TT> (see the
HELM experimental rendering tool at <A HREF="http://helm.cs.unibo.it/library.html"><TT>http://helm.cs.unibo.it</TT></A>, link
HELM, link COQ Online). Indeed <TT>generalize</TT> builds a beta-expanded term
while <TT>assert</TT>, <TT>pose</TT> and <TT>cut</TT> uses a let-in.</P><PRE CLASS="verbatim">  (* Goal is T *)
  generalize (H1 H2).
  (* Goal is A-&gt;T *)
  ... a proof of A-&gt;T ...
</PRE><P>is rendered into something like
</P><PRE CLASS="verbatim">  (h) ... the proof of A-&gt;T ...
      we proved A-&gt;T
  (h0) by (H1 H2) we proved A
  by (h h0) we proved T
</PRE><P>while 
</P><PRE CLASS="verbatim">  (* Goal is T *)
  assert q := (H1 H2).
  (* Goal is A *)
  ... a proof of A ...
  (* Goal is A |- T *)
  ... a proof of T ...
</PRE><P>is rendered into something like
</P><PRE CLASS="verbatim">  (q) ... the proof of A ...
      we proved A
  ... the proof of T ...
  we proved T
</PRE><P>Otherwise said, <TT>generalize</TT> is not rendered in a forward-reasoning way,
while <TT>assert</TT> is.</P><!--TOC subsubsection What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc106">95</A>  What can I do if <SPAN STYLE="font-variant:small-caps">Coq</SPAN>can not infer some implicit argument ?</H4><!--SEC END --><P>You can state explicitely what this implicit argument is. See <A HREF="#implicit">96</A>.</P><!--TOC subsubsection How can I explicit some implicit argument ?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc107">96</A>  How can I explicit some implicit argument ?</H4><!--SEC END --><P><A NAME="implicit"></A></P><P>Just use <TT>A:=term</TT> where <TT>A</TT> is the argument.</P><P>For instance if you want to use the existence of &#X201C;nil&#X201D; on nat*nat lists:
</P><PRE CLASS="verbatim">exists (nil (A:=(nat*nat))).
</PRE><!--TOC subsection Proof management-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc108">6.3</A>  Proof management</H3><!--SEC END --><!--TOC subsubsection How can I change the order of the subgoals?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc109">97</A>  How can I change the order of the subgoals?</H4><!--SEC END --><P>You can use the <TT>Focus</TT> command to concentrate on some goal. When the goal is proved you will see the remaining goals.</P><!--TOC subsubsection How can I change the order of the hypothesis?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc110">98</A>  How can I change the order of the hypothesis?</H4><!--SEC END --><P>You can use the <TT>Move ... after</TT> command.</P><!--TOC subsubsection How can I change the name of an hypothesis?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc111">99</A>  How can I change the name of an hypothesis?</H4><!--SEC END --><P>You can use the <TT>Rename ... into</TT> command.</P><!--TOC subsubsection How can I delete some hypothesis?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc112">100</A>  How can I delete some hypothesis?</H4><!--SEC END --><P>You can use the <TT>Clear</TT> command.</P><!--TOC subsubsection How can use a proof which is not finished?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc113">101</A>  How can use a proof which is not finished?</H4><!--SEC END --><P>You can use the <TT>Admitted</TT> command to state your current proof as an axiom.</P><!--TOC subsubsection How can I state a conjecture?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc114">102</A>  How can I state a conjecture?</H4><!--SEC END --><P>You can use the <TT>Admitted</TT> command to state your current proof as an axiom.</P><!--TOC subsubsection What is the difference between a lemma, a fact and a theorem?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc115">103</A>  What is the difference between a lemma, a fact and a theorem?</H4><!--SEC END --><P>From <SPAN STYLE="font-variant:small-caps">Coq</SPAN> point of view there are no difference. But some tools can
have a different behavior when you use a lemma rather than a
theorem. For instance <TT>coqdoc</TT> will not generate documentation for
the lemmas within your development.</P><!--TOC subsubsection How can I organize my proofs?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc116">104</A>  How can I organize my proofs?</H4><!--SEC END --><P>You can organize your proofs using the section mechanism of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Have
a look at the manual for further information.</P><!--TOC section Inductive and Co-inductive types-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc117">7</A>  Inductive and Co-inductive types</H2><!--SEC END --><!--TOC subsection General-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc118">7.1</A>  General</H3><!--SEC END --><!--TOC subsubsection How can I prove that two constructors are different?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc119">105</A>  How can I prove that two constructors are different?</H4><!--SEC END --><P>You can use the <TT>discriminate</TT> tactic.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive toto : Set := | C1 : toto | C2 : toto.</TT><BR>
<TT><I>toto is defined</I></TT><BR>
<TT><I>toto_rect is defined</I></TT><BR>
<TT><I>toto_ind is defined</I></TT><BR>
<TT><I>toto_rec is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal C1 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> C2.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   C1 </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> C2</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> discriminate.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I> discriminate.</I></TT><BR>
<TT><I>Unnamed_thm22 is defined</I></TT><BR>
</DIV><!--TOC subsubsection During an inductive proof, how to get rid of impossible cases of an inductive definition?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc120">106</A>  During an inductive proof, how to get rid of impossible cases of an inductive definition?</H4><!--SEC END --><P>Use the <TT>inversion</TT> tactic.</P><!--TOC subsubsection How can I prove that 2 terms in an inductive set are equal? Or different?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc121">107</A>  How can I prove that 2 terms in an inductive set are equal? Or different?</H4><!--SEC END --><P>Have a look at <TT>decide equality</TT> and <TT>discriminate</TT> in the <A HREF="http://coq.inria.fr/doc/main.html">Reference Manual</A>.</P><!--TOC subsubsection Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc122">108</A>  Why is the proof of <TT>0+n=n</TT> on natural numbers
trivial but the proof of <TT>n+0=n</TT> is not?</H4><!--SEC END --><P>Since <TT>+</TT> (<TT>plus</TT>) on natural numbers is defined by analysis on its first argument</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Print plus.</TT><BR>
<TT><I>plus = </I></TT><BR>
<TT><I>fix plus (n m : nat) {struct n} : nat :=</I></TT><BR>
<TT><I>  match n with</I></TT><BR>
<TT><I>  | 0%nat =</I></TT><TT><I>&gt;</I></TT><TT><I> m</I></TT><BR>
<TT><I>  | S p =</I></TT><TT><I>&gt;</I></TT><TT><I> S (p + m)</I></TT><BR>
<TT><I>  end</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>Argument scopes are [nat_scope nat_scope]</I></TT><BR>
</DIV><P> The expression <TT>0+n</TT> evaluates to <TT>n</TT>. As <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reasons
modulo evaluation of expressions, <TT>0+n</TT> and <TT>n</TT> are
considered equal and the theorem <TT>0+n=n</TT> is an instance of the
reflexivity of equality. On the other side, <TT>n+0</TT> does not
evaluate to <TT>n</TT> and a proof by induction on <TT>n</TT> is
necessary to trigger the evaluation of <TT>+</TT>.</P><!--TOC subsubsection Why is dependent elimination in Prop not
available by default?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc123">109</A>  Why is dependent elimination in Prop not
available by default?</H4><!--SEC END --><P>This is just because most of the time it is not needed. To derive a
dependent elimination principle in <TT>Prop</TT>, use the command <TT>Scheme</TT> and
apply the elimination scheme using the <CODE>using</CODE> option of
<CODE>elim</CODE>, <CODE>destruct</CODE> or <CODE>induction</CODE>.</P><!--TOC subsubsection Argh! I cannot write expressions like &#X201C; <TT>if n &lt;= p then p else n</TT> &#X201D;, as in any programming language-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc124">110</A>  Argh! I cannot write expressions like &#X201C; <TT>if n &lt;= p then p else n</TT> &#X201D;, as in any programming language</H4><!--SEC END --><P>
<A NAME="minmax"></A></P><P>The short answer : You should use <TT>l</TT>e_lt_dec n p instead.<BR>

That's right, you can't.
If you type for instance the following &#X201C;definition&#X201D;:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition max (n p : nat) := if n </TT><TT>&lt;</TT><TT>= p then p else n.</TT><BR>
<TT><I>Toplevel input, characters 33-39</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I> Definition max (n p : nat) := if n </I></TT><TT><I>&lt;</I></TT><TT><I>= p then p else n.</I></TT><BR>
<TT><I>&gt;</I></TT><TT><I>                                  </I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><TT><I>^</I></TT><BR>
<TT><I>Error: The term "n </I></TT><TT><I>&lt;</I></TT><TT><I>= p" has type "Prop" which is not a (co-)inductive type</I></TT><BR>
</DIV><P>As <SPAN STYLE="font-variant:small-caps">Coq</SPAN>  says, the term &#X201C; <TT>n &lt;= p</TT> &#X201D; is a proposition, i.e. a
statement that belongs to the mathematical world. There are many ways to
prove such a proposition, either by some computation, or using some already
proven theoremas. For instance, proving 3&#X2212;2 &#X2264; 2<SUP>45503</SUP> is very easy,
using some theorems on arithmetical operations. If you compute both numbers
before comparing them, you risk to use a lot of time and space.</P><P>On the contrary, a function for computing the greatest of two natural numbers
is an algorithm which, called on two natural numbers
<I>n</I> and <I>p</I>, determines wether <I>n</I>&#X2264; <I>p</I> or <I>p</I> &lt; <I>n</I>.
Such a function is a <EM>decision procedure</EM> for the inequality of
<TT>nat</TT>. The possibility of writing such a procedure comes 
directly from de decidability of the order &#X2264; on natural numbers.</P><P>When you write a piece of code like 
&#X201C; <TT>if n &lt;= p then &#X2026; else &#X2026;</TT> &#X201D;
in a
programming language like <EM>ML</EM> or <EM>Java</EM>, a call to such a 
decision procedure is generated. The decision procedure is in general
a primitive function, written in a low-level language, in the correctness
of which you have to trust.</P><P>The standard Library of the system <EM>Coq</EM> contains a 
(constructive) proof of decidability of the order &#X2264; on
<TT>nat</TT> : the function <TT>le_lt_dec</TT> of 
the module <TT>Compare_dec</TT> of library <TT>Arith</TT>.</P><P>The following code shows how to define correctly <TT>min</TT> and
<TT>max</TT>, and prove some properties of these functions.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Compare_dec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition max (n p : nat) := if le_lt_dec n p then p else n.</TT><BR>
<TT><I>max is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition min (n p : nat) := if le_lt_dec n p then n else p.</TT><BR>
<TT><I>min is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Eval compute in (min 4 7).</TT><BR>
<TT><I>     = 4</I></TT><BR>
<TT><I>     : nat</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem min_plus_max : forall n p, min n p + max n p  = n + p.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n p : nat, min n p + max n p = n + p</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  intros n p; </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  unfold min, max; </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  case (le_lt_dec n p);</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  simpl; auto with arith.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intros n p; unfold min, max in |- *; case (le_lt_dec n p); simpl in |- *;</I></TT><BR>
<TT><I> auto with arith.</I></TT><BR>
<TT><I>min_plus_max is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem max_equiv : forall n p, max n p = p </TT><TT>&lt;</TT><TT>-</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= p.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n p : nat, max n p = p </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  unfold max; intros n p; case (le_lt_dec n p);simpl; auto.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n </I></TT><TT><I>&lt;</I></TT><TT><I>= p -</I></TT><TT><I>&gt;</I></TT><TT><I> (p = p </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p)</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> p </I></TT><TT><I>&lt;</I></TT><TT><I> n -</I></TT><TT><I>&gt;</I></TT><TT><I> (n = p </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  intuition auto with arith.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   p </I></TT><TT><I>&lt;</I></TT><TT><I> n -</I></TT><TT><I>&gt;</I></TT><TT><I> (n = p </I></TT><TT><I>&lt;</I></TT><TT><I>-</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p)</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  split. </TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  l : p </I></TT><TT><I>&lt;</I></TT><TT><I> n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n = p -</I></TT><TT><I>&gt;</I></TT><TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> n </I></TT><TT><I>&lt;</I></TT><TT><I>= p -</I></TT><TT><I>&gt;</I></TT><TT><I> n = p</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  intro e; rewrite e; auto with arith.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  p : nat</I></TT><BR>
<TT><I>  l : p </I></TT><TT><I>&lt;</I></TT><TT><I> n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   n </I></TT><TT><I>&lt;</I></TT><TT><I>= p -</I></TT><TT><I>&gt;</I></TT><TT><I> n = p</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  intro H; absurd (p </TT><TT>&lt;</TT><TT> p); eauto with arith.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>unfold max in |- *; intros n p; case (le_lt_dec n p); simpl in |- *; auto.</I></TT><BR>
<TT><I>  intuitionauto with arith.</I></TT><BR>
<TT><I>split.</I></TT><BR>
<TT><I> intro e; rewrite e in |- *; auto with arith.</I></TT><BR>
<TT><I>intro H;  absurd (p </I></TT><TT><I>&lt;</I></TT><TT><I> p);  eauto with arith.</I></TT><BR>
<TT><I>max_equiv is defined</I></TT><BR>
</DIV><!--TOC subsubsection I wrote my own decision procedure for &#X2264;, which
is much faster than yours, but proving such theorems as
<TT>max_equiv</TT> seems to be quite difficult-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc125">111</A>  I wrote my own decision procedure for &#X2264;, which
is much faster than yours, but proving such theorems as
<TT>max_equiv</TT> seems to be quite difficult</H4><!--SEC END --><P>Your code is probably the following one:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint my_le_lt_dec (n p :nat) {struct n}: bool  :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  match n, p with 0, _ =</TT><TT>&gt;</TT><TT> true</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                | S n', S p' =</TT><TT>&gt;</TT><TT> my_le_lt_dec n' p'</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                | _   , _    =</TT><TT>&gt;</TT><TT> false</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  end.</TT><BR>
<TT><I>my_le_lt_dec is recursively defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition my_max (n p:nat) := if my_le_lt_dec n p then p else n.</TT><BR>
<TT><I>my_max is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition my_min (n p:nat) := if my_le_lt_dec n p then n else p.</TT><BR>
<TT><I>my_min is defined</I></TT><BR>
</DIV><P>For instance, the computation of <TT>my_max 567 321</TT> is almost
immediate, whereas one can't wait for the result of 
<TT>max 56 32</TT>, using <EM>Coq's</EM> <TT>le_lt_dec</TT>.</P><P>This is normal. Your definition is a simple recursive function which
returns a boolean value. Coq's <TT>le_lt_dec</TT> is a <EM>certified
function</EM>, i.e. a complex object, able not only to tell wether <I>n</I>&#X2264; <I>p</I>
or <I>p</I>&lt;<I>n</I>, but also of building a complete proof of the correct inequality.
What make <TT>le_lt_dec</TT> inefficient for computing <TT>min</TT>
and <TT>max</TT> is the building of a huge proof term.</P><P>Nevertheless, <TT>le_lt_dec</TT> is very useful. Its type 
is a strong specification, using the
<TT>sumbool</TT> type (look at the reference manual or chapter 9 of
[<A HREF="#coqart"><CITE>1</CITE></A>]). Eliminations of the form
&#X201C; <TT>case (le_lt_dec n p)</TT> &#X201D; provide proofs of
either <I>n</I> &#X2264; <I>p</I> or <I>p</I> &lt; <I>n</I>, allowing to prove easily theorems as in
question <A HREF="#minmax">110</A>. Unfortunately, this not the case of your
<TT>my_le_lt_dec</TT>, which returns a quite non-informative boolean
value.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Check le_lt_dec.</TT><BR>
<TT><I>le_lt_dec</I></TT><BR>
<TT><I>     : forall n m : nat, {n </I></TT><TT><I>&lt;</I></TT><TT><I>= m} + {m </I></TT><TT><I>&lt;</I></TT><TT><I> n}</I></TT><BR>
</DIV><P>You should keep in mind that <TT>le_lt_dec</TT> is useful to build
certified programs which need to compare natural numbers, and is not
designed to compare quickly two numbers.</P><P>Nevertheless, the <EM>extraction</EM> of <TT>le_lt_dec</TT> towards 
<EM>Ocaml</EM> or <EM>Haskell</EM>, is a reasonable program for comparing two
natural numbers in Peano form in linear time.</P><P>It is also possible to keep your boolean function as a decision procedure,
but you have to establish yourself the relationship between <TT>my_le_lt_dec</TT> and the propositions <I>n</I>&#X2264; <I>p</I> and <I>p</I>&lt;<I>n</I>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem my_le_lt_dec_true : </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall n p, my_le_lt_dec n p = true </TT><TT>&lt;</TT><TT>-</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= p.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem  my_le_lt_dec_false : </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall n p, my_le_lt_dec n p = false </TT><TT>&lt;</TT><TT>-</TT><TT>&gt;</TT><TT> p </TT><TT>&lt;</TT><TT> n.</TT><BR>
</DIV><!--TOC subsection Recursion-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc126">7.2</A>  Recursion</H3><!--SEC END --><!--TOC subsubsection Why can't I define a non terminating program?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc127">112</A>  Why can't I define a non terminating program?</H4><!--SEC END --><P>Because otherwise the decidability of the type-checking
algorithm (which involves evaluation of programs) is not ensured. On
another side, if non terminating proofs were allowed, we could get a
proof of <TT>False</TT>:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> (* This is fortunately not allowed! *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint InfiniteProof (n:nat) : False := InfiniteProof n.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem Paradox : False.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof (InfiniteProof O).</TT><BR>
</DIV><!--TOC subsubsection Why only structurally well-founded loops are allowed?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc128">113</A>  Why only structurally well-founded loops are allowed?</H4><!--SEC END --><P>The structural order on inductive types is a simple and
powerful notion of termination. The consistency of the Calculus of
Inductive Constructions relies on it and another consistency proof
would have to be made for stronger termination arguments (such
as the termination of the evaluation of CIC programs themselves!).</P><P>In spite of this, all non-pathological termination orders can be mapped
to a structural order. Tools to do this are provided in the file 
<A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html"><TT>Wf</TT><TT>.v</TT></A> of the standard library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><!--TOC subsubsection How to define loops based on non structurally smaller
recursive calls?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc129">114</A>  How to define loops based on non structurally smaller
recursive calls?</H4><!--SEC END --><P>The procedure is as follows (we consider the definition of <TT>mergesort</TT> as an example).</P><UL CLASS="itemize"><LI CLASS="li-itemize">Define the termination order, say <TT>R</TT> on the type <TT>A</TT> of
the arguments of the loop.<DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition R (a b:list nat) := length a </TT><TT>&lt;</TT><TT> length b.</TT><BR>
</DIV></LI><LI CLASS="li-itemize">Prove that this order is well-founded (in fact that all elements in <TT>A</TT> are accessible along <TT>R</TT>).<DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Rwf : well_founded R.</TT><BR>
</DIV></LI><LI CLASS="li-itemize">Define the step function (which needs proofs that recursive
calls are on smaller arguments).<DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition split (l : list nat) </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    : {l1: list nat | R l1 l} * {l2 : list nat | R l2 l}</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    := (* ... *) .</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition concat (l1 l2 : list nat) : list nat := (* ... *) .</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition merge_step (l : list nat) (f: forall l':list nat, R l' l -</TT><TT>&gt;</TT><TT> list nat) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   let (lH1,lH2) := (split l) in</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   let (l1,H1) := lH1 in</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   let (l2,H2) := lH2 in</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   concat (f l1 H1) (f l2 H2).</TT><BR>
</DIV></LI><LI CLASS="li-itemize">Define the recursive function by fixpoint on the step function.<DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition merge := Fix Rwf (fun _ =</TT><TT>&gt;</TT><TT> list nat) merge_step.</TT><BR>
</DIV></LI></UL><!--TOC subsubsection What is behind the accessibility and well-foundedness proofs?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc130">115</A>  What is behind the accessibility and well-foundedness proofs?</H4><!--SEC END --><P>Well-foundedness of some relation <TT>R</TT> on some type <TT>A</TT>
is defined as the accessibility of all elements of <TT>A</TT> along <TT>R</TT>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Print well_founded.</TT><BR>
<TT><I>well_founded = </I></TT><BR>
<TT><I>fun (A : Type) (R : A -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop) =</I></TT><TT><I>&gt;</I></TT><TT><I> forall a : A, Acc R a</I></TT><BR>
<TT><I>     : forall A : Type, (A -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop) -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>Argument A is implicit</I></TT><BR>
<TT><I>Argument scopes are [type_scope _]</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print Acc.</TT><BR>
<TT><I>Inductive Acc (A : Type) (R : A -</I></TT><TT><I>&gt;</I></TT><TT><I> A -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop) (x : A) : Prop :=</I></TT><BR>
<TT><I>    Acc_intro : (forall y : A, R y x -</I></TT><TT><I>&gt;</I></TT><TT><I> Acc R y) -</I></TT><TT><I>&gt;</I></TT><TT><I> Acc R x</I></TT><BR>
<TT><I>For Acc: Argument A is implicit</I></TT><BR>
<TT><I>For Acc_intro: Arguments A, R are implicit</I></TT><BR>
<TT><I>For Acc: Argument scopes are [type_scope _ _]</I></TT><BR>
<TT><I>For Acc_intro: Argument scopes are [type_scope _ _ _]</I></TT><BR>
</DIV><P>The structure of the accessibility predicate is a well-founded tree
branching at each node <TT>x</TT> in <TT>A</TT> along all the nodes <TT>x'</TT>
less than <TT>x</TT> along <TT>R</TT>. Any sequence of elements of <TT>A</TT>
decreasing along the order <TT>R</TT> are branches in the accessibility
tree. Hence any decreasing along <TT>R</TT> is mapped into a structural
decreasing in the accessibility tree of <TT>R</TT>. This is emphasised in
the definition of <TT>fix</TT> which recurs not on its argument <TT>x:A</TT>
but on the accessibility of this argument along <TT>R</TT>.</P><P>See file <A HREF="http://coq.inria.fr/library/Coq.Init.Wf.html"><TT>Wf</TT><TT>.v</TT></A>.</P><!--TOC subsubsection How to perform simultaneous double induction?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc131">116</A>  How to perform simultaneous double induction?</H4><!--SEC END --><P>In general a (simultaneous) double induction is simply solved by an
induction on the first hypothesis followed by an inversion over the
second hypothesis. Here is an example</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive even : nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | even_O : even 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | even_S : forall n:nat, even n -</TT><TT>&gt;</TT><TT> even (S (S n)).</TT><BR>
<TT><I>even is defined</I></TT><BR>
<TT><I>even_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive odd : nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | odd_SO : odd 1</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | odd_S : forall n:nat, odd n -</TT><TT>&gt;</TT><TT> odd (S (S n)).</TT><BR>
<TT><I>odd is defined</I></TT><BR>
<TT><I>odd_ind is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma not_even_and_odd : forall n:nat, even n -</TT><TT>&gt;</TT><TT> odd n -</TT><TT>&gt;</TT><TT> False.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, even n -</I></TT><TT><I>&gt;</I></TT><TT><I> odd n -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction 1.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   odd 0 -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> odd (S (S n)) -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   inversion 1.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : even n</I></TT><BR>
<TT><I>  IHeven : odd n -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   odd (S (S n)) -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   inversion 1. apply IHeven; trivial.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  H : even n</I></TT><BR>
<TT><I>  IHeven : odd n -</I></TT><TT><I>&gt;</I></TT><TT><I> False</I></TT><BR>
<TT><I>  H0 : odd (S (S n))</I></TT><BR>
<TT><I>  n0 : nat</I></TT><BR>
<TT><I>  H2 : odd n</I></TT><BR>
<TT><I>  H1 : n0 = n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   False</I></TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><P>In case the type of the second induction hypothesis is not
dependent, <TT>inversion</TT> can just be replaced by <TT>destruct</TT>.</P><!--TOC subsubsection How to define a function by simultaneous double recursion?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc132">117</A>  How to define a function by simultaneous double recursion?</H4><!--SEC END --><P>The same trick applies, you can even use the pattern-matching
compilation algorithm to do the work for you. Here is an example:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint minus (n m:nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n, m with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | O, _ =</TT><TT>&gt;</TT><TT> 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S k, O =</TT><TT>&gt;</TT><TT> S k</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S k, S l =</TT><TT>&gt;</TT><TT> minus k l</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<TT><I>minus is recursively defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Print  minus.</TT><BR>
<TT><I>minus = </I></TT><BR>
<TT><I>fix minus (n m : nat) {struct n} : nat :=</I></TT><BR>
<TT><I>  match n with</I></TT><BR>
<TT><I>  | 0 =</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  | S k =</I></TT><TT><I>&gt;</I></TT><TT><I> match m with</I></TT><BR>
<TT><I>           | 0 =</I></TT><TT><I>&gt;</I></TT><TT><I> S k</I></TT><BR>
<TT><I>           | S l =</I></TT><TT><I>&gt;</I></TT><TT><I> k - l</I></TT><BR>
<TT><I>           end</I></TT><BR>
<TT><I>  end</I></TT><BR>
<TT><I>     : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat</I></TT><BR>
<TT><I>Argument scopes are [nat_scope nat_scope]</I></TT><BR>
</DIV><P>In case of dependencies in the type of the induction objects
<I>t</I><SUB>1</SUB> and <I>t</I><SUB>2</SUB>, an extra argument stating <I>t</I><SUB>1</SUB>=<I>t</I><SUB>2</SUB> must be given to
the fixpoint definition</P><!--TOC subsubsection How to perform nested and double induction?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc133">118</A>  How to perform nested and double induction?</H4><!--SEC END --><P>To reason by nested (i.e. lexicographic) induction, just reason by
induction on the successive components.</P><P><BR>
</P><P>Double induction (or induction on pairs) is a restriction of the
lexicographic induction. Here is an example of double induction.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma nat_double_ind : </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> forall P : nat -</TT><TT>&gt;</TT><TT> nat -</TT><TT>&gt;</TT><TT> Prop, P 0 0 -</TT><TT>&gt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   (forall m n, P m n -</TT><TT>&gt;</TT><TT> P m (S n)) -</TT><TT>&gt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   (forall m n, P m n -</TT><TT>&gt;</TT><TT> P (S m) n) -</TT><TT>&gt;</TT><TT> </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      forall m n, P m n.</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop,</I></TT><BR>
<TT><I>   P 0 0 -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>   (forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P m (S n)) -</I></TT><TT><I>&gt;</I></TT><BR>
<TT><I>   (forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S m) n) -</I></TT><TT><I>&gt;</I></TT><TT><I> forall m n : nat, P m n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros P H00 HmS HSn; induction m.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  H00 : P 0 0</I></TT><BR>
<TT><I>  HmS : forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P m (S n)</I></TT><BR>
<TT><I>  HSn : forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S m) n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, P 0 n</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> forall n : nat, P (S m) n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> (* case 0 *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction n; [assumption | apply HmS; apply IHn].</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  P : nat -</I></TT><TT><I>&gt;</I></TT><TT><I> nat -</I></TT><TT><I>&gt;</I></TT><TT><I> Prop</I></TT><BR>
<TT><I>  H00 : P 0 0</I></TT><BR>
<TT><I>  HmS : forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P m (S n)</I></TT><BR>
<TT><I>  HSn : forall m n : nat, P m n -</I></TT><TT><I>&gt;</I></TT><TT><I> P (S m) n</I></TT><BR>
<TT><I>  m : nat</I></TT><BR>
<TT><I>  IHm : forall n : nat, P m n</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, P (S m) n</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> (* case Sm *)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intro n; apply HSn; apply IHm.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV><!--TOC subsubsection How to define a function by nested recursion?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc134">119</A>  How to define a function by nested recursion?</H4><!--SEC END --><P>The same trick applies. Here is the example of Ackermann
function.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint ack (n:nat) : nat -</TT><TT>&gt;</TT><TT> nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | O =</TT><TT>&gt;</TT><TT> S</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S n' =</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      (fix ack' (m:nat) : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>         match m with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>         | O =</TT><TT>&gt;</TT><TT> ack n' 1</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>         | S m' =</TT><TT>&gt;</TT><TT> ack n' (ack' m')</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>         end)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<TT><I>ack is recursively defined</I></TT><BR>
</DIV><!--TOC subsection Co-inductive types-->
<H3 CLASS="subsection"><!--SEC ANCHOR --><A NAME="htoc135">7.3</A>  Co-inductive types</H3><!--SEC END --><!--TOC subsubsection I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc136">120</A>  I have a cofixpoint <I>t</I>:=<I>F</I>(<I>t</I>) and I want to prove <I>t</I>=<I>F</I>(<I>t</I>). How to do it?</H4><!--SEC END --><P>Just case-expand <I>F</I>(<TT><I>t</I></TT>) then complete by a trivial case analysis.
Here is what it gives on e.g. the type of streams on naturals</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> CoInductive Stream (A:Set) : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   Cons : A -</TT><TT>&gt;</TT><TT> Stream A -</TT><TT>&gt;</TT><TT> Stream A.</TT><BR>
<TT><I>Stream is defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> CoFixpoint nats (n:nat) : Stream nat := Cons n (nats (S n)).</TT><BR>
<TT><I>nats is corecursively defined</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Stream_unfold : </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall n:nat, nats n = Cons n (nats (S n)).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   forall n : nat, nats n = Cons n (nats (S n))</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intro;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   change (nats n = match nats n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                   | Cons x s =</TT><TT>&gt;</TT><TT> Cons x s</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                   end).</TT><BR>
<TT><I>1 subgoal</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  n : nat</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   nats n = match nats n with</I></TT><BR>
<TT><I>            | Cons x s =</I></TT><TT><I>&gt;</I></TT><TT><I> Cons x s</I></TT><BR>
<TT><I>            end</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   case (nats n); reflexivity.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
<TT><I>intro; change (nats n = match nats n with</I></TT><BR>
<TT><I>                        | Cons x s =</I></TT><TT><I>&gt;</I></TT><TT><I> Cons x s</I></TT><BR>
<TT><I>                        end) in |- *.</I></TT><BR>
<TT><I>case (nats n); reflexivity.</I></TT><BR>
<TT><I>Stream_unfold is defined</I></TT><BR>
</DIV><!--TOC section Syntax and notations-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc137">8</A>  Syntax and notations</H2><!--SEC END --><!--TOC subsubsection I do not want to type &#X201C;forall&#X201D; because it is too long, what can I do?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc138">121</A>  I do not want to type &#X201C;forall&#X201D; because it is too long, what can I do?</H4><!--SEC END --><P>You can define your own notation for forall:
</P><PRE CLASS="verbatim">Notation "fa x : t, P" := (forall x:t, P) (at level 200, x ident).
</PRE><P>or if your are using <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> you can define a pretty symbol for for all and an input method (see <A HREF="#forallcoqide">152</A>).</P><!--TOC subsubsection How can I define a notation for square?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc139">122</A>  How can I define a notation for square?</H4><!--SEC END --><P>You can use for instance:
</P><PRE CLASS="verbatim">Notation "x ^2" := (Rmult x x) (at level 20).
</PRE><P>Note that you can not use:
<TT>N</TT>otation "x <SUP>²</SUP>" := (Rmult x x) (at level 20).

because &#X201C;<SUP>2</SUP>&#X201D; is an iso-latin character. If you really want this kind of notation you should use UTF-8.</P><!--TOC subsubsection Why &#X201C;no associativity&#X201D; and &#X201C;left associativity&#X201D; at the same level does not work?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc140">123</A>  Why &#X201C;no associativity&#X201D; and &#X201C;left associativity&#X201D; at the same level does not work?</H4><!--SEC END --><P>Because we relie on camlp4 for syntactical analysis and camlp4 does not really implement no associativity. By default, non associative operators are defined as right associative.</P><!--TOC subsubsection How can I know the associativity associated with a level?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc141">124</A>  How can I know the associativity associated with a level?</H4><!--SEC END --><P>You can do &#X201C;Print Grammar constr&#X201D;, and decode the output from camlp4, good luck !</P><!--TOC section Modules-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc142">9</A>  Modules</H2><!--SEC END --><!--TOC section <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc143">10</A>  <SPAN STYLE="font-variant:small-caps">Ltac</SPAN></H2><!--SEC END --><!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc144">125</A>  What is <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">Ltac</SPAN> is the tactic language for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. It provides the user with a
high-level &#X201C;toolbox&#X201D; for tactic creation.</P><!--TOC subsubsection Why do I always get the same error message?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc145">126</A>  Why do I always get the same error message?</H4><!--SEC END --><!--TOC subsubsection Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc146">127</A>  Is there any printing command in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END --><P>You can use the <TT>idtac</TT> tactic with a string argument. This string
will be printed out. The same applies to the <TT>fail</TT> tactic</P><!--TOC subsubsection What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc147">128</A>  What is the syntax for let in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END --><P>If <I>x</I><SUB><I>i</I></SUB> are identifiers and <I>e</I><SUB><I>i</I></SUB> and <I>expr</I> are tactic expressions, then let reads:
</P><DIV CLASS="center">
<TT>let </TT><TT><I>x</I></TT><SUB><TT>1</TT></SUB><TT>:=</TT><TT><I>e</I></TT><SUB><TT>1</TT></SUB><TT> with </TT><TT><I>x</I></TT><SUB><TT>2</TT></SUB><TT>:=</TT><TT><I>e</I></TT><SUB><TT>2</TT></SUB><TT>&#X2026;with </TT><TT><I>x</I></TT><SUB><TT><I>n</I></TT></SUB><TT>:=</TT><TT><I>e</I></TT><SUB><TT><I>n</I></TT></SUB><TT> in
</TT><TT><I>expr</I></TT>.
</DIV><P>
Beware that if <I>expr</I> is complex (i.e. features at least a sequence) parenthesis
should be added around it. For example: 

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac twoIntro := let x:=intro in (x;x).</TT><BR>
<TT><I>twoIntro is defined</I></TT><BR>
</DIV><!--TOC subsubsection What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc148">129</A>  What is the syntax for pattern matching in <SPAN STYLE="font-variant:small-caps">Ltac</SPAN>?</H4><!--SEC END --><P>Pattern matching on a term <I>expr</I> (non-linear first order unification)
with patterns <I>p</I><SUB><I>i</I></SUB> and tactic expressions <I>e</I><SUB><I>i</I></SUB> reads:
</P><DIV CLASS="center">
          
<TT>match </TT><TT><I>expr</I></TT><TT> with
  </TT><TT><I>p</I></TT><SUB><TT>1</TT></SUB><TT> =&gt; </TT><TT><I>e</I></TT><SUB><TT>1</TT></SUB><TT>
 |</TT><TT><I>p</I></TT><SUB><TT>2</TT></SUB><TT> =&gt; </TT><TT><I>e</I></TT><SUB><TT>2</TT></SUB><TT>
 &#X2026; |</TT><TT><I>p</I></TT><SUB><TT><I>n</I></TT></SUB><TT> =&gt; </TT><TT><I>e</I></TT><SUB><TT><I>n</I></TT></SUB><TT>
 | _ =&gt; </TT><TT><I>e</I></TT><SUB><TT><I>n</I>+1</TT></SUB><TT>
end.
</TT>
</DIV><P>
Underscore matches all terms.</P><!--TOC subsubsection What is the semantics for &#X201C;match goal&#X201D;?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc149">130</A>  What is the semantics for &#X201C;match goal&#X201D;?</H4><!--SEC END --><P>The semantics of <TT>match goal</TT> depends on whether it returns
tactics or not. The <TT>match goal</TT> expression matches the current
goal against a series of patterns: <I>hyp</I><SUB>1</SUB> &#X2026; <I>hyp</I><SUB><I>n</I></SUB> |-
<I>ccl</I>. It uses a first-order unification algorithm and in case of
success, if the right-hand-side is an expression, it tries to type it
while if the right-hand-side is a tactic, it tries to apply it. If the
typing or the tactic application fails, the <TT>match goal</TT> tries all
the possible combinations of <I>hyp</I><SUB><I>i</I></SUB> before dropping the branch and
moving to the next one. Underscore matches all terms.</P><!--TOC subsubsection Why can't I use a &#X201C;match goal&#X201D; returning a tactic in a non
tail-recursive position?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc150">131</A>  Why can't I use a &#X201C;match goal&#X201D; returning a tactic in a non
tail-recursive position?</H4><!--SEC END --><P>This is precisely because the semantics of <TT>match goal</TT> is to
apply the tactic on the right as soon as a pattern unifies what is
meaningful only in tail-recursive uses.</P><P>The semantics in non tail-recursive call could have been the one used
for terms (i.e. fail if the tactic expression is not typable, but
don't try to apply it). For uniformity of semantics though, this has
been rejected.</P><!--TOC subsubsection How can I generate a new name?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc151">132</A>  How can I generate a new name?</H4><!--SEC END --><P>You can use the following syntax:
<TT>let id:=fresh in &#X2026;</TT><BR>
For example:

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Ltac introIdGen := let id:=fresh in intro id.</TT><BR>
<TT><I>introIdGen is defined</I></TT><BR>
</DIV><!--TOC subsubsection How can I define static and dynamic code?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc152">133</A>  How can I define static and dynamic code?</H4><!--SEC END --><!--TOC section Tactics written in Ocaml-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc153">11</A>  Tactics written in Ocaml</H2><!--SEC END --><!--TOC subsubsection Can you show me an example of a tactic written in OCaml?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc154">134</A>  Can you show me an example of a tactic written in OCaml?</H4><!--SEC END --><P>You have some examples of tactics written in Ocaml in the &#X201C;contrib&#X201D; directory of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> sources. </P><!--TOC section Case studies-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc155">12</A>  Case studies</H2><!--SEC END --><!--TOC subsubsection How can I define vectors or lists of size n?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc156">135</A>  How can I define vectors or lists of size n?</H4><!--SEC END --><!--TOC subsubsection How to prove that 2 sets are different?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc157">136</A>  How to prove that 2 sets are different?</H4><!--SEC END --><P>You need to find a property true on one set and false on the
other one. As an example we show how to prove that <TT>bool</TT> and <TT>nat</TT> are discriminable. As discrimination property we take the
property to have no more than 2 elements.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem nat_bool_discr : bool </TT><TT>&lt;</TT><TT>&gt;</TT><TT> nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   pose (discr :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     fun X:Set =</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       </TT><TT>~</TT><TT> (forall a b:X, </TT><TT>~</TT><TT> (forall x:X, x </TT><TT>&lt;</TT><TT>&gt;</TT><TT> a -</TT><TT>&gt;</TT><TT> x </TT><TT>&lt;</TT><TT>&gt;</TT><TT> b -</TT><TT>&gt;</TT><TT> False))).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intro Heq; assert (H: discr bool).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   intro H; apply (H true false); destruct x; auto.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   rewrite Heq in H; apply H; clear H.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   destruct a; destruct b as [|n]; intro H0; eauto.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   destruct n; [ apply (H0 2); discriminate | eauto ].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><!--TOC subsubsection Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc158">137</A>  Is there an axiom-free proof of Streicher's axiom <I>K</I> for
the equality on <TT>nat</TT>?</H4><!--SEC END --><P>
<A NAME="K-nat"></A></P><P>Yes, because equality is decidable on <TT>nat</TT>. Here is the proof.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Eqdep_dec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Peano_dec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem K_nat :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (x:nat) (P:x = x -</TT><TT>&gt;</TT><TT> Prop), P (refl_equal x) -</TT><TT>&gt;</TT><TT> forall p:x = x, P p.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros; apply K_dec_set with (p := p).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply eq_nat_dec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><P>Similarly, we have</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem eq_rect_eq_nat :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (p:nat) (Q:nat-</TT><TT>&gt;</TT><TT>Type) (x:Q p) (h:p=p), x = eq_rect p Q x p h.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros; apply K_nat with (p := h); reflexivity.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><!--TOC subsubsection How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc159">138</A>  How to prove that two proofs of <TT>n&lt;=m</TT> on <TT>nat</TT> are equal?</H4><!--SEC END --><P>
<A NAME="le-uniqueness"></A></P><P>This is provable without requiring any axiom because axiom <I>K</I>
directly holds on <TT>nat</TT>. Here is a proof using question <A HREF="#K-nat">137</A>.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Arith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Scheme le_ind' := Induction for le Sort Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem le_uniqueness_proof : forall (n m : nat) (p q : n </TT><TT>&lt;</TT><TT>= m), p = q.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Proof.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction p using le_ind'; intro q.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  replace (le_n n) with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   (eq_rect _ (fun n0 =</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= n0) (le_n n) _ (refl_equal n)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  2:reflexivity.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   generalize (refl_equal n).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     pattern n at 2 4 6 10, q; case q; [intro | intros m l e].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      rewrite </TT><TT>&lt;</TT><TT>- eq_rect_eq_nat; trivial.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      contradiction (le_Sn_n m); rewrite </TT><TT>&lt;</TT><TT>- e; assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  replace (le_S n m p) with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   (eq_rect _ (fun n0 =</TT><TT>&gt;</TT><TT> n </TT><TT>&lt;</TT><TT>= n0) (le_S n m p) _ (refl_equal (S m))).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  2:reflexivity.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   generalize (refl_equal (S m)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     pattern (S m) at 1 3 4 6, q; case q; [intro Heq | intros m0 l HeqS].</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      contradiction (le_Sn_n m); rewrite Heq; assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>      injection HeqS; intro Heq; generalize l HeqS.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       rewrite </TT><TT>&lt;</TT><TT>- Heq; intros; rewrite </TT><TT>&lt;</TT><TT>- eq_rect_eq_nat.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       rewrite (IHp l0); reflexivity.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><!--TOC subsubsection How to exploit equalities on sets-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc160">139</A>  How to exploit equalities on sets</H4><!--SEC END --><P>To extract information from an equality on sets, you need to
find a predicate of sets satisfied by the elements of the sets. As an
example, let's consider the following theorem.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem interval_discr :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall m n:nat,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     {x : nat | x </TT><TT>&lt;</TT><TT>= m} = {x : nat | x </TT><TT>&lt;</TT><TT>= n} -</TT><TT>&gt;</TT><TT> m = n.</TT><BR>
</DIV><P>We have a proof requiring the axiom of proof-irrelevance. We
conjecture that proof-irrelevance can be circumvented by introducing a
primitive definition of discrimination of the proofs of
<CODE>{x : nat | x &lt;= m}</CODE>.</P><P><A HREF="./interval_discr.v">Here</A> is the proof.
</P><!--TOC subsubsection I have a problem of dependent elimination on
proofs, how to solve it?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc161">140</A>  I have a problem of dependent elimination on
proofs, how to solve it?</H4><!--SEC END --><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive Def1 : Set := c1 : Def1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive DefProp : Def1 -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   c2 : forall d:Def1, DefProp d.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive Comb : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   c3 : forall d:Def1, DefProp d -</TT><TT>&gt;</TT><TT> Comb.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma eq_comb :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (d1 d1':Def1) (d2:DefProp d1) (d2':DefProp d1'),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     d1 = d1' -</TT><TT>&gt;</TT><TT> c3 d1 d2 = c3 d1' d2'.</TT><BR>
</DIV><P>You need to derive the dependent elimination
scheme for DefProp by hand using <TT>S</TT>cheme.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Scheme DefProp_elim := Induction for DefProp Sort Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma eq_comb :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall d1 d1':Def1,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     d1 = d1' -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall (d2:DefProp d1) (d2':DefProp d1'), c3 d1 d2 = c3 d1' d2'.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> destruct H.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> destruct d2 using DefProp_elim.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> destruct d2' using DefProp_elim.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> reflexivity.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><!--TOC subsubsection And what if I want to prove the following?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc162">141</A>  And what if I want to prove the following?</H4><!--SEC END --><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive natProp : nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | p0 : natProp 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | pS : forall n:nat, natProp n -</TT><TT>&gt;</TT><TT> natProp (S n).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive package : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   pack : forall n:nat, natProp n -</TT><TT>&gt;</TT><TT> package.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma eq_pack :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall n n':nat,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    n = n' -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall (np:natProp n) (np':natProp n'), pack n np = pack n' np'.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Scheme natProp_elim := Induction for natProp Sort Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition pack_S : package -</TT><TT>&gt;</TT><TT> package.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> destruct 1.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply (pack (S n)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply pS; assumption.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Defined.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma eq_pack :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall n n':nat,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     n = n' -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall (np:natProp n) (np':natProp n'), pack n np = pack n' np'.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> intros n n' Heq np np'.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> generalize dependent n'.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction np using natProp_elim.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction np' using natProp_elim; intros; auto.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  discriminate Heq.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> induction np' using natProp_elim; intros; auto.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  discriminate Heq.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> change (pack_S (pack n np) = pack_S (pack n0 np')).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply (f_equal (A:=package)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> apply IHnp.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> auto.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Qed.</TT><BR>
</DIV><!--TOC section Publishing tools-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc163">13</A>  Publishing tools</H2><!--SEC END --><!--TOC subsubsection How can I generate some latex from my development?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc164">142</A>  How can I generate some latex from my development?</H4><!--SEC END --><P>You can use <TT>coqdoc</TT>.</P><!--TOC subsubsection How can I generate some HTML from my development?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc165">143</A>  How can I generate some HTML from my development?</H4><!--SEC END --><P>You can use <TT>coqdoc</TT>.</P><!--TOC subsubsection How can I generate some dependency graph from my development?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc166">144</A>  How can I generate some dependency graph from my development?</H4><!--SEC END --><!--TOC subsubsection How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc167">145</A>  How can I cite some <SPAN STYLE="font-variant:small-caps">Coq</SPAN> in my latex document?</H4><!--SEC END --><P>You can use <TT>coq_tex</TT>.</P><!--TOC subsubsection How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc168">146</A>  How can I cite the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> reference manual?</H4><!--SEC END --><P>You can use this bibtex entry:
</P><PRE CLASS="verbatim">@Manual{Coq:manual,
  title =        {The Coq proof assistant reference manual},
  author =       {\mbox{The Coq development team}},
  organization = {LogiCal Project},
  note =         {Version 8.0},
  year =         {2004},
  url =          "http://coq.inria.fr"
}
</PRE><!--TOC subsubsection Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc169">147</A>  Where can I publish my developments in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>?</H4><!--SEC END --><P>You can submit your developments as a user contribution to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
development team. This ensures its liveness along the evolution and
possible changes of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><P>You can also submit your developments to the HELM/MoWGLI repository at
the University of Bologna (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>). For
developments submitted in this database, it is possible to visualize
the developments in natural language and execute various retrieving
requests.</P><!--TOC subsubsection How can I read my proof in natural language?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc170">148</A>  How can I read my proof in natural language?</H4><!--SEC END --><P>You can submit your proof to the HELM/MoWGLI repository and use the
rendering tool provided by the server (see
<A HREF="http://mowgli.cs.unibo.it"><TT>http://mowgli.cs.unibo.it</TT></A>).</P><!--TOC section <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc171">14</A>  <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN></H2><!--SEC END --><!--TOC subsubsection What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc172">149</A>  What is <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>?</H4><!--SEC END --><P><SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> is a gtk based GUI for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><!--TOC subsubsection How to enable Emacs keybindings?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc173">150</A>  How to enable Emacs keybindings?</H4><!--SEC END --><P>
Insert <TT>gtk-key-theme-name = "Emacs"</TT>
in your <TT>.coqide-gtk2rc</TT> file. It may be in the current dir
or in <CODE>$HOME</CODE> dir. This is done by default.</P><!--TOC subsubsection How to enable antialiased fonts?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc174">151</A>  How to enable antialiased fonts?</H4><!--SEC END --><P>Set the <CODE>GDK_USE_XFT</CODE> variable to <CODE>1</CODE>. This is by default with <CODE>Gtk &gt;= 2.2</CODE>.
If some of your fonts are not available, set <CODE>GDK_USE_XFT</CODE> to <CODE>0</CODE>.</P><!--TOC subsubsection How to use those Forall and Exists pretty symbols?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc175">152</A>  How to use those Forall and Exists pretty symbols?</H4><!--SEC END --><P><A NAME="forallcoqide"></A>
Thanks to the notation features in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>, you just need to insert these
lines in your <SPAN STYLE="font-variant:small-caps">Coq</SPAN> buffer:<BR>
<TT>N</TT>otation "&#X2200; x : t, P" := (forall x:t, P) (at level 200, x ident).<BR>
<TT>N</TT>otation "&#X2203; x : t, P" := (exists x:t, P) (at level 200, x ident).
</P><P>Copy/Paste of these lines from this file will not work outside of <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>.
You need to load a file containing these lines or to enter the &#X2200;
using an input method (see <A HREF="#inputmeth">153</A>). To try it just use <CODE>Require Import utf8</CODE> from inside
<SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>. 
To enable these notations automatically start coqide with
</P><PRE CLASS="verbatim"> coqide -l utf8
</PRE><P>In the ide subdir of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library, you will find a sample utf8.v with some 
pretty simple notations.</P><!--TOC subsubsection How to define an input method for non ASCII symbols?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc176">153</A>  How to define an input method for non ASCII symbols?</H4><!--SEC END --><P><A NAME="inputmeth"></A></P><UL CLASS="itemize"><LI CLASS="li-itemize">
First solution: type <CODE>&lt;CONTROL&gt;&lt;SHIFT&gt;2200</CODE> to enter a forall in the script widow. 
	2200 is the hexadecimal code for forall in unicode charts and is encoded as 	
	in UTF-8.
	2203 is for exists. See <A HREF="http://www.unicode.org"><TT>http://www.unicode.org</TT></A> for more codes.
</LI><LI CLASS="li-itemize">Second solution: rebind <CODE>&lt;AltGr&gt;a</CODE> to forall and <CODE>&lt;AltGr&gt;e</CODE> to exists. 
	Under X11, you need to use something like
<PRE CLASS="verbatim">  xmodmap -e "keycode  24 = a A F13 F13" 
  xmodmap -e "keycode  26 = e E F14 F14"
</PRE>	and then to add 
<PRE CLASS="verbatim">  bind "F13" {"insert-at-cursor" ("")}
  bind "F14" {"insert-at-cursor" ("")}
</PRE>	to your "binding "text"" section in <CODE>.coqiderc-gtk2rc.</CODE>
	The strange ("") argument is the UTF-8 encoding for
	0x2200. 
	You can compute these encodings using the lablgtk2 toplevel with 
<PRE CLASS="verbatim">  
Glib.Utf8.from_unichar 0x2200;;
</PRE>	Further symbols can be bound on higher Fxx keys or on even on other keys you
	do not need .
</LI></UL><!--TOC subsubsection How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc177">154</A>  How to build a custom <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN> with user ml code?</H4><!--SEC END --><P>
Use 
	coqmktop -ide -byte m1.cmo...mi.cmo
or 
	coqmktop -ide -opt m1.cmx...mi.cmx</P><!--TOC subsubsection How to customize the shortcuts for menus?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc178">155</A>  How to customize the shortcuts for menus?</H4><!--SEC END --><P>
Two solutions are offered:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
Edit $HOME/.coqide.keys by hand or
</LI><LI CLASS="li-itemize">Add "gtk-can-change-accels = 1" in your .coqide-gtk2rc file. Then
from <SPAN STYLE="font-variant:small-caps">CoqIde</SPAN>, you may select a menu entry and press the desired 
shortcut. 
</LI></UL><!--TOC subsubsection What encoding should I use? What is this \x{iiii} in my file?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc179">156</A>  What encoding should I use? What is this \x{iiii} in my file?</H4><!--SEC END --><P>
The encoding option is related to the way files are saved. 
Keep it as UTF-8 until it becomes important for you to exchange files 
with non UTF-8 aware applications.
If you choose something else than UTF-8, then missing characters will 
be encoded by \x{....} or \x{........}
where each dot is an hex. digit. 
The number between braces is the hexadecimal UNICODE index for the
missing character.</P><!--TOC section Extraction-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc180">15</A>  Extraction</H2><!--SEC END --><!--TOC subsubsection What is program extraction?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc181">157</A>  What is program extraction?</H4><!--SEC END --><P>Program extraction consist in generating a program from a constructive proof.</P><!--TOC subsubsection Which language can I extract to?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc182">158</A>  Which language can I extract to?</H4><!--SEC END --><P>You can extract your programs to Objective Caml and Haskell.</P><!--TOC subsubsection How can I extract an incomplete proof?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc183">159</A>  How can I extract an incomplete proof?</H4><!--SEC END --><P>You can provide programs for your axioms.</P><!--TOC section Glossary-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc184">16</A>  Glossary</H2><!--SEC END --><!--TOC subsubsection Can you explain me what an evaluable constant is?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc185">160</A>  Can you explain me what an evaluable constant is?</H4><!--SEC END --><P>An evaluable constant is a constant which is unfoldable.</P><!--TOC subsubsection What is a goal?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc186">161</A>  What is a goal?</H4><!--SEC END --><P>The goal is the statement to be proved.</P><!--TOC subsubsection What is a meta variable?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc187">162</A>  What is a meta variable?</H4><!--SEC END --><P>A meta variable in <SPAN STYLE="font-variant:small-caps">Coq</SPAN> represents a &#X201C;hole&#X201D;, i.e. a part of a proof
that is still unknown. </P><!--TOC subsubsection What is Gallina?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc188">163</A>  What is Gallina?</H4><!--SEC END --><P>Gallina is the specification language of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. Complete documentation
of this language can be found in the Reference Manual.</P><!--TOC subsubsection What is The Vernacular?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc189">164</A>  What is The Vernacular?</H4><!--SEC END --><P>It is the language of commands of Gallina i.e. definitions, lemmas, &#X2026; </P><!--TOC subsubsection What is a dependent type?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc190">165</A>  What is a dependent type?</H4><!--SEC END --><P>A dependant type is a type which depends on some term. For instance
&#X201C;vector of size n&#X201D; is a dependant type representing all the vectors
of size <I>n</I>. Its type depends on <I>n</I></P><!--TOC subsubsection What is a proof by reflection?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc191">166</A>  What is a proof by reflection?</H4><!--SEC END --><P>This is a proof generated by some computation which is done using the
internal reduction of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (not using the tactic language of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
(<SPAN STYLE="font-variant:small-caps">Ltac</SPAN>) nor the implementation language for <SPAN STYLE="font-variant:small-caps">Coq</SPAN>). An example of
tactic using the reflection mechanism is the <TT>ring</TT> tactic. The
reflection method consist in reflecting a subset of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> language (for
example the arithmetical expressions) into an object of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>language itself (in this case an inductive type denoting arithmetical
expressions). For more information see [<A HREF="#howe"><CITE>14</CITE></A><CITE>, </CITE><A HREF="#harrison"><CITE>12</CITE></A><CITE>, </CITE><A HREF="#boutin"><CITE>3</CITE></A>]
and the last chapter of the Coq'Art.</P><!--TOC subsubsection What is intuitionistic logic?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc192">167</A>  What is intuitionistic logic?</H4><!--SEC END --><P>This is any logic which does not assume that &#X201C;A or not A&#X201D;.</P><!--TOC subsubsection What is proof-irrelevance?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc193">168</A>  What is proof-irrelevance?</H4><!--SEC END --><P>See question <A HREF="#proof-irrelevance">33</A></P><!--TOC subsubsection What is the difference between opaque and transparent?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc194">169</A>  What is the difference between opaque and transparent?</H4><!--SEC END --><P><A NAME="opaque"></A>	</P><P>Opaque definitions can not be unfolded but transparent ones can.</P><!--TOC section Troubleshooting-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc195">17</A>  Troubleshooting</H2><!--SEC END --><!--TOC subsubsection What can I do when <TT>Qed.</TT> is slow?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc196">170</A>  What can I do when <TT>Qed.</TT> is slow?</H4><!--SEC END --><P>Sometime you can use the <TT>abstract</TT> tactic, which makes as if you had
stated some local lemma, this speeds up the typing process.</P><!--TOC subsubsection Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc197">171</A>  Why <TT>Reset Initial.</TT> does not work when using <TT>coqc</TT>?</H4><!--SEC END --><P>The initial state corresponds to the state of coqtop when the interactive
session began. It does not make sense in files to compile.</P><!--TOC subsubsection What can I do if I get &#X201C;No more subgoals but non-instantiated existential variables&#X201D;?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc198">172</A>  What can I do if I get &#X201C;No more subgoals but non-instantiated existential variables&#X201D;?</H4><!--SEC END --><P>This means that <TT>eauto</TT> or <TT>eapply</TT> didn't instantiate an
existential variable which eventually got erased by some computation.
You have to backtrack to the faulty occurrence of <TT>eauto</TT> or
<TT>eapply</TT> and give the missing argument an explicit value.</P><!--TOC subsubsection What can I do if I get &#X201C;Cannot solve a second-order unification problem&#X201D;?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc199">173</A>  What can I do if I get &#X201C;Cannot solve a second-order unification problem&#X201D;?</H4><!--SEC END --><P>You can help <SPAN STYLE="font-variant:small-caps">Coq</SPAN> using the <TT>pattern</TT> tactic.</P><!--TOC subsubsection Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc200">174</A>  Why does <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tell me that <TT>{x:A|(P x)}</TT> is not convertible with <TT>(sig A P)</TT>?</H4><!--SEC END --><P>This is because <TT>{x:A|P x}</TT> is a notation for
<TT>sig (fun x:A =&gt; P x)</TT>. Since <SPAN STYLE="font-variant:small-caps">Coq</SPAN> does not reason up to
&#X3B7;-conversion, this is different from <TT>sig P</TT>.</P><!--TOC subsubsection I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
to the original term. Sometimes it even says the copied term is not
well-typed.-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc201">175</A>  I copy-paste a term and <SPAN STYLE="font-variant:small-caps">Coq</SPAN> says it is not convertible
to the original term. Sometimes it even says the copied term is not
well-typed.</H4><!--SEC END --><P>This is probably due to invisible implicit information (implicit
arguments, coercions and Cases annotations) in the printed term, which
is not re-synthesised from the copied-pasted term in the same way as
it is in the original term.</P><P>Consider for instance <TT>(@eq Type True True)</TT>. This term is
printed as <TT>True=True</TT> and re-parsed as <TT>(@eq Prop True
True)</TT>. The two terms are not convertible (hence they fool tactics
like <TT>pattern</TT>).</P><P>There is currently no satisfactory answer to the problem. However,
the command <TT>Set Printing All</TT> is useful for diagnosing the
problem.</P><P>Due to coercions, one may even face type-checking errors. In some
rare cases, the criterion to hide coercions is a bit too loose, which
may result in a typing error message if the parser is not able to find
again the missing coercion.</P><!--TOC section Conclusion and Farewell.-->
<H2 CLASS="section"><!--SEC ANCHOR --><A NAME="htoc202">18</A>  Conclusion and Farewell.</H2><!--SEC END --><P>
<A NAME="ccl"></A></P><!--TOC subsubsection What if my question isn't answered here?-->
<H4 CLASS="subsubsection"><!--SEC ANCHOR --><A NAME="htoc203">176</A>  What if my question isn't answered here?</H4><!--SEC END --><P> 
<A NAME="lastquestion"></A></P><P>Don't panic <CODE>:-)</CODE>. You can try the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> manual [<A HREF="#Coq:manual"><CITE>17</CITE></A>] for a technical
description of the prover. The Coq'Art [<A HREF="#Coq:coqart"><CITE>2</CITE></A>] is the first
book written on <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and provides a comprehensive review of the
theorem prover as well as a number of example and exercises. Finally,
the tutorial [<A HREF="#Coq:Tutorial"><CITE>15</CITE></A>] provides a smooth introduction to
theorem proving in <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.</P><!--TOC section References-->
<H2 CLASS="section"><!--SEC ANCHOR -->References</H2><!--SEC END --><DL CLASS="thebibliography"><DT CLASS="dt-thebibliography">
<A NAME="coqart"><FONT COLOR=purple>[1]</FONT></A></DT><DD CLASS="dd-thebibliography">
Yves bertot and Pierre Castéran.
<EM>Coq'Art</EM>.
Springer-Verlag, 2004.
To appear.</DD><DT CLASS="dt-thebibliography"><A NAME="Coq:coqart"><FONT COLOR=purple>[2]</FONT></A></DT><DD CLASS="dd-thebibliography">
Yves Bertot and Pierre Castéran.
<EM>Interactive Theorem Proving and Program Development, Coq'Art:
The Calculus of Inductive Constructions</EM>.
Texts in Theoretical Computer Science. An EATCS series. Springer
Verlag, 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="boutin"><FONT COLOR=purple>[3]</FONT></A></DT><DD CLASS="dd-thebibliography">
Samuel Boutin.
Using reflection to build efficient and certified decision pro
cedures.
In M. Abadi and T. Ito, editors, <EM>Proceedings of TACS'97</EM>, volume
1281 of <EM>LNCS</EM>. Springer-Verlag, 1997.</DD><DT CLASS="dt-thebibliography"><A NAME="LaTeX:symb"><FONT COLOR=purple>[4]</FONT></A></DT><DD CLASS="dd-thebibliography">
David Carlisle, Scott Pakin, and Alexander Holt.
<EM>The Great, Big List of L<sup>A</sup>T<sub>E</sub>X Symbols</EM>, February 2001.</DD><DT CLASS="dt-thebibliography"><A NAME="Coq85"><FONT COLOR=purple>[5]</FONT></A></DT><DD CLASS="dd-thebibliography">
Thierry Coquand.
<EM>Une Théorie des Constructions</EM>.
PhD thesis, Université Paris 7, January 1985.</DD><DT CLASS="dt-thebibliography"><A NAME="CoHu86"><FONT COLOR=purple>[6]</FONT></A></DT><DD CLASS="dd-thebibliography">
Thierry Coquand and Gérard Huet.
The Calculus of Constructions.
<EM>Information and Computation</EM>, 76(2/3), 1988.</DD><DT CLASS="dt-thebibliography"><A NAME="CoPa89"><FONT COLOR=purple>[7]</FONT></A></DT><DD CLASS="dd-thebibliography">
Thierry Coquand and Christine Paulin-Mohring.
Inductively defined types.
In P. Martin-Löf and G. Mints, editors, <EM>Proceedings of
Colog'88</EM>, volume 417 of <EM>Lecture Notes in Computer Science</EM>.
Springer-Verlag, 1990.</DD><DT CLASS="dt-thebibliography"><A NAME="Types:Dowek"><FONT COLOR=purple>[8]</FONT></A></DT><DD CLASS="dd-thebibliography">
Gilles Dowek.
Théorie des types.
Lecture notes, 2002.</DD><DT CLASS="dt-thebibliography"><A NAME="EGThese"><FONT COLOR=purple>[9]</FONT></A></DT><DD CLASS="dd-thebibliography">
Eduardo Giménez.
<EM>Un Calcul de Constructions Infinies et son application a la
vérification de systèmes communicants</EM>.
thèse d'université, Ecole Normale Supérieure de Lyon, December 1996.</DD><DT CLASS="dt-thebibliography"><A NAME="Gir70"><FONT COLOR=purple>[10]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jean-Yves Girard.
Une extension de l'interprétation de Gödel à l'analyse, et
son application à l'élimination des coupures dans l'analyse et la
théorie des types.
In <EM>Proceedings of the 2nd Scandinavian Logic Symposium</EM>.
North-Holland, 1970.</DD><DT CLASS="dt-thebibliography"><A NAME="ProofsTypes"><FONT COLOR=purple>[11]</FONT></A></DT><DD CLASS="dd-thebibliography">
Jean-Yves Girard, Yves Lafont, and Paul Taylor.
<EM>Proofs and Types</EM>.
Cambrige Tracts in Theoretical Computer Science, Cambridge University
Press, 1989.</DD><DT CLASS="dt-thebibliography"><A NAME="harrison"><FONT COLOR=purple>[12]</FONT></A></DT><DD CLASS="dd-thebibliography">
John Harrison.
Meta theory and reflection in theorem proving:a survey and cri tique.
Technical Report CRC-053, SRI International Cambridge Computer
Science Research Center, 1995.</DD><DT CLASS="dt-thebibliography"><A NAME="HofStr98"><FONT COLOR=purple>[13]</FONT></A></DT><DD CLASS="dd-thebibliography">
Martin Hofmann and Thomas Streicher.
The groupoid interpretation of type theory.
In <EM>Proceedings of the meeting Twenty-five years of constructive
type theory</EM>. Oxford University Press, 1998.</DD><DT CLASS="dt-thebibliography"><A NAME="howe"><FONT COLOR=purple>[14]</FONT></A></DT><DD CLASS="dd-thebibliography">
Doug Howe.
Computation meta theory in nuprl.
In E. Lusk and R. Overbeek, editors, <EM>The Proceedings of the
Ninth International Conference of Autom ated Deduction</EM>, volume 310, pages
238&#X2013;257. Springer-Verlag, 1988.</DD><DT CLASS="dt-thebibliography"><A NAME="Coq:Tutorial"><FONT COLOR=purple>[15]</FONT></A></DT><DD CLASS="dd-thebibliography">
Gérard Huet, Gilles Kahn, and Christine Paulin-Mohring.
<EM>The Coq Proof Assistant A Tutorial</EM>, 2004.</DD><DT CLASS="dt-thebibliography"><A NAME="Luo90"><FONT COLOR=purple>[16]</FONT></A></DT><DD CLASS="dd-thebibliography">
Z. Luo.
<EM>An Extended Calculus of Constructions</EM>.
PhD thesis, University of Edinburgh, 1990.</DD><DT CLASS="dt-thebibliography"><A NAME="Coq:manual"><FONT COLOR=purple>[17]</FONT></A></DT><DD CLASS="dd-thebibliography">
The Coq development team.
<EM>The Coq proof assistant reference manual</EM>.
LogiCal Project, 2004.
Version 8.0.</DD><DT CLASS="dt-thebibliography"><A NAME="LaTeX:intro"><FONT COLOR=purple>[18]</FONT></A></DT><DD CLASS="dd-thebibliography">
Tobias Oetiker.
<EM>The Not So Short Introduction to L<sup>A</sup>T<sub>E</sub>X2e</EM>, January 1999.</DD><DT CLASS="dt-thebibliography"><A NAME="Pau96b"><FONT COLOR=purple>[19]</FONT></A></DT><DD CLASS="dd-thebibliography">
Christine Paulin-Mohring.
<EM>Définitions Inductives en Théorie des Types d'Ordre Supérieur</EM>.
Habilitation à diriger les recherches, Université Claude Bernard Lyon
I, December 1996.</DD></DL><!--CUT END -->
<!--HTMLFOOT-->
<!--ENDHTML-->
<!--FOOTER-->
<HR SIZE=2><BLOCKQUOTE CLASS="quote"><EM>This document was translated from L<sup>A</sup>T<sub>E</sub>X by
</EM><A HREF="http://hevea.inria.fr/index.html"><EM>H</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>V</EM><EM><FONT SIZE=2><sup>E</sup></FONT></EM><EM>A</EM></A><EM>.</EM></BLOCKQUOTE></BODY>
</HTML>
