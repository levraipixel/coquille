<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<LINK rel="stylesheet" type="text/css" href="Reference-Manual.css">
<TITLE>The Coq library</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc67">Chapter 3</A>  The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library</H1><P>
<A NAME="@default128"></A><A NAME="Theories"></A></P><P>The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> library is structured into three parts:</P><DL CLASS="description"><DT CLASS="dt-description">
<B>The initial library:</B></DT><DD CLASS="dd-description"> it contains
elementary logical notions and datatypes. It constitutes the
basic state of the system directly available when running
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>;</DD><DT CLASS="dt-description"><B>The standard library:</B></DT><DD CLASS="dd-description"> general-purpose libraries containing
various developments of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> axiomatizations about sets, lists,
sorting, arithmetic, etc. This library comes with the system and its
modules are directly accessible through the <CODE>Require</CODE> command
(see section <A HREF="Reference-Manual008.html#Require">6.4.1</A>);</DD><DT CLASS="dt-description"><B>User contributions:</B></DT><DD CLASS="dd-description"> Other specification and proof developments
coming from the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> users' community. These libraries are
available for download at <TT>http://coq.inria.fr</TT> (see
section <A HREF="#Contributions">3.3</A>).
</DD></DL><P>This chapter briefly reviews these libraries.</P><H2 CLASS="section"><A NAME="toc22"></A><A NAME="htoc68">3.1</A>  The basic library</H2><P>
<A NAME="Prelude"></A></P><P>This section lists the basic notions and results which are directly
available in the standard <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system<SUP><A NAME="text3" HREF="#note3">1</A></SUP>.</P><H3 CLASS="subsection"><A NAME="htoc69">3.1.1</A>  Notations</H3><P> <A NAME="Notations"></A></P><P>This module defines the parsing and pretty-printing of many symbols
(infixes, prefixes, etc.). However, it does not assign a meaning to these
notations. The purpose of this is to define precedence and
associativity of very common notations, and avoid users to use them
with other precedence, which may be confusing.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=center NOWRAP>Notation</TD><TD ALIGN=left NOWRAP>Precedence</TD><TD ALIGN=left NOWRAP>Associativity</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;-&gt; _</CODE></TD><TD ALIGN=left NOWRAP>95</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ \/ _</CODE></TD><TD ALIGN=left NOWRAP>85</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ /\ _</CODE></TD><TD ALIGN=left NOWRAP>80</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>~ _</CODE></TD><TD ALIGN=left NOWRAP>75</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _ = _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ = _ :&gt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;&gt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;&gt; _ :&gt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &gt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &gt;= _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _ &lt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt; _ &lt;= _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _ &lt; _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ &lt;= _ &lt;= _</CODE></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ + _</CODE></TD><TD ALIGN=left NOWRAP>50</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ - _</CODE></TD><TD ALIGN=left NOWRAP>50</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ * _</CODE></TD><TD ALIGN=left NOWRAP>40</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ / _</CODE></TD><TD ALIGN=left NOWRAP>40</TD><TD ALIGN=left NOWRAP>left</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>- _</CODE></TD><TD ALIGN=left NOWRAP>35</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>/ _</CODE></TD><TD ALIGN=left NOWRAP>35</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=center NOWRAP><CODE>_ ^ _</CODE></TD><TD ALIGN=left NOWRAP>30</TD><TD ALIGN=left NOWRAP>right</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.1: Notations in the initial state</TD></TR>
</TABLE></DIV>
<A NAME="init-notations"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><H3 CLASS="subsection"><A NAME="htoc70">3.1.2</A>  Logic</H3><P> 
<A NAME="Logic"></A></P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>True</TT></TD><TD ALIGN=right NOWRAP>(<TT>True</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>False</TT></TD><TD ALIGN=right NOWRAP>(<TT>False</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>~</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>not</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>/</TT><TT>\</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>and</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>\</TT><TT>/</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>or</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>-&gt;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<EM>primitive implication</EM><EM>)</EM></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>form</FONT></I> <TT>&lt;-&gt;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>iff</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>forall</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>type</FONT></I> <TT>,</TT>
<I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<EM>primitive for all</EM><EM>)</EM></TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>exists</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>ex</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>exists2</TT> <I><FONT COLOR=maroon>ident</FONT></I> <I><FONT COLOR=maroon>[</FONT></I><TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I><I><FONT COLOR=maroon>]</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>form</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>ex2</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>=</TT> <I><FONT COLOR=maroon>term</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>eq</TT>)</TD></TR>
<TR><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>term</FONT></I> <TT>=</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>:&gt;</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>eq</TT>)</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.2: Syntax of formulas</TD></TR>
</TABLE></DIV>
<A NAME="formulas-syntax"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>The basic library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with the definitions of standard
(intuitionistic) logical connectives (they are defined as inductive
constructions). They are equipped with an appealing syntax enriching the
(subclass <I><FONT COLOR=maroon>form</FONT></I>) of the syntactic class <I><FONT COLOR=maroon>term</FONT></I>. The syntax
extension is shown on figure <A HREF="#formulas-syntax">3.2</A>.</P><P><BR>
<B>Remark: </B>Implication is not defined but primitive (it is a non-dependent
product of a proposition over another proposition). There is also a
primitive universal quantification (it is a dependent product over a
proposition). The primitive universal quantification allows both
first-order and higher-order quantification.</P><H4 CLASS="subsubsection">Propositional Connectives</H4><P> <A NAME="Connectives"></A>
<A NAME="@default129"></A></P><P>First, we find propositional calculus connectives:
<A NAME="@default130"></A>
<A NAME="@default131"></A>
<A NAME="@default132"></A>
<A NAME="@default133"></A>
<A NAME="@default134"></A>
<A NAME="@default135"></A>
<A NAME="@default136"></A>
<A NAME="@default137"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive True : Prop := I.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive False :  Prop := .</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition not (A: Prop) := A -</TT><TT>&gt;</TT><TT> False.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive and (A B:Prop) : Prop := conj (_:A) (_:B).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Section Projections.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables A B : Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem proj1 : A /</TT><TT>\</TT><TT> B -</TT><TT>&gt;</TT><TT> A.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem proj2 : A /</TT><TT>\</TT><TT> B -</TT><TT>&gt;</TT><TT> B.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End Projections.</TT><BR>
</DIV><P>

<A NAME="@default138"></A>
<A NAME="@default139"></A>
<A NAME="@default140"></A>
<A NAME="@default141"></A>
<A NAME="@default142"></A>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive or (A B:Prop) : Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | or_introl (_:A)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | or_intror (_:B).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition iff (P Q:Prop) := (P -</TT><TT>&gt;</TT><TT> Q) /</TT><TT>\</TT><TT> (Q -</TT><TT>&gt;</TT><TT> P).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition IF_then_else (P Q R:Prop) := P /</TT><TT>\</TT><TT> Q </TT><TT>\</TT><TT>/ </TT><TT>~</TT><TT> P /</TT><TT>\</TT><TT> R.</TT><BR>
</DIV><H4 CLASS="subsubsection">Quantifiers</H4><P> <A NAME="Quantifiers"></A>
<A NAME="@default143"></A></P><P>Then we find first-order quantifiers:
<A NAME="@default144"></A>
<A NAME="@default145"></A>
<A NAME="@default146"></A>
<A NAME="@default147"></A>
<A NAME="@default148"></A>
<A NAME="@default149"></A>
<A NAME="@default150"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition all (A:Set) (P:A -</TT><TT>&gt;</TT><TT> Prop) := forall x:A, P x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive ex (A: Set) (P:A -</TT><TT>&gt;</TT><TT> Prop) : Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     ex_intro (x:A) (_:P x).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive ex2 (A:Set) (P Q:A -</TT><TT>&gt;</TT><TT> Prop) : Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     ex_intro2 (x:A) (_:P x) (_:Q x).</TT><BR>
</DIV><P>The following abbreviations are allowed:
</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP> <CODE>exists x:A, P</CODE></TD><TD ALIGN=left NOWRAP><CODE>ex A (fun x:A =&gt; P)</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>exists x, P</CODE></TD><TD ALIGN=left NOWRAP><CODE>ex _ (fun x =&gt; P)</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>exists2 x:A, P &amp; Q</CODE></TD><TD ALIGN=left NOWRAP><CODE>ex2 A (fun x:A =&gt; P) (fun x:A =&gt; Q)</CODE></TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>exists2 x, P &amp; Q</CODE></TD><TD ALIGN=left NOWRAP><CODE>ex2 _ (fun x =&gt; P) (fun x =&gt; Q)</CODE></TD></TR>
</TABLE>
</DIV><P>The type annotation <TT>:A</TT> can be omitted when <TT>A</TT> can be
synthesized by the system.</P><H4 CLASS="subsubsection">Equality</H4><P> <A NAME="Equality"></A>
<A NAME="@default151"></A></P><P>Then, we find equality, defined as an inductive relation. That is,
given a <CODE>Type</CODE> <CODE>A</CODE> and an <CODE>x</CODE> of type <CODE>A</CODE>, the
predicate <CODE>(eq A x)</CODE> is the smallest one which contains <CODE>x</CODE>.
This definition, due to Christine Paulin-Mohring, is equivalent to
define <CODE>eq</CODE> as the smallest reflexive relation, and it is also
equivalent to Leibniz' equality.</P><P><A NAME="@default152"></A>
<A NAME="@default153"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive eq (A:Type) (x:A) : A -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     refl_equal : eq A x x.</TT><BR>
</DIV><H4 CLASS="subsubsection">Lemmas</H4><P> 
<A NAME="PreludeLemmas"></A></P><P>Finally, a few easy lemmas are provided.</P><P><A NAME="@default154"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem absurd : forall A C:Prop, A -</TT><TT>&gt;</TT><TT> </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
</DIV><P>

<A NAME="@default155"></A>
<A NAME="@default156"></A>
<A NAME="@default157"></A>
<A NAME="@default158"></A>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section equality.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables A B : Type.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable f : A -</TT><TT>&gt;</TT><TT> B.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables x y z : A.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem sym_eq : x = y -</TT><TT>&gt;</TT><TT> y = x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem trans_eq : x = y -</TT><TT>&gt;</TT><TT> y = z -</TT><TT>&gt;</TT><TT> x = z.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem f_equal : x = y -</TT><TT>&gt;</TT><TT> f x = f y.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem sym_not_eq : x </TT><TT>&lt;</TT><TT>&gt;</TT><TT> y -</TT><TT>&gt;</TT><TT> y </TT><TT>&lt;</TT><TT>&gt;</TT><TT> x.</TT><BR>
</DIV><P>

<A NAME="@default159"></A>
<A NAME="@default160"></A>
<A NAME="@default161"></A>
<A NAME="@default162"></A>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End equality.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition eq_ind_r :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (A:Type) (x:A) (P:A -</TT><TT>&gt;</TT><TT> Prop), P x -</TT><TT>&gt;</TT><TT> forall y:A, y = x -</TT><TT>&gt;</TT><TT> P y.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition eq_rec_r :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (A:Type) (x:A) (P:A -</TT><TT>&gt;</TT><TT> Set), P x -</TT><TT>&gt;</TT><TT> forall y:A, y = x -</TT><TT>&gt;</TT><TT> P y.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition eq_rect_r :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   forall (A:Type) (x:A) (P:A -</TT><TT>&gt;</TT><TT> Type), P x -</TT><TT>&gt;</TT><TT> forall y:A, y = x -</TT><TT>&gt;</TT><TT> P y.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Immediate sym_eq sym_not_eq : core.</TT><BR>
</DIV><P>

<A NAME="@default163"></A></P><P>The theorem <TT>f_equal</TT> is extended to functions with two to five
arguments. The theorem are names <TT>f_equal2</TT>, <TT>f_equal3</TT>, 
<TT>f_equal4</TT> and <TT>f_equal5</TT>.
For instance <TT>f_equal3</TT> is defined the following way.

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem f_equal3 :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (A1 A2 A3 B:Type) (f:A1 -</TT><TT>&gt;</TT><TT> A2 -</TT><TT>&gt;</TT><TT> A3 -</TT><TT>&gt;</TT><TT> B) (x1 y1:A1) (x2 y2:A2)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (x3 y3:A3), x1 = y1 -</TT><TT>&gt;</TT><TT> x2 = y2 -</TT><TT>&gt;</TT><TT> x3 = y3 -</TT><TT>&gt;</TT><TT> f x1 x2 x3 = f y1 y2 y3.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc71">3.1.3</A>  Datatypes</H3><P>
<A NAME="Datatypes"></A>
<A NAME="@default164"></A></P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>specif</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>*</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>prod</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>+</TT> <I><FONT COLOR=maroon>specif</FONT></I></TD><TD ALIGN=right NOWRAP>(<TT>sum</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><I><FONT COLOR=maroon>specif</FONT></I> <TT>+ {</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP>(<TT>sumor</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>} + {</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP> (<TT>sumbool</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>|</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP>(<TT>sig</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>|</TT> <I><FONT COLOR=maroon>form</FONT></I> <TT>&amp;</TT>
<I><FONT COLOR=maroon>form</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP>(<TT>sig2</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP>(<TT>sigS</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>|</TD><TD ALIGN=left NOWRAP><TT>{</TT> <I><FONT COLOR=maroon>ident</FONT></I> <TT>:</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>&amp;</TT> <I><FONT COLOR=maroon>specif</FONT></I> <TT>}</TT></TD><TD ALIGN=right NOWRAP>(<TT>sigS2</TT>)</TD></TR>
<TR><TD ALIGN=right NOWRAP>&nbsp;</TD><TD ALIGN=center NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=right NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=right NOWRAP><I><FONT COLOR=maroon>term</FONT></I></TD><TD ALIGN=center NOWRAP>::=</TD><TD ALIGN=left NOWRAP><TT>(</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>,</TT> <I><FONT COLOR=maroon>term</FONT></I> <TT>)</TT></TD><TD ALIGN=right NOWRAP>(<TT>pair</TT>)</TD></TR>
</TABLE>
</DIV>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.3: Syntax of datatypes and specifications</TD></TR>
</TABLE></DIV>
<A NAME="specif-syntax"></A>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>In the basic library, we find the definition<SUP><A NAME="text4" HREF="#note4">2</A></SUP> of the basic data-types of programming, again
defined as inductive constructions over the sort <CODE>Set</CODE>. Some of
them come with a special syntax shown on Figure <A HREF="#specif-syntax">3.3</A>.</P><H4 CLASS="subsubsection">Programming</H4><P> 
<A NAME="Programming"></A>
<A NAME="@default165"></A>
<A NAME="libnats"></A></P><P><A NAME="@default166"></A>
<A NAME="@default167"></A>
<A NAME="@default168"></A>
<A NAME="@default169"></A>
<A NAME="@default170"></A>
<A NAME="@default171"></A>
<A NAME="@default172"></A>
<A NAME="@default173"></A>
<A NAME="@default174"></A>
<A NAME="@default175"></A>
<A NAME="@default176"></A>
<A NAME="@default177"></A>
<A NAME="@default178"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive unit : Set := tt.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive bool : Set := true | false.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive nat : Set := O | S (n:nat).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive option (A:Set) : Set := Some (_:A) | None.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive identity (A:Type) (a:A) : A -</TT><TT>&gt;</TT><TT> Type :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     refl_identity : identity A a a.</TT><BR>
</DIV><P>Note that zero is the letter <CODE>O</CODE>, and <I><FONT COLOR=maroon>not</FONT></I> the numeral
<CODE>0</CODE>.</P><P><TT>identity</TT> is logically equivalent to equality but it lives in
sort <TT>Set</TT>. Computationaly, it behaves like <TT>unit</TT>.</P><P>We then define the disjoint sum of <CODE>A+B</CODE> of two sets <CODE>A</CODE> and
<CODE>B</CODE>, and their product <CODE>A*B</CODE>.
<A NAME="@default179"></A>
<A NAME="@default180"></A>
<A NAME="@default181"></A>
<A NAME="@default182"></A>
<A NAME="@default183"></A>
<A NAME="@default184"></A>
<A NAME="@default185"></A>
<A NAME="@default186"></A>
<A NAME="@default187"></A>
<A NAME="@default188"></A>
<A NAME="@default189"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sum (A B:Set) : Set := inl (_:A) | inr (_:B).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive prod (A B:Set) : Set := pair (_:A) (_:B).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Section projections.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variables A B : Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition fst (H: prod A B) := match H with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                 | pair x y =</TT><TT>&gt;</TT><TT> x</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                 end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition snd (H: prod A B) := match H with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                 | pair x y =</TT><TT>&gt;</TT><TT> y</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>                                 end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End projections.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc72">3.1.4</A>  Specification</H3><P>The following notions<SUP><A NAME="text5" HREF="#note5">3</A></SUP> allows to build new datatypes and specifications. 
They are available with the syntax shown on
Figure <A HREF="#specif-syntax">3.3</A><SUP><A NAME="text6" HREF="#note6">4</A></SUP>.</P><P>For instance, given <CODE>A:Set</CODE> and <CODE>P:A-&gt;Prop</CODE>, the construct
<CODE>{x:A | P x}</CODE> (in abstract syntax <CODE>(sig A P)</CODE>) is a
<CODE>Set</CODE>. We may build elements of this set as <CODE>(exist x p)</CODE>
whenever we have a witness <CODE>x:A</CODE> with its justification
<CODE>p:P x</CODE>.</P><P>From such a <CODE>(exist x p)</CODE> we may in turn extract its witness
<CODE>x:A</CODE> (using an elimination construct such as <CODE>match</CODE>) but
<I><FONT COLOR=maroon>not</FONT></I> its justification, which stays hidden, like in an abstract
data type. In technical terms, one says that <CODE>sig</CODE> is a &#X201C;weak
(dependent) sum&#X201D;. A variant <CODE>sig2</CODE> with two predicates is also
provided.</P><P><A NAME="@default190"></A>
<A NAME="@default191"></A>
<A NAME="@default192"></A>
<A NAME="@default193"></A>
<A NAME="@default194"></A>
<A NAME="@default195"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sig (A:Set) (P:A -</TT><TT>&gt;</TT><TT> Prop) : Set := exist (x:A) (_:P x).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sig2 (A:Set) (P Q:A -</TT><TT>&gt;</TT><TT> Prop) : Set := </TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   exist2 (x:A) (_:P x) (_:Q x).</TT><BR>
</DIV><P>A &#X201C;strong (dependent) sum&#X201D; <CODE>{x:A &amp; (P x)}</CODE> may be also defined,
when the predicate <CODE>P</CODE> is now defined as a <CODE>Set</CODE>
constructor.</P><P><A NAME="@default196"></A>
<A NAME="@default197"></A>
<A NAME="@default198"></A>
<A NAME="@default199"></A>
<A NAME="@default200"></A>
<A NAME="@default201"></A>
<A NAME="@default202"></A>
<A NAME="@default203"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sigS (A:Set) (P:A -</TT><TT>&gt;</TT><TT> Set) : Set := existS (x:A) (_:P x).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Section sigSprojections.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable A : Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P : A -</TT><TT>&gt;</TT><TT> Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition projS1 (H:sigS A P) := let (x, h) := H in x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition projS2 (H:sigS A P) :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match H return P (projS1 H) with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     existS x h =</TT><TT>&gt;</TT><TT> h</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End sigSprojections.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sigS2 (A: Set) (P Q:A -</TT><TT>&gt;</TT><TT> Set) : Set :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     existS2 (x:A) (_:P x) (_:Q x).</TT><BR>
</DIV><P>A related non-dependent construct is the constructive sum
<CODE>{A}+{B}</CODE> of two propositions <CODE>A</CODE> and <CODE>B</CODE>.
<A NAME="sumbool"></A>
<A NAME="@default204"></A>
<A NAME="@default205"></A>
<A NAME="@default206"></A>
<A NAME="@default207"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sumbool (A B:Prop) : Set := left (_:A) | right (_:B).</TT><BR>
</DIV><P>This <CODE>sumbool</CODE> construct may be used as a kind of indexed boolean
data type. An intermediate between <CODE>sumbool</CODE> and <CODE>sum</CODE> is
the mixed <CODE>sumor</CODE> which combines <CODE>A:Set</CODE> and <CODE>B:Prop</CODE>
in the <CODE>Set</CODE> <CODE>A+{B}</CODE>.
<A NAME="@default208"></A>
<A NAME="@default209"></A>
<A NAME="@default210"></A>
<A NAME="@default211"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive sumor (A:Set) (B:Prop) : Set := inleft (_:A) | inright (_:B).</TT><BR>
</DIV><P>We may define variants of the axiom of choice, like in Martin-Löf's
Intuitionistic Type Theory.
<A NAME="@default212"></A>
<A NAME="@default213"></A>
<A NAME="@default214"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Choice :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (S S':Set) (R:S -</TT><TT>&gt;</TT><TT> S' -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall x:S, {y : S' | R x y}) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    {f : S -</TT><TT>&gt;</TT><TT> S' | forall z:S, R z (f z)}.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Choice2 :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (S S':Set) (R:S -</TT><TT>&gt;</TT><TT> S' -</TT><TT>&gt;</TT><TT> Set),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall x:S, {y : S' &amp;  R x y}) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    {f : S -</TT><TT>&gt;</TT><TT> S' &amp;  forall z:S, R z (f z)}.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma bool_choice :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (S:Set) (R1 R2:S -</TT><TT>&gt;</TT><TT> Prop),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall x:S, {R1 x} + {R2 x}) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    {f : S -</TT><TT>&gt;</TT><TT> bool |</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    forall x:S, f x = true /</TT><TT>\</TT><TT> R1 x </TT><TT>\</TT><TT>/ f x = false /</TT><TT>\</TT><TT> R2 x}.</TT><BR>
</DIV><P>The next constructs builds a sum between a data type <CODE>A:Set</CODE> and
an exceptional value encoding errors:</P><P><A NAME="@default215"></A>
<A NAME="@default216"></A>
<A NAME="@default217"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition Exc := option.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition value := Some.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition error := None.</TT><BR>
</DIV><P>This module ends with theorems, 
relating the sorts <CODE>Set</CODE> and
<CODE>Prop</CODE> in a way which is consistent with the realizability
interpretation.
<A NAME="@default218"></A>
<A NAME="@default219"></A>
<A NAME="@default220"></A>
<A NAME="@default221"></A>
<A NAME="@default222"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition except := False_rec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Notation Except := (except _).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem absurd_set : forall (A:Prop) (C:Set), A -</TT><TT>&gt;</TT><TT> </TT><TT>~</TT><TT> A -</TT><TT>&gt;</TT><TT> C.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem and_rec :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (A B:Prop) (P:Set), (A -</TT><TT>&gt;</TT><TT> B -</TT><TT>&gt;</TT><TT> P) -</TT><TT>&gt;</TT><TT> A /</TT><TT>\</TT><TT> B -</TT><TT>&gt;</TT><TT> P.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc73">3.1.5</A>  Basic Arithmetics</H3><P>The basic library includes a few elementary properties of natural
numbers, together with the definitions of predecessor, addition and
multiplication<SUP><A NAME="text7" HREF="#note7">5</A></SUP>. It also
provides a scope <TT>nat_scope</TT> gathering standard notations for
common operations (+,*) and a decimal notation for numbers. That is he
can write <TT>3</TT> for <TT>(S (S (S O)))</TT>. This also works on
the left hand side of a <TT>match</TT> expression (see for example
section <A HREF="Reference-Manual012.html#refine-example">10.1</A>). This scope is opened by default.</P><P>The following example is not part of the standard library, but it
shows the usage of the notations:</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint even (n:nat) : bool :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> true</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 1 =</TT><TT>&gt;</TT><TT> false</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S (S n) =</TT><TT>&gt;</TT><TT> even n</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
</DIV><P><A NAME="@default223"></A>
<A NAME="@default224"></A>
<A NAME="@default225"></A>
<A NAME="@default226"></A>
<A NAME="@default227"></A>
<A NAME="@default228"></A>
<A NAME="@default229"></A>
<A NAME="@default230"></A>
<A NAME="@default231"></A>
<A NAME="@default232"></A>
<A NAME="@default233"></A>
<A NAME="@default234"></A>
<A NAME="@default235"></A>
<A NAME="@default236"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem eq_S : forall x y:nat, x = y -</TT><TT>&gt;</TT><TT> S x = S y.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition pred (n:nat) : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S u =</TT><TT>&gt;</TT><TT> u</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem pred_Sn : forall m:nat, m = pred (S m).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem eq_add_S : forall n m:nat, S n = S m -</TT><TT>&gt;</TT><TT> n = m.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hint Immediate eq_add_S : core.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem not_eq_S : forall n m:nat, n </TT><TT>&lt;</TT><TT>&gt;</TT><TT> m -</TT><TT>&gt;</TT><TT> S n </TT><TT>&lt;</TT><TT>&gt;</TT><TT> S m.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition IsSucc (n:nat) : Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> False</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> True</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem O_S : forall n:nat, 0 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> S n.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem n_Sn : forall n:nat, n </TT><TT>&lt;</TT><TT>&gt;</TT><TT> S n.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint plus (n m:nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> m</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> S (plus p m)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma plus_n_O : forall n:nat, n = plus n 0.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma plus_n_Sm : forall n m:nat, S (plus n m) = plus n (S m).</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint mult (n m:nat) {struct n} : nat :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   match n with</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | 0 =</TT><TT>&gt;</TT><TT> 0</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | S p =</TT><TT>&gt;</TT><TT> m + mult p m</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   end.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma mult_n_O : forall n:nat, 0 = mult n 0.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma mult_n_Sm : forall n m:nat, plus (mult n m) n = mult n (S m).</TT><BR>
</DIV><P>Finally, it gives the definition of the usual orderings <CODE>le</CODE>,
<CODE>lt</CODE>, <CODE>ge</CODE>, and <CODE>gt</CODE>.
<A NAME="@default237"></A>
<A NAME="@default238"></A>
<A NAME="@default239"></A>
<A NAME="@default240"></A>
<A NAME="@default241"></A>
<A NAME="@default242"></A>
<A NAME="le"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive le (n:nat) : nat -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | le_n : le n n</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   | le_S : forall m:nat, le n m -</TT><TT>&gt;</TT><TT> le n (S m).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Infix "+" := plus : nat_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition lt (n m:nat) := S n </TT><TT>&lt;</TT><TT>= m.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition ge (n m:nat) := m </TT><TT>&lt;</TT><TT>= n.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition gt (n m:nat) := m </TT><TT>&lt;</TT><TT> n.</TT><BR>
</DIV><P>Properties of these relations are not initially known, but may be
required by the user from modules <CODE>Le</CODE> and <CODE>Lt</CODE>. Finally,
<CODE>Peano</CODE> gives some lemmas allowing pattern-matching, and a double
induction principle.</P><P><A NAME="@default243"></A>
<A NAME="@default244"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem nat_case :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (n:nat) (P:nat -</TT><TT>&gt;</TT><TT> Prop), P 0 -</TT><TT>&gt;</TT><TT> (forall m:nat, P (S m)) -</TT><TT>&gt;</TT><TT> P n.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem nat_double_ind :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall R:nat -</TT><TT>&gt;</TT><TT> nat -</TT><TT>&gt;</TT><TT> Prop,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall n:nat, R 0 n) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall n:nat, R (S n) 0) -</TT><TT>&gt;</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall n m:nat, R n m -</TT><TT>&gt;</TT><TT> R (S n) (S m)) -</TT><TT>&gt;</TT><TT> forall n m:nat, R n m.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc74">3.1.6</A>  Well-founded recursion</H3><P>The basic library contains the basics of well-founded recursion and 
well-founded induction<SUP><A NAME="text8" HREF="#note8">6</A></SUP>.
<A NAME="@default245"></A>
<A NAME="@default246"></A>
<A NAME="@default247"></A>
<A NAME="@default248"></A>
<A NAME="@default249"></A>
<A NAME="@default250"></A>
<A NAME="@default251"></A></P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section Well_founded.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable A : Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable R : A -</TT><TT>&gt;</TT><TT> A -</TT><TT>&gt;</TT><TT> Prop.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive Acc : A -</TT><TT>&gt;</TT><TT> Prop :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     Acc_intro : forall x:A, (forall y:A, R y x -</TT><TT>&gt;</TT><TT> Acc y) -</TT><TT>&gt;</TT><TT> Acc x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Acc_inv : forall x:A, Acc x -</TT><TT>&gt;</TT><TT> forall y:A, R y x -</TT><TT>&gt;</TT><TT> Acc y.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section AccRec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P : A -</TT><TT>&gt;</TT><TT> Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable F :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall x:A,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       (forall y:A, R y x -</TT><TT>&gt;</TT><TT> Acc y) -</TT><TT>&gt;</TT><TT> (forall y:A, R y x -</TT><TT>&gt;</TT><TT> P y) -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint Acc_rec (x:A) (a:Acc x) {struct a} : P x :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   F x (Acc_inv x a)</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     (fun (y:A) (h:R y x) =</TT><TT>&gt;</TT><TT> Acc_rec y (Acc_inv x a y h)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End AccRec.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition well_founded := forall a:A, Acc a.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis Rwf : well_founded.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem well_founded_induction :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall P:A -</TT><TT>&gt;</TT><TT> Set,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall x:A, (forall y:A, R y x -</TT><TT>&gt;</TT><TT> P y) -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall a:A, P a.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Theorem well_founded_ind :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall P:A -</TT><TT>&gt;</TT><TT> Prop,</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    (forall x:A, (forall y:A, R y x -</TT><TT>&gt;</TT><TT> P y) -</TT><TT>&gt;</TT><TT> P x) -</TT><TT>&gt;</TT><TT> forall a:A, P a.</TT><BR>
</DIV><P>

<TT>Acc_rec</TT> can be used to define functions by fixpoints using
well-founded relations to justify termination. Assuming
extensionality of the functional used for the recursive call, the
fixpoint equation can be proved.
<A NAME="@default252"></A>
<A NAME="@default253"></A>
<A NAME="@default254"></A>
<A NAME="@default255"></A>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Section FixPoint.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable P : A -</TT><TT>&gt;</TT><TT> Set.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Variable F : forall x:A, (forall y:A, R y x -</TT><TT>&gt;</TT><TT> P y) -</TT><TT>&gt;</TT><TT> P x.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Fixpoint Fix_F (x:A) (r:Acc x) {struct r} : P x :=</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>   F x (fun (y:A) (p:R y x) =</TT><TT>&gt;</TT><TT> Fix_F y (Acc_inv x r y p)).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Definition Fix (x:A) := Fix_F x (Rwf x).</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Hypothesis F_ext :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>     forall (x:A) (f g:forall y:A, R y x -</TT><TT>&gt;</TT><TT> P y),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>       (forall (y:A) (p:R y x), f y p = g y p) -</TT><TT>&gt;</TT><TT> F x f = F x g.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Fix_F_eq :</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>  forall (x:A) (r:Acc x),</TT><BR>
<TT>Coq </TT><TT>&lt;</TT><TT>    F x (fun (y:A) (p:R y x) =</TT><TT>&gt;</TT><TT> Fix_F y (Acc_inv x r y p)) = Fix_F x r.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma Fix_F_inv : forall (x:A) (r s:Acc x), Fix_F x r = Fix_F x s.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Lemma fix_eq : forall x:A, Fix x = F x (fun (y:A) (p:R y x) =</TT><TT>&gt;</TT><TT> Fix y).</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> End FixPoint.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> End Well_founded.</TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc75">3.1.7</A>  Accessing the <FONT COLOR=purple>Type</FONT> level</H3><P>The basic library includes the definitions<SUP><A NAME="text9" HREF="#note9">7</A></SUP> of the counterparts of some datatypes and logical
quantifiers at the <CODE>Type</CODE> level: negation, pair, and properties
of <TT>identity</TT>.</P><P><A NAME="@default256"></A>
<A NAME="@default257"></A>
<A NAME="@default258"></A>

</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Definition notT (A:Type) := A -</TT><TT>&gt;</TT><TT> False.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Inductive prodT (A B:Type) : Type := pairT (_:A) (_:B).</TT><BR>
</DIV><P>At the end, it defines datatypes at the <FONT COLOR=purple>Type</FONT> level.</P><H2 CLASS="section"><A NAME="toc23"></A><A NAME="htoc76">3.2</A>  The standard library</H2><H3 CLASS="subsection"><A NAME="htoc77">3.2.1</A>  Survey</H3><P>The rest of the standard library is structured into the following 
subdirectories:</P><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Logic</B></TD><TD VALIGN=top ALIGN=left>Classical logic and dependent equality</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Arith</B></TD><TD VALIGN=top ALIGN=left>Basic Peano arithmetic</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>NArith</B></TD><TD VALIGN=top ALIGN=left>Basic positive integer arithmetic</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>ZArith</B></TD><TD VALIGN=top ALIGN=left>Basic relative integer arithmetic</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Bool</B></TD><TD VALIGN=top ALIGN=left>Booleans (basic functions and results)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Lists</B></TD><TD VALIGN=top ALIGN=left>Monomorphic and polymorphic lists (basic functions and
results), Streams (infinite sequences defined with co-inductive
types)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Sets</B></TD><TD VALIGN=top ALIGN=left>Sets (classical, constructive, finite, infinite, power set,
etc.)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>FSets</B></TD><TD VALIGN=top ALIGN=left>Specification and implementations of finite sets and finite
maps (by lists and by AVL trees)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>IntMap</B></TD><TD VALIGN=top ALIGN=left>Representation of finite sets by an efficient
structure of map (trees indexed by binary integers).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Reals</B></TD><TD VALIGN=top ALIGN=left>Axiomatization of real numbers (classical, basic functions, 
integer part, fractional part, limit, derivative, Cauchy 
series, power series and results,...)</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Relations</B></TD><TD VALIGN=top ALIGN=left>Relations (definitions and basic results).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Sorting</B></TD><TD VALIGN=top ALIGN=left>Sorted list (basic definitions and heapsort correctness).</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Strings</B></TD><TD VALIGN=top ALIGN=left>8-bits characters and strings</TD></TR>
<TR><TD VALIGN=top ALIGN=left NOWRAP> <B>Wellfounded</B></TD><TD VALIGN=top ALIGN=left>Well-founded relations (basic results).</TD></TR>
</TABLE><P>
<BR>
</P><P>These directories belong to the initial load path of the system, and
the modules they provide are compiled at installation time. So they
are directly accessible with the command <CODE>Require</CODE> (see
chapter <A HREF="Reference-Manual008.html#Other-commands">6</A>). </P><P>The different modules of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library are described in the
additional document <CODE>Library.dvi</CODE>. They are also accessible on the WWW
through the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> homepage
<SUP><A NAME="text10" HREF="#note10">8</A></SUP>.</P><H3 CLASS="subsection"><A NAME="htoc78">3.2.2</A>  Notations for integer arithmetics</H3><P>
<A NAME="@default259"></A></P><P>On figure <A HREF="#zarith-syntax">3.2.2</A> is described the syntax of expressions
for integer arithmetics. It is provided by requiring and opening the
module <TT>ZArith</TT> and opening scope <TT>Z_scope</TT>.</P><P><A NAME="@default260"></A>
<A NAME="@default261"></A>
<A NAME="@default262"></A>
<A NAME="@default263"></A>
<A NAME="@default264"></A>
<A NAME="@default265"></A>
<A NAME="@default266"></A>
<A NAME="@default267"></A>
<A NAME="@default268"></A>
<A NAME="@default269"></A></P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Notation</TD><TD ALIGN=left NOWRAP>Interpretation</TD><TD ALIGN=left NOWRAP>Precedence</TD><TD ALIGN=left NOWRAP>Associativity</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zlt</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>Zle</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zgt</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>Zge</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ?= _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zcompare</TT></TD><TD ALIGN=left NOWRAP>70</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zplus</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zminus</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zmult</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ / _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zdiv</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ mod _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zmod</TT></TD><TD ALIGN=left NOWRAP>40</TD><TD ALIGN=left NOWRAP>no</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>- _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zopp</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ^ _</CODE></TD><TD ALIGN=left NOWRAP><TT>Zpower</TT></TD><TD ALIGN=left NOWRAP>&nbsp;</TD><TD ALIGN=left NOWRAP>&nbsp;</TD></TR>
</TABLE>
</DIV>
<A NAME="zarith-syntax"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.4: Definition of the scope for integer arithmetics (<TT>Z_scope</TT>)</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><P>Figure <A HREF="#zarith-syntax">3.2.2</A> shows the notations provided by <TT>Z_scope</TT>. It specifies how notations are interpreted and, when not
already reserved, the precedence and associativity.</P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import ZArith.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check  (2 + 3)%Z.</TT><BR>
<TT><I>(2 + 3)%Z</I></TT><BR>
<TT><I>     : Z</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Scope Z_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check 2 + 3.</TT><BR>
<TT><I>2 + 3</I></TT><BR>
<TT><I>     : Z</I></TT><BR>
</DIV><H3 CLASS="subsection"><A NAME="htoc79">3.2.3</A>  Peano's arithmetic (<TT>nat</TT>)</H3><P>
<A NAME="@default270"></A>
<A NAME="@default271"></A></P><P>While in the initial state, many operations and predicates of Peano's
arithmetic are defined, further operations and results belong to other
modules. For instance, the decidability of the basic predicates are
defined here. This is provided by requiring the module <TT>Arith</TT>.</P><P>Figure <A HREF="#nat-syntax">3.2.3</A> describes notation available in scope <TT>nat_scope</TT>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Notation</TD><TD ALIGN=left NOWRAP>Interpretation</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>lt</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>le</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>gt</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>ge</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD><TD ALIGN=left NOWRAP><TT>plus</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD><TD ALIGN=left NOWRAP><TT>minus</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD><TD ALIGN=left NOWRAP><TT>mult</TT></TD></TR>
</TABLE>
</DIV>
<A NAME="nat-syntax"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.5: Definition of the scope for natural numbers (<TT>nat_scope</TT>)</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><H3 CLASS="subsection"><A NAME="htoc80">3.2.4</A>  Real numbers library</H3><H4 CLASS="subsubsection">Notations for real numbers</H4><P>
<A NAME="@default272"></A></P><P>This is provided by requiring and opening the module <TT>Reals</TT> and
opening scope <TT>R_scope</TT>. This set of notations is very similar to
the notation for integer arithmetics. The inverse function was added.
</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Notation</TD><TD ALIGN=left NOWRAP>Interpretation</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &lt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rlt</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>Rle</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ &gt; _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rgt</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &gt;= y</CODE></TD><TD ALIGN=left NOWRAP><TT>Rge</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt; y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt; y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt; z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt; z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>x &lt;= y &lt;= z</CODE></TD><TD ALIGN=left NOWRAP><TT>x &lt;= y </TT><CODE><TT>/\</TT></CODE><TT> y &lt;= z</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ + _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rplus</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ - _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rminus</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ * _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rmult</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ / _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rdiv</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>- _</CODE></TD><TD ALIGN=left NOWRAP><TT>Ropp</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>/ _</CODE></TD><TD ALIGN=left NOWRAP><TT>Rinv</TT></TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ^ _</CODE></TD><TD ALIGN=left NOWRAP><TT>pow</TT></TD></TR>
</TABLE>
</DIV>
<A NAME="reals-syntax"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.6: Definition of the scope for real arithmetics (<TT>R_scope</TT>)</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import Reals.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check  (2 + 3)%R.</TT><BR>
<TT><I>(2 + 3)%R</I></TT><BR>
<TT><I>     : R</I></TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Open Scope R_scope.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Check 2 + 3.</TT><BR>
<TT><I>2 + 3</I></TT><BR>
<TT><I>     : R</I></TT><BR>
</DIV><H4 CLASS="subsubsection">Some tactics</H4><P>In addition to the <CODE>ring</CODE>, <CODE>field</CODE> and <CODE>fourier</CODE>
tactics (see Chapter <A HREF="Reference-Manual010.html#Tactics">8</A>) there are:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<TT>discrR</TT> <A NAME="@default273"></A><A NAME="@tactic0"></A><P>Proves that a real integer constant <I>c</I><SUB>1</SUB> is different from another
real integer constant <I>c</I><SUB>2</SUB>. </P><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import DiscrR.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal 5 </TT><TT>&lt;</TT><TT>&gt;</TT><TT> 0.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> discrR.</TT><BR>
<TT><I>Proof completed.</I></TT><BR>
</DIV></LI><LI CLASS="li-itemize"><TT>split_Rabs</TT> allows to unfold <TT>Rabs</TT> constant and splits 
corresponding conjonctions.
<A NAME="@default274"></A><A NAME="@tactic1"></A><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import SplitAbsolu.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x:R, x </TT><TT>&lt;</TT><TT>= Rabs x.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intro; split_Rabs.</TT><BR>
<TT><I>2 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : R</I></TT><BR>
<TT><I>  r : x </I></TT><TT><I>&lt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x </I></TT><TT><I>&lt;</I></TT><TT><I>= - x</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> x </I></TT><TT><I>&lt;</I></TT><TT><I>= x</I></TT><BR>
</DIV></LI><LI CLASS="li-itemize"><TT>split_Rmult</TT> allows to split a condition that a product is
non null into subgoals corresponding to the condition on each
operand of the product. 
<A NAME="@default275"></A><A NAME="@tactic2"></A><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> Require Import SplitRmult.</TT><BR>
<BR>
<TT>Coq </TT><TT>&lt;</TT><TT> Goal forall x y z:R, x * y * z </TT><TT>&lt;</TT><TT>&gt;</TT><TT> 0.</TT><BR>
</DIV><DIV CLASS="flushleft">
<TT>Coq </TT><TT>&lt;</TT><TT> intros; split_Rmult.</TT><BR>
<TT><I>3 subgoals</I></TT><BR>
<TT><I>  </I></TT><BR>
<TT><I>  x : R</I></TT><BR>
<TT><I>  y : R</I></TT><BR>
<TT><I>  z : R</I></TT><BR>
<TT><I>  ============================</I></TT><BR>
<TT><I>   x </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>subgoal 2 is:</I></TT><BR>
<TT><I> y </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
<TT><I>subgoal 3 is:</I></TT><BR>
<TT><I> z </I></TT><TT><I>&lt;</I></TT><TT><I>&gt;</I></TT><TT><I> 0</I></TT><BR>
</DIV></LI></UL><P>All this tactics has been written with the tactic language Ltac
described in Chapter <A HREF="Reference-Manual011.html#TacticLanguage">9</A>. More details are available
in document <TT>http://coq.inria.fr/~desmettr/Reals.ps</TT>.</P><H3 CLASS="subsection"><A NAME="htoc81">3.2.5</A>  List library</H3><P>
<A NAME="@default276"></A>
<A NAME="@default277"></A>
<A NAME="@default278"></A>
<A NAME="@default279"></A>
<A NAME="@default280"></A>
<A NAME="@default281"></A>
<A NAME="@default282"></A>
<A NAME="@default283"></A>
<A NAME="@default284"></A>
<A NAME="@default285"></A>
<A NAME="@default286"></A></P><P>Some elementary operations on polymorphic lists are defined here. They
can be accessed by requiring module <TT>List</TT>.</P><P>It defines the following notions:
</P><DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP><TT>length</TT></TD><TD ALIGN=left NOWRAP>length</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>head</TT></TD><TD ALIGN=left NOWRAP>first element (with default)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>tail</TT></TD><TD ALIGN=left NOWRAP>all but first element</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>app</TT></TD><TD ALIGN=left NOWRAP>concatenation</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>rev</TT></TD><TD ALIGN=left NOWRAP>reverse</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>nth</TT></TD><TD ALIGN=left NOWRAP>accessing <I>n</I>-th element (with default)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>map</TT></TD><TD ALIGN=left NOWRAP>applying a function</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>flat_map</TT></TD><TD ALIGN=left NOWRAP>applying a function returning lists</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>fold_left</TT></TD><TD ALIGN=left NOWRAP>iterator (from head to tail)</TD></TR>
<TR><TD ALIGN=left NOWRAP><TT>fold_right</TT></TD><TD ALIGN=left NOWRAP>iterator (from tail to head)</TD></TR>
</TABLE>
</DIV><P>Table show notations available when opening scope <TT>list_scope</TT>.</P><BLOCKQUOTE CLASS="figure"><DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV>
<DIV CLASS="center">
<TABLE BORDER=1 CELLSPACING=0 CELLPADDING=1><TR><TD ALIGN=left NOWRAP>Notation</TD><TD ALIGN=left NOWRAP>Interpretation</TD><TD ALIGN=left NOWRAP>Precedence</TD><TD ALIGN=left NOWRAP>Associativity</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ ++ _</CODE></TD><TD ALIGN=left NOWRAP><TT>app</TT></TD><TD ALIGN=left NOWRAP>60</TD><TD ALIGN=left NOWRAP>right</TD></TR>
<TR><TD ALIGN=left NOWRAP><CODE>_ :: _</CODE></TD><TD ALIGN=left NOWRAP><TT>cons</TT></TD><TD ALIGN=left NOWRAP>60</TD><TD ALIGN=left NOWRAP>right</TD></TR>
</TABLE>
</DIV>
<A NAME="list-syntax"></A>
<DIV CLASS="caption"><TABLE CELLSPACING=6 CELLPADDING=0><TR><TD VALIGN=top ALIGN=left>Figure 3.7: Definition of the scope for lists (<TT>list_scope</TT>)</TD></TR>
</TABLE></DIV>
<DIV CLASS="center"><HR WIDTH="80%" SIZE=2></DIV></BLOCKQUOTE><H2 CLASS="section"><A NAME="toc24"></A><A NAME="htoc82">3.3</A>  Users' contributions</H2><P>
<A NAME="@default287"></A>
<A NAME="Contributions"></A></P><P>Numerous users' contributions have been collected and are available at
URL <TT>coq.inria.fr/contribs/</TT>. On this web page, you have a list
of all contributions with informations (author, institution, quick
description, etc.) and the possibility to download them one by one.
There is a small search engine to look for keywords in all
contributions. You will also find informations on how to submit a new
contribution.</P><P>The users' contributions may also be obtained by anonymous FTP from site
<CODE>ftp.inria.fr</CODE>, in directory <CODE>INRIA/coq/</CODE> and
searchable on-line at <TT>http://coq.inria.fr/contribs-eng.html</TT></P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note3" HREF="#text3">1</A></DT><DD CLASS="dd-thefootnotes">Most 
of these constructions are defined in the
<TT>Prelude</TT> module in directory <TT>theories/Init</TT> at the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
root directory; this includes the modules
<TT>Notations</TT>,
<TT>Logic</TT>,
<TT>Datatypes</TT>,
<TT>Specif</TT>,
<TT>Peano</TT>,
and <TT>Wf</TT>.
Module <TT>Logic_Type</TT> also makes it in the initial state
</DD><DT CLASS="dt-thefootnotes"><A NAME="note4" HREF="#text4">2</A></DT><DD CLASS="dd-thefootnotes">They are in <TT>Datatypes.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note5" HREF="#text5">3</A></DT><DD CLASS="dd-thefootnotes">They are defined in module <TT>Specif.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note6" HREF="#text6">4</A></DT><DD CLASS="dd-thefootnotes">This syntax can be found in the module
<TT>SpecifSyntax.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note7" HREF="#text7">5</A></DT><DD CLASS="dd-thefootnotes">This is in module <TT>Peano.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note8" HREF="#text8">6</A></DT><DD CLASS="dd-thefootnotes">This is defined in module <TT>Wf.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note9" HREF="#text9">7</A></DT><DD CLASS="dd-thefootnotes">This is in module
<TT>Logic_Type.v</TT>
</DD><DT CLASS="dt-thefootnotes"><A NAME="note10" HREF="#text10">8</A></DT><DD CLASS="dd-thefootnotes"><TT>http://coq.inria.fr</TT>
</DD></DL>
<HR>
<A HREF="Reference-Manual004.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual006.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
