<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN"
            "http://www.w3.org/TR/REC-html40/loose.dtd">
<HTML>
<HEAD>

<META http-equiv="Content-Type" content="text/html; charset=ISO-8859-1">
<META name="GENERATOR" content="hevea 1.09">
<LINK rel="stylesheet" type="text/css" href="Reference-Manual.css">
<TITLE>Utilities</TITLE>
</HEAD>
<BODY >
<A HREF="Reference-Manual015.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual017.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
<HR>
<H1 CLASS="chapter"><A NAME="htoc322">Chapter 13</A>  Utilities</H1><P><A NAME="Utilities"></A></P><P>The distribution provides utilities to simplify some tedious works
beside proof development, tactics writing or documentation.</P><H2 CLASS="section"><A NAME="toc84"></A><A NAME="htoc323">13.1</A>  Building a toplevel extended with user tactics</H2><P>
<A NAME="Coqmktop"></A><A NAME="@default712"></A></P><P>The native-code version of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> cannot dynamically load user tactics
using Objective Caml code. It is possible to build a toplevel of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>,
with Objective Caml code statically linked, with the tool <TT>coqmktop</TT>.</P><P>For example, one can build a native-code <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel extended with a tactic
which source is in <TT>tactic.ml</TT> with the command 
</P><PRE CLASS="verbatim">     % coqmktop -opt -o mytop.out tactic.cmx
</PRE><P>where <TT>tactic.ml</TT> has been compiled with the native-code
compiler <TT>ocamlopt</TT>. This command generates an executable
called <TT>mytop.out</TT>. To use this executable to compile your <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
files, use <TT>coqc -image mytop.out</TT>.</P><P>A basic example is the native-code version of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> (<TT>coqtop.opt</TT>),
which can be generated by <TT>coqmktop -opt -o coqopt.opt</TT>.</P><H5 CLASS="paragraph">Application: how to use the Objective Caml debugger with Coq.</H5><P>
<A NAME="@default713"></A></P><P>One useful application of <TT>coqmktop</TT> is to build a <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel in
order to debug your tactics with the Objective Caml debugger.
You need to have configured and compiled <SPAN STYLE="font-variant:small-caps">Coq</SPAN> for debugging
(see the file <TT>INSTALL</TT> included in the distribution).
Then, you must compile the Caml modules of your tactic with the
option <TT>-g</TT> (with the bytecode compiler) and build a stand-alone
bytecode toplevel with the following command:</P><BLOCKQUOTE CLASS="quotation">
<TT>% coqmktop -g -o coq-debug</TT> <EM>&lt;your </EM><EM><TT>.cmo</TT></EM><EM> files&gt;</EM>
</BLOCKQUOTE><P>To launch the <SPAN STYLE="font-variant:small-caps">Objective Caml</SPAN> debugger with the image you need to execute it in
an environment which correctly sets the <TT>COQLIB</TT> variable.
Moreover, you have to indicate the directories in which
<TT>ocamldebug</TT> should search for Caml modules.</P><P>A possible solution is to use a wrapper around <TT>ocamldebug</TT>
which detects the executables containing the word <TT>coq</TT>. In
this case, the debugger is called with the required additional
arguments. In other cases, the debugger is simply called without additional
arguments. Such a wrapper can be found in the <TT>dev/</TT>
subdirectory of the sources. </P><H2 CLASS="section"><A NAME="toc85"></A><A NAME="htoc324">13.2</A>  Modules dependencies</H2><P><A NAME="Dependencies"></A><A NAME="@default714"></A>
<A NAME="@default715"></A></P><P>In order to compute modules dependencies (so to use <TT>make</TT>),
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with an appropriate tool, <TT>coqdep</TT>.</P><P><TT>coqdep</TT> computes inter-module dependencies for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and
<SPAN STYLE="font-variant:small-caps">Objective Caml</SPAN> programs, and prints the dependencies on the standard
output in a format readable by make. When a directory is given as
argument, it is recursively looked at.</P><P>Dependencies of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> modules are computed by looking at <TT>Require</TT>
commands (<TT>Require</TT>, <TT>Require Export</TT>, <TT>Require Import</TT>,
<TT>Require Implementation</TT>), but also at the command <TT>Declare ML Module</TT>.</P><P>Dependencies of <SPAN STYLE="font-variant:small-caps">Objective Caml</SPAN> modules are computed by looking at
<CODE>open</CODE> commands and the dot notation <EM>module.value</EM>. However,
this is done approximatively and you are advised to use <TT>ocamldep</TT>
instead for the <SPAN STYLE="font-variant:small-caps">Objective Caml</SPAN> modules dependencies.</P><P>See the man page of <TT>coqdep</TT> for more details and options.</P><H2 CLASS="section"><A NAME="toc86"></A><A NAME="htoc325">13.3</A>  Creating a <TT>Makefile</TT> for <SPAN STYLE="font-variant:small-caps">Coq</SPAN> modules</H2><P>
<A NAME="Makefile"></A>
<A NAME="@default716"></A>
<A NAME="@default717"></A></P><P>When a proof development becomes large and is split into several files,
it becomes crucial to use a tool like <TT>make</TT> to compile <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
modules.</P><P>The writing of a generic and complete <TT>Makefile</TT> may be a tedious work
and that's why <SPAN STYLE="font-variant:small-caps">Coq</SPAN> provides a tool to automate its creation,
<TT>coq_makefile</TT>. Given the files to compile, the command <TT>coq_makefile</TT> prints a 
<TT>Makefile</TT> on the standard output. So one has just to run the
command:</P><BLOCKQUOTE CLASS="quotation">
<TT>% coq_makefile</TT> <EM>file</EM><SUB><EM>1</EM></SUB><EM>.v &#X2026; file</EM><SUB><EM><I>n</I></EM></SUB><EM>.v</EM> <TT>&gt; Makefile</TT>
</BLOCKQUOTE><P>The resulted <TT>Makefile</TT> has a target <TT>depend</TT> which computes the
dependencies and puts them in a separate file <TT>.depend</TT>, which is
included by the <TT>Makefile</TT>. 
Therefore, you should create such a file before the first invocation
of make. You can for instance use the command </P><BLOCKQUOTE CLASS="quotation">
<TT>% touch .depend</TT>
</BLOCKQUOTE><P>Then, to initialize or update the modules dependencies, type in:</P><BLOCKQUOTE CLASS="quotation">
<TT>% make depend</TT>
</BLOCKQUOTE><P>There is a target <TT>all</TT> to compile all the files <EM>file</EM><SUB><EM>1</EM></SUB><EM>
&#X2026; file</EM><SUB><EM><I>n</I></EM></SUB>, and a generic target to produce a <TT>.vo</TT> file from
the corresponding <TT>.v</TT> file (so you can do <TT>make</TT> <EM>file</EM><TT>.vo</TT>
to compile the file <EM>file</EM><TT>.v</TT>).</P><P><TT>coq_makefile</TT> can also handle the case of ML files and
subdirectories. For more options type</P><BLOCKQUOTE CLASS="quotation">
<TT>% coq_makefile &#X2013;help</TT>
</BLOCKQUOTE><P><BR>
<B>Warning: </B>To compile a project containing <SPAN STYLE="font-variant:small-caps">Objective Caml</SPAN> files you must keep
the sources of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> somewhere and have an environment variable named
<TT>COQTOP</TT> that points to that directory.</P><H2 CLASS="section"><A NAME="toc87"></A><A NAME="htoc326">13.4</A>  Documenting <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files with coqdoc</H2><P>
<A NAME="coqdoc"></A>
<A NAME="@default718"></A></P><P><FONT COLOR=purple>coqdoc</FONT> is a documentation tool for the proof assistant
<SPAN STYLE="font-variant:small-caps">Coq</SPAN>, similar to <FONT COLOR=purple>javadoc</FONT> or <FONT COLOR=purple>ocamldoc</FONT>. 
The task of <FONT COLOR=purple>coqdoc</FONT> is
</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
to produce a nice L<sup>A</sup>T<sub>E</sub>X and/or HTML document from the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> 
sources, readable for a human and not only for the proof assistant;
</LI><LI CLASS="li-enumerate">to help the user navigating in his own (or third-party) sources.
</LI></OL><H3 CLASS="subsection"><A NAME="htoc327">13.4.1</A>  Principles</H3><P>Documentation is inserted into <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files as <EM>special comments</EM>. 
Thus your files will compile as usual, whether you use <FONT COLOR=purple>coqdoc</FONT> or not.
<FONT COLOR=purple>coqdoc</FONT> presupposes that the given <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files are well-formed (at
least lexically). Documentation starts with
<TT>(**</TT>, followed by a space, and ends with the pending <TT>*)</TT>. 
The documentation format is inspired
by Todd A. Coram's <EM>Almost Free Text (AFT)</EM> tool: it is mainly
ASCII text with some syntax-light controls, described below.
<FONT COLOR=purple>coqdoc</FONT> is robust: it shouldn't fail, whatever the input is. But
remember: &#X201C;garbage in, garbage out&#X201D;.</P><H5 CLASS="paragraph"><SPAN STYLE="font-variant:small-caps">Coq</SPAN> material inside documentation.</H5><P>
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> material is quoted between the
delimiters <TT>[</TT> and <TT>]</TT>. Square brackets may be nested,
the inner ones being understood as being part of the quoted code (thus
you can quote a term like [<I>x</I>:<I>T</I>]<I>u</I> by writing
<TT>[[x:T]u]</TT>). Inside quotations, the code is pretty-printed in
the same way as it is in code parts.</P><P>Pre-formatted vernacular is enclosed by <TT>[[</TT> and
<TT>]]</TT>. The former must be followed by a newline and the latter
must follow a newline.</P><H5 CLASS="paragraph">Pretty-printing.</H5><P>
<FONT COLOR=purple>coqdoc</FONT> uses different faces for identifiers and keywords. 
The pretty-printing of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> tokens (identifiers or symbols) can be
controlled using one of the following commands:
</P><PRE>
(** printing <EM>token</EM> %...L<sup>A</sup>T<sub>E</sub>X...% #...HTML...# *)
</PRE><P>
or
</P><PRE>
(** printing <EM>token</EM> $...L<sup>A</sup>T<sub>E</sub>X math...$ #...HTML...# *)
</PRE><P>
It gives the L<sup>A</sup>T<sub>E</sub>X and HTML texts to be produced for the given <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
token. One of the L<sup>A</sup>T<sub>E</sub>X or HTML text may be ommitted, causing the
default pretty-printing to be used for this token.</P><P>The printing for one token can be removed with
</P><PRE>
(** remove printing <EM>token</EM> *)
</PRE><P>Initially, the pretty-printing table contains the following mapping:
</P><DIV CLASS="center">
<TABLE CELLSPACING=6 CELLPADDING=0><TR><TD ALIGN=left NOWRAP> <CODE>-&gt;</CODE></TD><TD ALIGN=left NOWRAP>&#X2192;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>&lt;-</CODE></TD><TD ALIGN=left NOWRAP>&#X2190;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>*</CODE></TD><TD ALIGN=left NOWRAP>×</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>&lt;=</CODE></TD><TD ALIGN=left NOWRAP>&#X2264;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>&gt;=</CODE></TD><TD ALIGN=left NOWRAP>&#X2265;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>=&gt;</CODE></TD><TD ALIGN=left NOWRAP>&#X21D2;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>&lt;&gt;</CODE></TD><TD ALIGN=left NOWRAP>&#X2260;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>&lt;-&gt;</CODE></TD><TD ALIGN=left NOWRAP>&#X2194;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>|-</CODE></TD><TD ALIGN=left NOWRAP>&#X22A2;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD></TR>
<TR><TD ALIGN=left NOWRAP> <CODE>\/</CODE></TD><TD ALIGN=left NOWRAP>&#X2228;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>/\</CODE></TD><TD ALIGN=left NOWRAP>&#X2227;</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD><TD ALIGN=left NOWRAP> <CODE>~</CODE></TD><TD ALIGN=left NOWRAP>¬</TD><TD VALIGN=top ALIGN=center NOWRAP>        </TD></TR>
</TABLE>
</DIV><P>
Any of these can be overwritten or suppressed using the
<TT>printing</TT> commands.</P><P>Important note: the recognition of tokens is done by a (ocaml)lex
automaton and thus applies the longest-match rule. For instance,
<CODE>-&gt;~</CODE> is recognized as a single token, where <SPAN STYLE="font-variant:small-caps">Coq</SPAN> sees two
tokens. It is the responsability of the user to insert space between
tokens <EM>or</EM> to give pretty-printing rules for the possible
combinations, e.g. 
</P><PRE CLASS="verbatim">(** printing -&gt;~ %\ensuremath{\rightarrow\lnot}% *)
</PRE><H5 CLASS="paragraph">Sections.</H5><P>
Sections are introduced by 1 to 4 leading stars (i.e. at the beginning of the
line). One star is a section, two stars a sub-section, etc.
The section title is given on the remaining of the line.
Example:
</P><PRE CLASS="verbatim">    (** * Well-founded relations
  
        In this section, we introduce...  *)
</PRE><H5 CLASS="paragraph">Lists.</H5><P>
List items are introduced by 1 to 4 leading dashes.
Deepness of the list is indicated by the number of dashes.
List ends with a blank line.
Example:
</P><PRE CLASS="verbatim">    This module defines
        - the predecessor [pred]
        - the addition [plus]
        - order relations:
          -- less or equal [le]
          -- less [lt]
</PRE><H5 CLASS="paragraph">Rules.</H5><P>
More than 4 leading dashes produce an horizontal rule.</P><H5 CLASS="paragraph">Escapings to L<sup>A</sup>T<sub>E</sub>X and HTML.</H5><P>
Pure L<sup>A</sup>T<sub>E</sub>X or HTML material can be inserted using the following
escape sequences:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
<CODE>$...LaTeX stuff...$</CODE> inserts some L<sup>A</sup>T<sub>E</sub>X material in math mode.
Simply discarded in HTML output.</LI><LI CLASS="li-itemize"><CODE>%...LaTeX stuff...%</CODE> inserts some L<sup>A</sup>T<sub>E</sub>X material.
Simply discarded in HTML output.</LI><LI CLASS="li-itemize"><CODE>#...HTML stuff...#</CODE> inserts some HTML material. Simply
discarded in L<sup>A</sup>T<sub>E</sub>X output.
</LI></UL><H5 CLASS="paragraph">Verbatim.</H5><P> 
Verbatim material is introduced by a leading <CODE>&lt;&lt;</CODE> and closed by
<CODE>&gt;&gt;</CODE>. Example:
</P><PRE CLASS="verbatim">Here is the corresponding caml code:
&lt;&lt;
  let rec fact n = 
    if n &lt;= 1 then 1 else n * fact (n-1)
&gt;&gt;
</PRE><H5 CLASS="paragraph">Hyperlinks.</H5><P>
Hyperlinks can be inserted into the HTML output, so that any
identifier is linked to the place of its definition.</P><P>In order to get hyperlinks you need to first compile your <SPAN STYLE="font-variant:small-caps">Coq</SPAN> file
using <TT>coqc --dump-glob </TT><TT><EM>file</EM></TT>; this appends 
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> names resolutions done during the compilation to file
<TT><EM>file</EM></TT>. Take care of erasing this file, if any, when
starting the whole compilation process.</P><P>Then invoke <TT>coqdoc --glob-from </TT><TT><EM>file</EM></TT> to tell
<FONT COLOR=purple>coqdoc</FONT> to look for name resolutions into the file <TT><EM>file</EM></TT>.</P><P>Identifiers from the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library are linked to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
web site at <TT>http://coq.inria.fr/library/</TT>. This behavior can be
changed using command line options <TT>--no-externals</TT> and
<TT>--coqlib</TT>; see below.</P><H5 CLASS="paragraph">Hiding / Showing parts of the source.</H5><P>
Some parts of the source can be hidden using command line options
<TT>-g</TT> and <TT>-l</TT> (see below), or using such comments:
</P><PRE>
(* begin hide *)
<EM>some Coq material</EM>
(* end hide *)
</PRE><P>
Conversely, some parts of the source which would be hidden can be
shown using such comments: 
</P><PRE>
(* begin show *)
<EM>some Coq material</EM>
(* end show *)
</PRE><P>
The latter cannot be used around some inner parts of a proof, but can
be used around a whole proof.</P><H3 CLASS="subsection"><A NAME="htoc328">13.4.2</A>  Usage</H3><P><FONT COLOR=purple>coqdoc</FONT> is invoked on a shell command line as follows:
</P><TABLE CLASS="display dcenter"><TR VALIGN="middle"><TD CLASS="dcell">  <TT>coqdoc </TT>&lt;<I>options and files</I>&gt;
</TD></TR>
</TABLE><P>
Any command line argument which is not an option is considered to be a
file (even if it starts with a <CODE>-</CODE>). <SPAN STYLE="font-variant:small-caps">Coq</SPAN> files are identified
by the suffixes <CODE>.v</CODE> and <CODE>.g</CODE> and L<sup>A</sup>T<sub>E</sub>X files by the
suffix <CODE>.tex</CODE>. </P><DL CLASS="description"><DT CLASS="dt-description">
<B>HTML output</B></DT><DD CLASS="dd-description">  <P>This is the default output.
One HTML file is created for each <SPAN STYLE="font-variant:small-caps">Coq</SPAN> file given on the command line,
together with a file <TT>index.html</TT> (unless option
<TT>-no-index</TT> is passed). The HTML pages use a style sheet
named <TT>style.css</TT>. Such a file is distributed with <FONT COLOR=purple>coqdoc</FONT>.</P></DD><DT CLASS="dt-description"><B>L<sup>A</sup>T<sub>E</sub>X output</B></DT><DD CLASS="dd-description">  <P>A single L<sup>A</sup>T<sub>E</sub>X file is created, on standard output. It can be
redirected to a file with option <TT>-o</TT>. 
The order of files on the command line is kept in the final
document. L<sup>A</sup>T<sub>E</sub>X files given on the command line are copied `as is'
in the final document .
DVI and PostScript can be produced directly with the options
<TT>-dvi</TT> and <TT>-ps</TT> respectively.</P></DD><DT CLASS="dt-description"><B>T<sub>E</sub>Xmacs output</B></DT><DD CLASS="dd-description">  <P>To translate the input files to T<sub>E</sub>Xmacs format, to be used by
the T<sub>E</sub>Xmacs Coq interface 
(see <TT>http://www-sop.inria.fr/lemme/Philippe.Audebaud/tmcoq/</TT>).
</P></DD></DL><H4 CLASS="subsubsection">Command line options</H4><H5 CLASS="paragraph">Overall options</H5><DL CLASS="description"><DT CLASS="dt-description"><B><TT>--html</TT></B></DT><DD CLASS="dd-description">  <P>Select a HTML output.</P></DD><DT CLASS="dt-description"><B><TT>--latex</TT></B></DT><DD CLASS="dd-description">  <P>Select a L<sup>A</sup>T<sub>E</sub>X output.</P></DD><DT CLASS="dt-description"><B><TT>--dvi</TT></B></DT><DD CLASS="dd-description">  <P>Select a DVI output.</P></DD><DT CLASS="dt-description"><B><TT>--ps</TT></B></DT><DD CLASS="dd-description">  <P>Select a PostScript output.</P></DD><DT CLASS="dt-description"><B><TT>--texmacs</TT></B></DT><DD CLASS="dd-description">  <P>Select a T<sub>E</sub>Xmacs output.</P></DD><DT CLASS="dt-description"><B><TT>&#X2013;stdout</TT></B></DT><DD CLASS="dd-description">  <P>Write output to stdout.</P></DD><DT CLASS="dt-description"><B><TT>-o </TT></B><B><I>file</I></B><B>, </B><B><TT>--output </TT></B><B><I>file</I></B></DT><DD CLASS="dd-description">  <P>Redirect the output into the file `<I>file</I>' (meaningless with
<TT>-html</TT>).</P></DD><DT CLASS="dt-description"><B><TT>-d </TT></B><B><I>dir</I></B><B>, </B><B><TT>--directory </TT></B><B><I>dir</I></B></DT><DD CLASS="dd-description">  <P>Output files into directory `<I>dir</I>' instead of current
directory (option <TT>-d</TT> does not change the filename specified
with option <TT>-o</TT>, if any).</P></DD><DT CLASS="dt-description"><B><TT>-s </TT></B><B>, </B><B><TT>--short</TT></B></DT><DD CLASS="dd-description">  <P>Do not insert titles for the files. The default behavior is to
insert a title like &#X201C;Library Foo&#X201D; for each file.</P></DD><DT CLASS="dt-description"><B><TT>-t </TT></B><B><I>string</I></B><B>, 
</B><B><TT>--title </TT></B><B><I>string</I></B></DT><DD CLASS="dd-description">  <P>Set the document title. </P></DD><DT CLASS="dt-description"><B><TT>--body-only</TT></B></DT><DD CLASS="dd-description">  <P>Suppress the header and trailer of the final document. Thus, you can
insert the resulting document into a larger one.</P></DD><DT CLASS="dt-description"><B><TT>-p</TT></B><B> </B><B><I>string</I></B><B>, </B><B><TT>--preamble</TT></B><B> </B><B><I>string</I></B></DT><DD CLASS="dd-description"> <P>Insert some material in the L<sup>A</sup>T<sub>E</sub>X preamble, right before
<CODE>\begin{document}</CODE> (meaningless with <TT>-html</TT>).</P></DD><DT CLASS="dt-description"><B><TT>--vernac-file </TT></B><B><I>file</I></B><B>,
</B><B><TT>--tex-file </TT></B><B><I>file</I></B></DT><DD CLASS="dd-description">  <P>Considers the file `<I>file</I>' respectively as a <CODE>.v</CODE>
(or <CODE>.g</CODE>) file or a <CODE>.tex</CODE> file.</P></DD><DT CLASS="dt-description"><B><TT>--files-from </TT></B><B><I>file</I></B></DT><DD CLASS="dd-description">  <P>Read file names to process in file `<I>file</I>' as if they were
given on the command line. Useful for program sources splitted in
several directories.</P></DD><DT CLASS="dt-description"><B><TT>-q</TT></B><B>, </B><B><TT>--quiet</TT></B></DT><DD CLASS="dd-description">  <P>Be quiet. Do not print anything except errors.</P></DD><DT CLASS="dt-description"><B><TT>-h</TT></B><B>, </B><B><TT>--help</TT></B></DT><DD CLASS="dd-description">  <P>Give a short summary of the options and exit.</P></DD><DT CLASS="dt-description"><B><TT>-v</TT></B><B>, </B><B><TT>--version</TT></B></DT><DD CLASS="dd-description">  <P>Print the version and exit.</P></DD></DL><H5 CLASS="paragraph">Index options</H5><P>  </P><P>Default behavior is to build an index, for the HTML output only, into
<TT>index.html</TT>.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>--no-index</TT></B></DT><DD CLASS="dd-description">  <P>Do not output the index.</P></DD><DT CLASS="dt-description"><B><TT>--multi-index</TT></B></DT><DD CLASS="dd-description">  <P>Generate one page for each category and each letter in the index,
together with a top page <TT>index.html</TT>.</P></DD></DL><H5 CLASS="paragraph">Table of contents option</H5><P>  </P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-toc</TT></B><B>, </B><B><TT>--table-of-contents</TT></B></DT><DD CLASS="dd-description">  <P>Insert a table of contents.
For a L<sup>A</sup>T<sub>E</sub>X output, it inserts a <CODE>\tableofcontents</CODE> at the
beginning of the document. For a HTML output, it builds a table of
contents into <TT>toc.html</TT>.</P></DD></DL><H5 CLASS="paragraph">Hyperlinks options</H5><DL CLASS="description"><DT CLASS="dt-description"><B><TT>--glob-from </TT></B><B><I>file</I></B></DT><DD CLASS="dd-description">  <P>Make references using <SPAN STYLE="font-variant:small-caps">Coq</SPAN> globalizations from file <I>file</I>. 
(Such globalizations are obtained with <SPAN STYLE="font-variant:small-caps">Coq</SPAN> option <TT>-dump-glob</TT>).</P></DD><DT CLASS="dt-description"><B><TT>--no-externals</TT></B></DT><DD CLASS="dd-description">  <P>Do not insert links to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library.</P></DD><DT CLASS="dt-description"><B><TT>--coqlib </TT></B><B><I>url</I></B></DT><DD CLASS="dd-description">  <P>Set base URL for the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> standard library (default is 
<TT>http://coq.inria.fr/library/</TT>).</P></DD><DT CLASS="dt-description"><B><TT>-R </TT></B><B><I>dir </I></B><B><I>coqdir</I></B></DT><DD CLASS="dd-description">  <P>Map physical directory <I>dir</I> to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> logical directory
<I>coqdir</I> (similarly to <SPAN STYLE="font-variant:small-caps">Coq</SPAN> option <TT>-R</TT>).</P><P>Note: option <TT>-R</TT> only has effect on the files
<EM>following</EM> it on the command line, so you will probably need
to put this option first.</P></DD></DL><H5 CLASS="paragraph">Contents options</H5><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-g</TT></B><B>, </B><B><TT>--gallina</TT></B></DT><DD CLASS="dd-description">  <P>Do not print proofs.</P></DD><DT CLASS="dt-description"><B><TT>-l</TT></B><B>, </B><B><TT>--light</TT></B></DT><DD CLASS="dd-description">  <P>Light mode. Suppress proofs (as with <TT>-g</TT>) and the following commands:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
[<TT>Recursive</TT>] <TT>Tactic Definition</TT>
</LI><LI CLASS="li-itemize"><TT>Hint / Hints</TT> 
</LI><LI CLASS="li-itemize"><TT>Require</TT>
</LI><LI CLASS="li-itemize"><TT>Transparent / Opaque</TT>
</LI><LI CLASS="li-itemize"><TT>Implicit Argument / Implicits</TT>
</LI><LI CLASS="li-itemize"><TT>Section / Variable / Hypothesis / End</TT>
</LI></UL></DD></DL><P>
The behavior of options <TT>-g</TT> and <TT>-l</TT> can be locally
overridden using the <TT>(* begin show *)</TT> &#X2026; <TT>(* end
show *)</TT> environment (see above).</P><H5 CLASS="paragraph">Language options</H5><P>  </P><P>Default behavior is to assume ASCII 7 bits input files.</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>-latin1</TT></B><B>, </B><B><TT>--latin1</TT></B></DT><DD CLASS="dd-description">  <P>Select ISO-8859-1 input files. It is equivalent to
<TT>&#X2013;inputenc latin1 &#X2013;charset iso-8859-1</TT>.</P></DD><DT CLASS="dt-description"><B><TT>-utf8</TT></B><B>, </B><B><TT>--utf8</TT></B></DT><DD CLASS="dd-description">  <P>Select UTF-8 (Unicode) input files. It is equivalent to
<TT>&#X2013;inputenc utf8 &#X2013;charset utf-8</TT>.
L<sup>A</sup>T<sub>E</sub>X UTF-8 support can be found at
<TT>http://www.ctan.org/tex-archive/macros/latex/contrib/supported/unicode/</TT>.</P></DD><DT CLASS="dt-description"><B><TT>--inputenc</TT></B><B> </B><B><I>string</I></B></DT><DD CLASS="dd-description">  <P>Give a L<sup>A</sup>T<sub>E</sub>X input encoding, as an option to L<sup>A</sup>T<sub>E</sub>X package
<TT>inputenc</TT>. </P></DD><DT CLASS="dt-description"><B><TT>--charset</TT></B><B> </B><B><I>string</I></B></DT><DD CLASS="dd-description">  <P>Specify the HTML character set, to be inserted in the HTML header.</P></DD></DL><H3 CLASS="subsection"><A NAME="htoc329">13.4.3</A>  The coqdoc L<sup>A</sup>T<sub>E</sub>X style file</H3><P>
<A NAME="section:coqdoc.sty"></A></P><P>In case you choose to produce a document without the default L<sup>A</sup>T<sub>E</sub>X
preamble (by using option <CODE>--no-preamble</CODE>), then you must insert
into your own preamble the command
</P><BLOCKQUOTE CLASS="quote">
<CODE>\usepackage{coqdoc}</CODE>
</BLOCKQUOTE><P>
Then you may alter the rendering of the document by
redefining some macros:
</P><DL CLASS="description"><DT CLASS="dt-description"><B><TT>coqdockw</TT></B><B>, </B><B><TT>coqdocid</TT></B></DT><DD CLASS="dd-description">   <P>The one-argument macros for typesetting keywords and identifiers.
Defaults are sans-serif for keywords and italic for identifiers.</P><P>For example, if you would like a slanted font for keywords, you
may insert 
</P><PRE CLASS="verbatim">     \renewcommand{\coqdockw}[1]{\textsl{#1}}
</PRE><P>anywhere between <CODE>\usepackage{coqdoc}</CODE> and
<CODE>\begin{document}</CODE>. </P></DD><DT CLASS="dt-description"><B><TT>coqdocmodule</TT></B></DT><DD CLASS="dd-description">   <P>One-argument macro for typesetting the title of a <CODE>.v</CODE> file.
Default is
</P><PRE CLASS="verbatim">\newcommand{\coqdocmodule}[1]{\section*{Module #1}}
</PRE><P>and you may redefine it using <CODE>\renewcommand</CODE>.</P></DD></DL><H2 CLASS="section"><A NAME="toc88"></A><A NAME="htoc330">13.5</A>  Exporting <SPAN STYLE="font-variant:small-caps">Coq</SPAN> theories to XML</H2><P><A NAME="Helm"></A>
<A NAME="@default719"></A>
<A NAME="@default720"></A></P><P>This section describes the exportation of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> theories to XML that
has been contributed by Claudio Sacerdoti Coen. Currently, the main
applications are the rendering and searching tool
developed within the HELM<SUP><A NAME="text22" HREF="#note22">1</A></SUP> and MoWGLI<SUP><A NAME="text23" HREF="#note23">2</A></SUP> projects mainly at the University of Bologna and
partly at INRIA-Sophia Antipolis.</P><H3 CLASS="subsection"><A NAME="htoc331">13.5.1</A>  Practical use of the XML exportation tool</H3><P>The basic way to export the logical content of a file into XML format
is to use <TT>coqc</TT> with option <TT>-xml</TT>. 
When the <TT>-xml</TT> flag is set, every definition or declaration is
immediately exported to XML once concluded.
The system environment variable <TT>COQ_XML_LIBRARY_ROOT</TT> must be
previously set to a directory in which the logical structure of the
exported objects is reflected.</P><P>For <TT>Makefile</TT> files generated by <CODE>coq_makefile</CODE> (see section
<A HREF="#Makefile">13.3</A>), it is sufficient to compile the files using
</P><BLOCKQUOTE CLASS="quotation">
<CODE>make COQ_XML=-xml</CODE>
</BLOCKQUOTE><P>
(or, equivalently, setting the environment variable <CODE>COQ_XML</CODE>)</P><P>To export a development to XML, the suggested procedure is then:</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
add to your own contribution a valid <CODE>Make</CODE> file and use
<CODE>coq_makefile</CODE> to generate the <CODE>Makefile</CODE> from the <CODE>Make</CODE>
file.<P><BR>
<B>Warning: </B>Since logical names are used to structure the XML
hierarchy, always add to the <CODE>Make</CODE> file at least one <CODE>"-R"</CODE>
option to map physical file names to logical module paths.
</P></LI><LI CLASS="li-enumerate">set the <CODE>COQ_XML_LIBRARY_ROOT</CODE> environment variable to
the directory where the XML file hierarchy must be physically
rooted.
</LI><LI CLASS="li-enumerate">compile your contribution with <CODE>"make COQ_XML=-xml"</CODE>
</LI></OL><P><BR>
<B>Remark: </B>In case the system variable <TT>COQ_XML_LIBRARY_ROOT</TT> is not set,
the output is done on the standard output. Also, the files are
compressed using <TT>gzip</TT> after creation. This is to save disk space
since the XML format is very verbose.</P><H3 CLASS="subsection"><A NAME="htoc332">13.5.2</A>  Reflection of the logical structure into the file system</H3><P>For each <SPAN STYLE="font-variant:small-caps">Coq</SPAN> logical object, several independent files associated
to this object are created. The structure of the long name of the
object is reflected in the directory structure of the file system.
E.g. an object of long name <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>.</TT><TT>&#X2026;</TT><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I> is exported to files in the
subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>/&#X2026;/<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB> of the directory 
bound to the environment variable <TT>COQ_XML_LIBRARY_ROOT</TT>.</P><H3 CLASS="subsection"><A NAME="htoc333">13.5.3</A>  What is exported?</H3><P>The XML exportation tool exports the logical content of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
theories. This covers global definitions (including lemmas, theorems,
...), global assumptions (parameters and axioms), local assumptions or
definitions, and inductive definitions.</P><P>Vernacular files are exported to <TT>.theory.xml</TT> files. 
Comments are pre-processed with <FONT COLOR=purple>coqdoc</FONT> (see section
<A HREF="#coqdoc">13.4</A>). Especially, they have to be enclosed within <TT>(**</TT>
and <TT>*)</TT> to be exported.</P><P>For each inductive definition of name
<I><FONT COLOR=maroon>ident</FONT></I><SUB>1</SUB>.&#X2026;.<I><FONT COLOR=maroon>ident</FONT></I><SUB><I>n</I></SUB>.<I><FONT COLOR=maroon>ident</FONT></I>, a file named <I><FONT COLOR=maroon>ident</FONT></I><TT>.ind.xml</TT> is created in the subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>/</TT><TT>&#X2026;</TT><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB> of the xml library root
directory. It contains the arities and constructors of the type. For mutual inductive definitions, the file is named after the
name of the first inductive type of the block.</P><P>For each global definition of base name <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>.</TT><TT>&#X2026;</TT><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, files named
<I><FONT COLOR=maroon>ident</FONT></I><TT>.con.body.xml</TT> and <I><FONT COLOR=maroon>ident</FONT></I><TT>.con.xml</TT> are created in the
subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>/</TT><TT>&#X2026;</TT><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>. They
respectively contain the body and the type of the definition.</P><P>For each global assumption of base name <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>.</TT><TT>&#X2026;</TT><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, a file
named <I><FONT COLOR=maroon>ident</FONT></I><TT>.con.xml</TT> is created in the subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>/</TT><TT>&#X2026;</TT><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB>. It contains the type of the
global assumption.</P><P>For each local assumption or definition of base name <I><FONT COLOR=maroon>ident</FONT></I> located
in sections <I><FONT COLOR=maroon>ident</FONT></I>'<SUB>1</SUB>, &#X2026;, <I><FONT COLOR=maroon>ident</FONT></I>'<SUB><I>p</I></SUB> of the module <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>2</TT></SUB><TT>.</TT><TT>&#X2026;</TT><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>.</TT><I><FONT COLOR=maroon>ident</FONT></I>, a file
named <I><FONT COLOR=maroon>ident</FONT></I><TT>.var.xml</TT> is created in the subdirectory <I><FONT COLOR=maroon>ident</FONT></I><SUB><TT>1</TT></SUB><TT>/</TT><TT>&#X2026;</TT><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><SUB><TT><I>n</I></TT></SUB><TT>/</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT>1</TT></SUB><TT>/&#X2026;/</TT><I><FONT COLOR=maroon>ident</FONT></I><TT>'</TT><SUB><TT><I>p</I></TT></SUB>.
It contains its type and, if a definition, its body.</P><P>In order to do proof-rendering (for example in natural language), some
redundant typing information is required, i.e. the type of at least
some of the subterms of the bodies and types of the CIC objects. These
types are called inner types and are exported to files of suffix <TT>.types.xml</TT> by the exportation tool.</P><H3 CLASS="subsection"><A NAME="htoc334">13.5.4</A>  Inner types</H3><P>
<A NAME="inner-types"></A></P><P>The type of a subterm of a construction is called an <EM>inner type</EM>
if it respects the following conditions.</P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
Its sort is <CODE>Prop</CODE><SUP><A NAME="text24" HREF="#note24">3</A></SUP>.
</LI><LI CLASS="li-enumerate">It is not a type cast nor an atomic term (variable, constructor or constant).
</LI><LI CLASS="li-enumerate">If it's root is an abstraction, then the root's parent node is
not an abstraction, i.e. only the type of the outer abstraction of
a block of nested abstractions is printed.
</LI></OL><P>The rationale for the 3<SUP><I>rd</I></SUP> condition is that the type of the inner
abstractions could be easily computed starting from the type of the
outer ones; moreover, the types of the inner abstractions requires a
lot of disk/memory space: removing the 3<SUP><I>rd</I></SUP> condition leads to XML
file that are two times as big as the ones exported applying the 3<SUP><I>rd</I></SUP>
condition.</P><H3 CLASS="subsection"><A NAME="htoc335">13.5.5</A>  Interactive exportation commands</H3><P>There are also commands to be used interactively in <TT>coqtop</TT>.</P><H4 CLASS="subsubsection"><TT>Print XML </TT><I><FONT COLOR=maroon>qualid</FONT></I></H4><P>
<A NAME="@default721"></A><A NAME="@command215"></A></P><P>If the variable <TT>COQ_XML_LIBRARY_ROOT</TT> is set, this command creates
files containing the logical content in XML format of <I><FONT COLOR=maroon>qualid</FONT></I>. If
the variable is not set, the result is displayed on the standard
output.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Print XML File </TT><I><FONT COLOR=maroon>string</FONT></I><TT> </TT><I><FONT COLOR=maroon>qualid</FONT></I><BR>
This writes the logical content of <I><FONT COLOR=maroon>qualid</FONT></I> in XML format to files
whose prefix is <I><FONT COLOR=maroon>string</FONT></I>.
</LI></OL><H4 CLASS="subsubsection"><TT>Show XML Proof</TT></H4><P>
<A NAME="@default722"></A><A NAME="@command216"></A></P><P>If the variable <TT>COQ_XML_LIBRARY_ROOT</TT> is set, this command creates
files containing the current proof in progress in XML format. It
writes also an XML file made of inner types. If the variable is not
set, the result is displayed on the standard output.</P><P><BR>
<B>Variants: </B></P><OL CLASS="enumerate" type=1><LI CLASS="li-enumerate">
<TT>Show XML File </TT><I><FONT COLOR=maroon>string</FONT></I><TT> Proof</TT><BR>
This writes the
logical content of <I><FONT COLOR=maroon>qualid</FONT></I> in XML format to files whose prefix is
<I><FONT COLOR=maroon>string</FONT></I>. 
</LI></OL><H3 CLASS="subsection"><A NAME="htoc336">13.5.6</A>  Applications: rendering, searching and publishing</H3><P>The HELM team at the University of Bologna has developed tools
exploiting the XML exportation of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> libraries. This covers
rendering, searching and publishing tools.</P><P>All these tools require a running http server and, if possible, a
MathML compliant browser. The procedure to install the suite of tools
ultimately allowing rendering and searching can be found on the HELM
web site <TT>http://helm.cs.unibo.it/library.html</TT>.</P><P>It may be easier though to upload your developments on the HELM http
server and to re-use the infrastructure running on it. This requires
publishing your development. To this aim, follow the instructions on
<TT>http://mowgli.cs.unibo.it</TT>.</P><P>Notice that the HELM server already hosts a copy of the standard
library of <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> user contributions.</P><H3 CLASS="subsection"><A NAME="htoc337">13.5.7</A>  Technical informations</H3><H4 CLASS="subsubsection">CIC with Explicit Named Substitutions</H4><P>The exported files are XML encoding of the lambda-terms used by the
<SPAN STYLE="font-variant:small-caps">Coq</SPAN> system. The implementative details of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system are hidden as much
as possible, so that the XML DTD is a straightforward encoding of the
Calculus of (Co)Inductive Constructions.</P><P>Nevertheless, there is a feature of the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> system that can not be
hidden in a completely satisfactory way: discharging (see Sect.<A HREF="Reference-Manual004.html#Section">2.4</A>).
In <SPAN STYLE="font-variant:small-caps">Coq</SPAN> it is possible
to open a section, declare variables and use them in the rest of the section
as if they were axiom declarations. Once the section is closed, every definition and theorem in the section is discharged by abstracting it over the section
variables. Variable declarations as well as section declarations are entirely
dropped. Since we are interested in an XML encoding of definitions and
theorems as close as possible to those directly provided the user, we
do not want to export discharged forms. Exporting non-discharged theorem
and definitions together with theorems that rely on the discharged forms
obliges the tools that work on the XML encoding to implement discharging to
achieve logical consistency. Moreover, the rendering of the files can be
misleading, since hyperlinks can be shown between occurrences of the discharge
form of a definition and the non-discharged definition, that are different
objects.</P><P>To overcome the previous limitations, Claudio Sacerdoti Coen developed in his
PhD. thesis an extension of CIC, called Calculus of (Co)Inductive Constructions
with Explicit Named Substitutions, that is a slight extension of CIC where
discharging is not necessary. The DTD of the exported XML files describes
constants, inductive types and variables of the Calculus of (Co)Inductive
Constructions with Explicit Named Substitutions. The conversion to the new
calculus is performed during the exportation phase.</P><P>The following example shows a very small <SPAN STYLE="font-variant:small-caps">Coq</SPAN> development together with its
version in CIC with Explicit Named Substitutions.</P><PRE CLASS="verbatim"># CIC version: #
Section S.
 Variable A : Prop.

 Definition impl := A -&gt; A.

 Theorem t : impl.           (* uses the undischarged form of impl *)
  Proof.
   exact (fun (a:A) =&gt; a).
  Qed.

End S.

Theorem t' : (impl False).   (* uses the discharged form of impl *)
 Proof.
  exact (t False).           (* uses the discharged form of t *)
 Qed.
</PRE><PRE CLASS="verbatim"># Corresponding CIC with Explicit Named Substitutions version: #
Section S.
 Variable A : Prop.
 
 Definition impl(A) := A -&gt; A. (* theorems and definitions are
                                  explicitly abstracted over the
                                  variables. The name is sufficient to
                                  completely describe the abstraction *)
 
 Theorem t(A) : impl.          (* impl where A is not instantiated *)
  Proof.
   exact (fun (a:A) =&gt; a).
  Qed.
 
End S.
 
Theorem t'() : impl{False/A}. (* impl where A is instantiated with False
                                 Notice that t' does not depend on A     *)
 Proof.
  exact t{False/A}.           (* t where A is instantiated with False *)
 Qed.
</PRE><P>Further details on the typing and reduction rules of the calculus can be
found in Claudio Sacerdoti Coen PhD. dissertation, where the consistency
of the calculus is also proved.</P><H4 CLASS="subsubsection">The CIC with Explicit Named Substitutions XML DTD</H4><P>A copy of the DTD can be found in the file &#X201C;<CODE>cic.dtd</CODE>&#X201D; in the
<CODE>contrib/xml</CODE> source directory of <SPAN STYLE="font-variant:small-caps">Coq</SPAN>.
The following is a very brief overview of the elements described in the DTD.</P><DL CLASS="description"><DT CLASS="dt-description">
</DT><DD CLASS="dd-description"><TT>&lt;ConstantType&gt;</TT>
is the root element of the files that correspond to constant types.
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>&lt;ConstantBody&gt;</TT>
is the root element of the files that correspond to constant bodies.
It is used only for closed definitions and theorems (i.e. when no
metavariable occurs in the body or type of the constant)
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>&lt;CurrentProof&gt;</TT>
is the root element of the file that correspond to the body of a constant
that depends on metavariables (e.g. unfinished proofs)
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>&lt;Variable&gt;</TT>
is the root element of the files that correspond to variables
</DD><DT CLASS="dt-description"></DT><DD CLASS="dd-description"><TT>&lt;InductiveTypes&gt;</TT>
is the root element of the files that correspond to blocks
of mutually defined inductive definitions
</DD></DL><P>The elements
<CODE>&lt;LAMBDA&gt;</CODE>, <CODE>&lt;CAST&gt;</CODE>, <CODE>&lt;PROD&gt;</CODE>, <CODE>&lt;REL&gt;</CODE>, <CODE>&lt;SORT&gt;</CODE>,
<CODE>&lt;APPLY&gt;</CODE>, <CODE>&lt;VAR&gt;</CODE>, <CODE>&lt;META&gt;</CODE>, <CODE>&lt;IMPLICIT&gt;</CODE>, <CODE>&lt;CONST&gt;</CODE>, <CODE>&lt;LETIN&gt;</CODE>, <CODE>&lt;MUTIND&gt;</CODE>, <CODE>&lt;MUTCONSTRUCT&gt;</CODE>, <CODE>&lt;MUTCASE&gt;</CODE>,
<CODE>&lt;FIX&gt;</CODE> and <CODE>&lt;COFIX&gt;</CODE> are used to encode the constructors of CIC.
The <CODE>sort</CODE> or <CODE>type</CODE> attribute of the element, if present, is
respectively the sort or the type of the term, that is a sort because of the
typing rules of CIC.</P><P>The element <CODE>&lt;instantiate&gt;</CODE> correspond to the application of an explicit
named substitution to its first argument, that is a reference to a definition
or declaration in the environment.</P><P>All the other elements are just syntactic sugar.</P><H2 CLASS="section"><A NAME="toc89"></A><A NAME="htoc338">13.6</A>  Embedded <SPAN STYLE="font-variant:small-caps">Coq</SPAN> phrases inside L<sup>A</sup>T<sub>E</sub>X documents</H2><P><A NAME="Latex"></A>
<A NAME="@default723"></A><A NAME="@default724"></A></P><P>When writing a documentation about a proof development, one may want
to insert <SPAN STYLE="font-variant:small-caps">Coq</SPAN> phrases inside a L<sup>A</sup>T<sub>E</sub>X document, possibly together with
the corresponding answers of the system. We provide a
mechanical way to process such <SPAN STYLE="font-variant:small-caps">Coq</SPAN> phrases embedded in L<sup>A</sup>T<sub>E</sub>X files: the
<TT>coq-tex</TT> filter. This filter extracts Coq phrases embedded in
LaTeX files, evaluates them, and insert the outcome of the evaluation
after each phrase.</P><P>Starting with a file <EM>file</EM><TT>.tex</TT> containing <SPAN STYLE="font-variant:small-caps">Coq</SPAN> phrases,
the <TT>coq-tex</TT> filter produces a file named <EM>file</EM><TT>.v.tex</TT> with
the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> outcome. </P><P>There are options to produce the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> parts in smaller font, italic,
between horizontal rules, etc.
See the man page of <TT>coq-tex</TT> for more details.</P><P><BR>
<B>Remark.</B> This Reference Manual and the Tutorial
have been completely produced with <TT>coq-tex</TT>.</P><H2 CLASS="section"><A NAME="toc90"></A><A NAME="htoc339">13.7</A>  <SPAN STYLE="font-variant:small-caps">Coq</SPAN> and <SPAN STYLE="font-variant:small-caps">GNU Emacs</SPAN></H2><P><A NAME="Emacs"></A><A NAME="@default725"></A></P><H3 CLASS="subsection"><A NAME="htoc340">13.7.1</A>  The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> Emacs mode</H3><P><SPAN STYLE="font-variant:small-caps">Coq</SPAN> comes with a Major mode for <SPAN STYLE="font-variant:small-caps">GNU Emacs</SPAN>, <TT>coq.el</TT>. This mode provides
syntax highlighting (assuming your <SPAN STYLE="font-variant:small-caps">GNU Emacs</SPAN> library provides
<TT>hilit19.el</TT>) and also a rudimentary indentation facility
in the style of the Caml <SPAN STYLE="font-variant:small-caps">GNU Emacs</SPAN> mode.</P><P>Add the following lines to your <CODE>.emacs</CODE> file:</P><PRE CLASS="verbatim">  (setq auto-mode-alist (cons '("\\.v$" . coq-mode) auto-mode-alist))
  (autoload 'coq-mode "coq" "Major mode for editing Coq vernacular." t)
</PRE><P>The <SPAN STYLE="font-variant:small-caps">Coq</SPAN> major mode is triggered by visiting a file with extension <TT>.v</TT>,
or manually with the command <CODE>M-x coq-mode</CODE>.
It gives you the correct syntax table for
the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> language, and also a rudimentary indentation facility:
</P><UL CLASS="itemize"><LI CLASS="li-itemize">
pressing <SPAN STYLE="font-variant:small-caps">Tab</SPAN> at the beginning of a line indents the line like
the line above;</LI><LI CLASS="li-itemize">extra <SPAN STYLE="font-variant:small-caps">Tab</SPAN>s increase the indentation level
(by 2 spaces by default);</LI><LI CLASS="li-itemize">M-<SPAN STYLE="font-variant:small-caps">Tab</SPAN> decreases the indentation level.
</LI></UL><P>An inferior mode to run <SPAN STYLE="font-variant:small-caps">Coq</SPAN> under Emacs, by Marco Maggesi, is also
included in the distribution, in file <TT>coq-inferior.el</TT>.
Instructions to use it are contained in this file.</P><H3 CLASS="subsection"><A NAME="htoc341">13.7.2</A>  Proof General</H3><P><A NAME="@default726"></A></P><P>Proof General is a generic interface for proof assistants based on
Emacs (or XEmacs). The main idea is that the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> commands you are
editing are sent to a <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel running behind Emacs and the
answers of the system automatically inserted into other Emacs buffers. 
Thus you don't need to copy-paste the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> material from your files
to the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel or conversely from the <SPAN STYLE="font-variant:small-caps">Coq</SPAN> toplevel to some
files. </P><P>Proof General is developped and distributed independently of the
system <SPAN STYLE="font-variant:small-caps">Coq</SPAN>. It is freely available at <CODE>proofgeneral.inf.ed.ac.uk</CODE>.</P><H2 CLASS="section"><A NAME="toc91"></A><A NAME="htoc342">13.8</A>  Module specification</H2><P><A NAME="gallina"></A><A NAME="@default727"></A></P><P>Given a <SPAN STYLE="font-variant:small-caps">Coq</SPAN> vernacular file, the <TT>gallina</TT> filter extracts its
specification (inductive types declarations, definitions, type of
lemmas and theorems), removing the proofs parts of the file. The <SPAN STYLE="font-variant:small-caps">Coq</SPAN>
file <EM>file</EM><TT>.v</TT> gives birth to the specification file
<EM>file</EM><TT>.g</TT> (where the suffix <TT>.g</TT> stands for <SPAN STYLE="font-variant:small-caps">Gallina</SPAN>).</P><P>See the man page of <TT>gallina</TT> for more details and options.</P><H2 CLASS="section"><A NAME="toc92"></A><A NAME="htoc343">13.9</A>  Man pages</H2><P><A NAME="ManPages"></A><A NAME="@default728"></A></P><P>There are man pages for the commands <TT>coqdep</TT>, <TT>gallina</TT> and
<TT>coq-tex</TT>. Man pages are installed at installation time
(see installation instructions in file <TT>INSTALL</TT>, step 6).</P><HR CLASS="footnoterule"><DL CLASS="thefootnotes"><DT CLASS="dt-thefootnotes">
<A NAME="note22" HREF="#text22">1</A></DT><DD CLASS="dd-thefootnotes">Hypertextual Electronic Library of
Mathematics
</DD><DT CLASS="dt-thefootnotes"><A NAME="note23" HREF="#text23">2</A></DT><DD CLASS="dd-thefootnotes">Mathematics on the Web, Get it by
Logic and Interfaces
</DD><DT CLASS="dt-thefootnotes"><A NAME="note24" HREF="#text24">3</A></DT><DD CLASS="dd-thefootnotes">or <TT>CProp</TT> which is the
"sort"-like definition used in C-CoRN (see
<TT>http://vacuumcleaner.cs.kun.nl/c-corn</TT>) to type
computationally relevant predicative propositions.
</DD></DL>
<HR>
<A HREF="Reference-Manual015.html"><IMG SRC="previous_motif.gif" ALT="Previous"></A>
<A HREF="toc.html"><IMG SRC="contents_motif.gif" ALT="Up"></A>
<A HREF="Reference-Manual017.html"><IMG SRC="next_motif.gif" ALT="Next"></A>
</BODY>
</HTML>
